{
  "0_0.txt": "{\n  \"file\": \"0_0.txt\",\n  \"assertion\": \"assertNull ( existing layout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existing layout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "0_1.txt": "{\n  \"file\": \"0_1.txt\",\n  \"assertion\": \"assertNull ( existingApplication )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingApplication ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingApplication\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_10.txt": "{\n  \"file\": \"0_10.txt\",\n  \"assertion\": \"assertNull ( existingContainer )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingContainer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingContainer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_11.txt": "{\n  \"file\": \"0_11.txt\",\n  \"assertion\": \"assertNull ( existingController )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingController ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingController\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_12.txt": "{\n  \"file\": \"0_12.txt\",\n  \"assertion\": \"assertNull ( existingModel )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingModel ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingModel\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_13.txt": "{\n  \"file\": \"0_13.txt\",\n  \"assertion\": \"assertNull ( existingPattern )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingPattern ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingPattern\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_14.txt": "{\n  \"file\": \"0_14.txt\",\n  \"assertion\": \"assertNull ( existingLayer )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLayer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingLayer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_15.txt": "{\n  \"file\": \"0_15.txt\",\n  \"assertion\": \"assertNull ( existingPosition )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingPosition ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingPosition\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_16.txt": "{\n  \"file\": \"0_16.txt\",\n  \"assertion\": \"assertNull ( existingRoute )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingRoute ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingRoute\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_17.txt": "{\n  \"file\": \"0_17.txt\",\n  \"assertion\": \"assertNull ( existingConfiguration )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingConfiguration ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingConfiguration\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_18.txt": "{\n  \"file\": \"0_18.txt\",\n  \"assertion\": \"assertNull ( existingWidget )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingWidget ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingWidget\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_19.txt": "{\n  \"file\": \"0_19.txt\",\n  \"assertion\": \"assertNull ( existingComponent )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingComponent ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingComponent\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_2.txt": "{\n  \"file\": \"0_2.txt\",\n  \"assertion\": \"assertNull ( existing Layout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existing Layout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "0_20.txt": "{\n  \"file\": \"0_20.txt\",\n  \"assertion\": \"assertNull ( existingFactory )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingFactory ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingFactory\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_21.txt": "{\n  \"file\": \"0_21.txt\",\n  \"assertion\": \"assertNull ( existingLayout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLayout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"existingLayout\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingLayout\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Layout\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "0_22.txt": "{\n  \"file\": \"0_22.txt\",\n  \"assertion\": \"assertNull (isting layout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull (isting layout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "0_23.txt": "{\n  \"file\": \"0_23.txt\",\n  \"assertion\": \"assertNull (existing layout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull (existing layout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "0_24.txt": "{\n  \"file\": \"0_24.txt\",\n  \"assertion\": \"assertNull ( existingGroup )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingGroup ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingGroup\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_25.txt": "{\n  \"file\": \"0_25.txt\",\n  \"assertion\": \"assertNull ( app layout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( app layout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "0_26.txt": "{\n  \"file\": \"0_26.txt\",\n  \"assertion\": \"assertNull ( existingLabel )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLabel ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingLabel\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_27.txt": "{\n  \"file\": \"0_27.txt\",\n  \"assertion\": \"assertNull ( existingFont )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingFont ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingFont\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_28.txt": "{\n  \"file\": \"0_28.txt\",\n  \"assertion\": \"assertNull ( existingAnimation )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingAnimation ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingAnimation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_29.txt": "{\n  \"file\": \"0_29.txt\",\n  \"assertion\": \"assertNull ( creating layout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( creating layout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "0_3.txt": "{\n  \"file\": \"0_3.txt\",\n  \"assertion\": \"assertNull ( existingLocation )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLocation ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingLocation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_4.txt": "{\n  \"file\": \"0_4.txt\",\n  \"assertion\": \"assertNull ( existingTemplate )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingTemplate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingTemplate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_5.txt": "{\n  \"file\": \"0_5.txt\",\n  \"assertion\": \"assertNull ( existingBuilder )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingBuilder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingBuilder\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_6.txt": "{\n  \"file\": \"0_6.txt\",\n  \"assertion\": \"assertNull ( existingView )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingView ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingView\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_7.txt": "{\n  \"file\": \"0_7.txt\",\n  \"assertion\": \"assertNull ( existingSession )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingSession ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingSession\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_8.txt": "{\n  \"file\": \"0_8.txt\",\n  \"assertion\": \"assertNull ( existingAppearance )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingAppearance ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existingAppearance\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "0_9.txt": "{\n  \"file\": \"0_9.txt\",\n  \"assertion\": \"assertNull ( existinglayout )\\r\\n\",\n  \"test\": \"class X {public void testRemove ( ) { Layout newLayout \\u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \\u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existinglayout ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\\r\\n\",\n  \"truth\": \"assertNull ( existingLayout )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"existinglayout\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_0.txt": "{\n  \"file\": \"10_0.txt\",\n  \"assertion\": \"assertNotNull ( molecule )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( molecule ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"molecule\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"molecule\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"IAtomContainer\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "10_1.txt": "{\n  \"file\": \"10_1.txt\",\n  \"assertion\": \"assertNotNull ( molecules )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( molecules ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"molecules\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_10.txt": "{\n  \"file\": \"10_10.txt\",\n  \"assertion\": \"assertNotNull ( orb )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( orb ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"orb\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_11.txt": "{\n  \"file\": \"10_11.txt\",\n  \"assertion\": \"assertNotNull ( collection )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( collection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"collection\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_12.txt": "{\n  \"file\": \"10_12.txt\",\n  \"assertion\": \"assertNotNull ( mixture )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mixture ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mixture\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_13.txt": "{\n  \"file\": \"10_13.txt\",\n  \"assertion\": \"assertNotNull ( lig )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( lig ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"lig\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_14.txt": "{\n  \"file\": \"10_14.txt\",\n  \"assertion\": \"assertNotNull ( bond )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( bond ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"bond\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_15.txt": "{\n  \"file\": \"10_15.txt\",\n  \"assertion\": \"assertNotNull ( 0 )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_16.txt": "{\n  \"file\": \"10_16.txt\",\n  \"assertion\": \"assertNotNull ( problem )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( problem ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"problem\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_17.txt": "{\n  \"file\": \"10_17.txt\",\n  \"assertion\": \"assertNotNull ( bro )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( bro ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"bro\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_18.txt": "{\n  \"file\": \"10_18.txt\",\n  \"assertion\": \"assertNotNull ( universe )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( universe ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"universe\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_19.txt": "{\n  \"file\": \"10_19.txt\",\n  \"assertion\": \"assertNotNull ( output )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( output ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"output\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_2.txt": "{\n  \"file\": \"10_2.txt\",\n  \"assertion\": \"assertNotNull ( mol )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mol ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mol\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_20.txt": "{\n  \"file\": \"10_20.txt\",\n  \"assertion\": \"assertNotNull ( movie )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( movie ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"movie\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_21.txt": "{\n  \"file\": \"10_21.txt\",\n  \"assertion\": \"assertNotNull ( mole )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mole ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mole\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_22.txt": "{\n  \"file\": \"10_22.txt\",\n  \"assertion\": \"assertNotNull ( circle )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( circle ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"circle\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_23.txt": "{\n  \"file\": \"10_23.txt\",\n  \"assertion\": \"assertNotNull ( brother )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( brother ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"brother\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_24.txt": "{\n  \"file\": \"10_24.txt\",\n  \"assertion\": \"assertNotNull ( maze )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( maze ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"maze\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_25.txt": "{\n  \"file\": \"10_25.txt\",\n  \"assertion\": \"assertNotNull ( noise )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( noise ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"noise\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_26.txt": "{\n  \"file\": \"10_26.txt\",\n  \"assertion\": \"assertNotNull ( residue )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( residue ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"residue\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_27.txt": "{\n  \"file\": \"10_27.txt\",\n  \"assertion\": \"assertNotNull ( twist )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( twist ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"twist\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_28.txt": "{\n  \"file\": \"10_28.txt\",\n  \"assertion\": \"assertNotNull ( manager )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( manager ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"manager\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_29.txt": "{\n  \"file\": \"10_29.txt\",\n  \"assertion\": \"assertNotNull ( } )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( } ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "10_3.txt": "{\n  \"file\": \"10_3.txt\",\n  \"assertion\": \"assertNotNull ( container )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( container ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"container\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_4.txt": "{\n  \"file\": \"10_4.txt\",\n  \"assertion\": \"assertNotNull ( smiles )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( smiles ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"smiles\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"smiles\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "10_5.txt": "{\n  \"file\": \"10_5.txt\",\n  \"assertion\": \"assertNotNull ( knob )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( knob ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"knob\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_6.txt": "{\n  \"file\": \"10_6.txt\",\n  \"assertion\": \"assertNotNull ( mixer )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mixer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mixer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_7.txt": "{\n  \"file\": \"10_7.txt\",\n  \"assertion\": \"assertNotNull ( coil )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( coil ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"coil\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_8.txt": "{\n  \"file\": \"10_8.txt\",\n  \"assertion\": \"assertNotNull ( compound )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( compound ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"compound\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "10_9.txt": "{\n  \"file\": \"10_9.txt\",\n  \"assertion\": \"assertNotNull ( element )\\r\\n\",\n  \"test\": \"class X {public void testAcyclic ( ) { String smiles \\u003d \\\"CCCCCCC\\\" ; SmilesParser smilesParser \\u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \\u003d smilesParser . parseSmiles ( smiles ) ; molecule \\u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( element ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \\u003d null ; try { mNew \\u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003eclone\\u003csp\\u003esource\\u003csp\\u003emolecule\\\" ) ; } IRingSet ringSet ; try { ringSet \\u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" , x ) ; } if ( ringSet \\u003d\\u003d null ) { throw new CDKException ( \\\"failure\\u003csp\\u003ein\\u003csp\\u003eSSSRFinder.findAllRings\\\" ) ; } List \\u003c Integer [ ] \\u003e rBondsArray \\u003d null ; util . List \\u003c List \\u003c Integer \\u003e \\u003e ringGroups \\u003d null ; rBondsArray \\u003d getRingSystem ( mNew , ringSet ) ; ringGroups \\u003d assignRingGroups ( rBondsArray ) ; for ( int i \\u003d 0 ; i \\u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e atomNos \\u003d null ; atomNos \\u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer \\u003e bondNos \\u003d null ; bondNos \\u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \\u003c Integer [ ] \\u003e atomNoPairs \\u003d null ; atomNoPairs \\u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \\u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \\u003d 0 ; x \\u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \\u003d 0 ; y \\u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \\u003c Integer \\u003e freeValencies \\u003d null ; freeValencies \\u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \\u003c Integer \\u003e bondOrders \\u003d new ArrayList \\u003c Integer \\u003e ( ) ; for ( int j \\u003d 0 ; j \\u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \\u003d 0 ; j \\u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \\u003d\\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( molecule )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"element\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "11_0.txt": "{\n  \"file\": \"11_0.txt\",\n  \"assertion\": \"assertEquals ( 2, 2S. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_1.txt": "{\n  \"file\": \"11_1.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 set. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_10.txt": "{\n  \"file\": \"11_10.txt\",\n  \"assertion\": \"assertEquals ( 3, 2S. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_11.txt": "{\n  \"file\": \"11_11.txt\",\n  \"assertion\": \"assertEquals ( 3, 2 set. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_12.txt": "{\n  \"file\": \"11_12.txt\",\n  \"assertion\": \"assertEquals ( 3, 2S. 4Max count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4Max count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_13.txt": "{\n  \"file\": \"11_13.txt\",\n  \"assertion\": \"assertEquals ( 3, 2S. 4C count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4C count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_14.txt": "{\n  \"file\": \"11_14.txt\",\n  \"assertion\": \"assertEquals ( 4, 2S. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_15.txt": "{\n  \"file\": \"11_15.txt\",\n  \"assertion\": \"assertEquals ( 3, 2 set. 4Max count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4Max count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_16.txt": "{\n  \"file\": \"11_16.txt\",\n  \"assertion\": \"assertEquals ( 3, 2 set. 4C count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4C count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_17.txt": "{\n  \"file\": \"11_17.txt\",\n  \"assertion\": \"assertEquals ( 4, 2 set. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2 set. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_18.txt": "{\n  \"file\": \"11_18.txt\",\n  \"assertion\": \"assertEquals ( 2, 2S. 4N2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4N2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_19.txt": "{\n  \"file\": \"11_19.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 set. 4N2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4N2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_2.txt": "{\n  \"file\": \"11_2.txt\",\n  \"assertion\": \"assertEquals ( 2, 2S. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_20.txt": "{\n  \"file\": \"11_20.txt\",\n  \"assertion\": \"assertEquals ( 4, 2S. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_21.txt": "{\n  \"file\": \"11_21.txt\",\n  \"assertion\": \"assertEquals ( 2, 2Offset. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2Offset. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_22.txt": "{\n  \"file\": \"11_22.txt\",\n  \"assertion\": \"assertEquals ( 4, 2 set. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2 set. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_23.txt": "{\n  \"file\": \"11_23.txt\",\n  \"assertion\": \"assertEquals ( 2, 2S. 4 column2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4 column2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_24.txt": "{\n  \"file\": \"11_24.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 set. 4 column2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4 column2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_25.txt": "{\n  \"file\": \"11_25.txt\",\n  \"assertion\": \"assertEquals ( 4, 2S. 4Max count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4Max count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_26.txt": "{\n  \"file\": \"11_26.txt\",\n  \"assertion\": \"assertEquals ( 4, 2S. 4C count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4C count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_27.txt": "{\n  \"file\": \"11_27.txt\",\n  \"assertion\": \"assertEquals ( 2, 2Offset. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2Offset. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_28.txt": "{\n  \"file\": \"11_28.txt\",\n  \"assertion\": \"assertEquals ( 5, 2S. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 5, 2S. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_29.txt": "{\n  \"file\": \"11_29.txt\",\n  \"assertion\": \"assertEquals ( 3, 2S. 4N2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4N2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_3.txt": "{\n  \"file\": \"11_3.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 set. 4 column count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4 column count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_4.txt": "{\n  \"file\": \"11_4.txt\",\n  \"assertion\": \"assertEquals ( 3, 2S. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_5.txt": "{\n  \"file\": \"11_5.txt\",\n  \"assertion\": \"assertEquals ( 2, 2S. 4Max count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4Max count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_6.txt": "{\n  \"file\": \"11_6.txt\",\n  \"assertion\": \"assertEquals ( 2, 2S. 4C count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4C count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_7.txt": "{\n  \"file\": \"11_7.txt\",\n  \"assertion\": \"assertEquals ( 3, 2 set. 4N count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4N count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_8.txt": "{\n  \"file\": \"11_8.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 set. 4Max count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4Max count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "11_9.txt": "{\n  \"file\": \"11_9.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 set. 4C count ( ) )\\r\\n\",\n  \"test\": \"class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \\u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \\u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4C count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getColumnCount() { return keys . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, resultSet. getColumnCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_0.txt": "{\n  \"file\": \"12_0.txt\",\n  \"assertion\": \"assertEquals ( set 3, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_1.txt": "{\n  \"file\": \"12_1.txt\",\n  \"assertion\": \"assertEquals ( set 3, set ) )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_10.txt": "{\n  \"file\": \"12_10.txt\",\n  \"assertion\": \"assertEquals ( set1, set1 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"set1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"set1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "12_11.txt": "{\n  \"file\": \"12_11.txt\",\n  \"assertion\": \"assertEquals ( set 3, set3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_12.txt": "{\n  \"file\": \"12_12.txt\",\n  \"assertion\": \"assertEquals ( set3, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set3, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_13.txt": "{\n  \"file\": \"12_13.txt\",\n  \"assertion\": \"assertEquals ( set 3, set0 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_14.txt": "{\n  \"file\": \"12_14.txt\",\n  \"assertion\": \"assertEquals ( set0, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set0, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_15.txt": "{\n  \"file\": \"12_15.txt\",\n  \"assertion\": \"assertEquals ( set2, set ) )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_16.txt": "{\n  \"file\": \"12_16.txt\",\n  \"assertion\": \"assertEquals ( set1, set2 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"set2\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"set1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"OclOrderedSet\\\\u003cString\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"set2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"OclOrderedSet\\\\u003cString\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "12_17.txt": "{\n  \"file\": \"12_17.txt\",\n  \"assertion\": \"assertEquals ( set2, set1 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"set1\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"set2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"OclOrderedSet\\\\u003cString\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"set1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"OclOrderedSet\\\\u003cString\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "12_18.txt": "{\n  \"file\": \"12_18.txt\",\n  \"assertion\": \"assertEquals ( set 3, set4 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_19.txt": "{\n  \"file\": \"12_19.txt\",\n  \"assertion\": \"assertEquals ( set4, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set4, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_2.txt": "{\n  \"file\": \"12_2.txt\",\n  \"assertion\": \"assertEquals ( set 3, set1 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_20.txt": "{\n  \"file\": \"12_20.txt\",\n  \"assertion\": \"assertEquals ( set2, set2 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"set2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"set2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "12_21.txt": "{\n  \"file\": \"12_21.txt\",\n  \"assertion\": \"assertEquals ( set 3, set5 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_22.txt": "{\n  \"file\": \"12_22.txt\",\n  \"assertion\": \"assertEquals ( set5, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set5, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_23.txt": "{\n  \"file\": \"12_23.txt\",\n  \"assertion\": \"assertEquals ( set\\\", set ) )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\\\", set ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_24.txt": "{\n  \"file\": \"12_24.txt\",\n  \"assertion\": \"assertEquals ( set 3, setified )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, setified ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_25.txt": "{\n  \"file\": \"12_25.txt\",\n  \"assertion\": \"assertEquals ( set\\\", set1 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\\\", set1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_26.txt": "{\n  \"file\": \"12_26.txt\",\n  \"assertion\": \"assertEquals ( set1, set\\\" )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_27.txt": "{\n  \"file\": \"12_27.txt\",\n  \"assertion\": \"assertEquals ( set 3, set8 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set8 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_28.txt": "{\n  \"file\": \"12_28.txt\",\n  \"assertion\": \"assertEquals ( set\\\", set2 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\\\", set2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_29.txt": "{\n  \"file\": \"12_29.txt\",\n  \"assertion\": \"assertEquals ( set2, set\\\" )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_3.txt": "{\n  \"file\": \"12_3.txt\",\n  \"assertion\": \"assertEquals ( set1, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_4.txt": "{\n  \"file\": \"12_4.txt\",\n  \"assertion\": \"assertEquals ( set 3, set2 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_5.txt": "{\n  \"file\": \"12_5.txt\",\n  \"assertion\": \"assertEquals ( set2, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_6.txt": "{\n  \"file\": \"12_6.txt\",\n  \"assertion\": \"assertEquals ( set\\\", set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\\\", set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_7.txt": "{\n  \"file\": \"12_7.txt\",\n  \"assertion\": \"assertEquals ( set 3, set\\\" )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_8.txt": "{\n  \"file\": \"12_8.txt\",\n  \"assertion\": \"assertEquals ( set{, set 3 )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set{, set 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "12_9.txt": "{\n  \"file\": \"12_9.txt\",\n  \"assertion\": \"assertEquals ( set1, set ) )\\r\\n\",\n  \"test\": \"class X {public void testAddAll ( ) { OclOrderedSet \\u003c String \\u003e set1 ; OclOrderedSet \\u003c String \\u003e set2 ; OclOrderedSet \\u003c String \\u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set2 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; set3 \\u003d new OclOrderedSet \\u003c String \\u003e ( ) ; object1 \\u003d \\\"1\\\" ; object2 \\u003d \\\"2\\\" ; object3 \\u003d \\\"3\\\" ; object4 \\u003d \\\"4\\\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( set3, set1 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_0.txt": "{\n  \"file\": \"13_0.txt\",\n  \"assertion\": \"assertFalse ( answer. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_1.txt": "{\n  \"file\": \"13_1.txt\",\n  \"assertion\": \"assertFalse ( answer. result result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. result result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_10.txt": "{\n  \"file\": \"13_10.txt\",\n  \"assertion\": \"assertFalse ( answer. test result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. test result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_11.txt": "{\n  \"file\": \"13_11.txt\",\n  \"assertion\": \"assertFalse ( answer. to result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. to result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_12.txt": "{\n  \"file\": \"13_12.txt\",\n  \"assertion\": \"assertFalse ( answers. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answers. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_13.txt": "{\n  \"file\": \"13_13.txt\",\n  \"assertion\": \"assertFalse ( answer. are result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. are result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_14.txt": "{\n  \"file\": \"13_14.txt\",\n  \"assertion\": \"assertFalse ( answer. check result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. check result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_15.txt": "{\n  \"file\": \"13_15.txt\",\n  \"assertion\": \"assertFalse ( answer. got result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. got result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_16.txt": "{\n  \"file\": \"13_16.txt\",\n  \"assertion\": \"assertFalse ( answers. result result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answers. result result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_17.txt": "{\n  \"file\": \"13_17.txt\",\n  \"assertion\": \"assertFalse ( answer. r result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. r result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_18.txt": "{\n  \"file\": \"13_18.txt\",\n  \"assertion\": \"assertFalse ( answer. given result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. given result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_19.txt": "{\n  \"file\": \"13_19.txt\",\n  \"assertion\": \"assertFalse ( answer. int result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. int result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_2.txt": "{\n  \"file\": \"13_2.txt\",\n  \"assertion\": \"assertFalse ( answer. return result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. return result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_20.txt": "{\n  \"file\": \"13_20.txt\",\n  \"assertion\": \"assertFalse ( response. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( response. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_21.txt": "{\n  \"file\": \"13_21.txt\",\n  \"assertion\": \"assertFalse ( reply. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( reply. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_22.txt": "{\n  \"file\": \"13_22.txt\",\n  \"assertion\": \"assertFalse ( answered. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answered. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_23.txt": "{\n  \"file\": \"13_23.txt\",\n  \"assertion\": \"assertFalse ( answer. responseResponse ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. responseResponse ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"responseResponse\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "13_24.txt": "{\n  \"file\": \"13_24.txt\",\n  \"assertion\": \"assertFalse ( answer. returns result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. returns result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_25.txt": "{\n  \"file\": \"13_25.txt\",\n  \"assertion\": \"assertFalse (answer. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse (answer. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_26.txt": "{\n  \"file\": \"13_26.txt\",\n  \"assertion\": \"assertFalse ( answering. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answering. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_27.txt": "{\n  \"file\": \"13_27.txt\",\n  \"assertion\": \"assertFalse ( answer. responseresult ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. responseresult ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"responseresult\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "13_28.txt": "{\n  \"file\": \"13_28.txt\",\n  \"assertion\": \"assertFalse ( result. response result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( result. response result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_29.txt": "{\n  \"file\": \"13_29.txt\",\n  \"assertion\": \"assertFalse ( response. result result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( response. result result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_3.txt": "{\n  \"file\": \"13_3.txt\",\n  \"assertion\": \"assertFalse ( answer. user result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. user result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_4.txt": "{\n  \"file\": \"13_4.txt\",\n  \"assertion\": \"assertFalse ( answer. is result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. is result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_5.txt": "{\n  \"file\": \"13_5.txt\",\n  \"assertion\": \"assertFalse ( answer. use result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. use result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_6.txt": "{\n  \"file\": \"13_6.txt\",\n  \"assertion\": \"assertFalse ( answer. get result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. get result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_7.txt": "{\n  \"file\": \"13_7.txt\",\n  \"assertion\": \"assertFalse ( answer. set result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. set result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_8.txt": "{\n  \"file\": \"13_8.txt\",\n  \"assertion\": \"assertFalse ( answer. can result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. can result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "13_9.txt": "{\n  \"file\": \"13_9.txt\",\n  \"assertion\": \"assertFalse ( answer. has result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \\\"BrocadeVcsResource\\\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \\u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \\u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. has result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getResult() { return this . result ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( answer. getResult ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "14_0.txt": "{\n  \"file\": \"14_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_1.txt": "{\n  \"file\": \"14_1.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_10.txt": "{\n  \"file\": \"14_10.txt\",\n  \"assertion\": \"assertEquals ( expected, expecting )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, expecting ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_11.txt": "{\n  \"file\": \"14_11.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_12.txt": "{\n  \"file\": \"14_12.txt\",\n  \"assertion\": \"assertEquals (expected, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals (expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_13.txt": "{\n  \"file\": \"14_13.txt\",\n  \"assertion\": \"assertEquals ( unexpected, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( unexpected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_14.txt": "{\n  \"file\": \"14_14.txt\",\n  \"assertion\": \"assertEquals ( expected, unexpected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, unexpected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_15.txt": "{\n  \"file\": \"14_15.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_16.txt": "{\n  \"file\": \"14_16.txt\",\n  \"assertion\": \"assertEquals ( ast, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( ast, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ast\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_17.txt": "{\n  \"file\": \"14_17.txt\",\n  \"assertion\": \"assertEquals ( expected, ast )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, ast ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ast\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_18.txt": "{\n  \"file\": \"14_18.txt\",\n  \"assertion\": \"assertEquals ( 3, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( 3, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_19.txt": "{\n  \"file\": \"14_19.txt\",\n  \"assertion\": \"assertEquals ( expected, 3 )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_2.txt": "{\n  \"file\": \"14_2.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_20.txt": "{\n  \"file\": \"14_20.txt\",\n  \"assertion\": \"assertEquals ( 2, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( 2, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_21.txt": "{\n  \"file\": \"14_21.txt\",\n  \"assertion\": \"assertEquals ( expected, 2 )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_22.txt": "{\n  \"file\": \"14_22.txt\",\n  \"assertion\": \"assertEquals ( 1, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( 1, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_23.txt": "{\n  \"file\": \"14_23.txt\",\n  \"assertion\": \"assertEquals ( 8, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( 8, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_24.txt": "{\n  \"file\": \"14_24.txt\",\n  \"assertion\": \"assertEquals ( string, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( string, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"string\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_25.txt": "{\n  \"file\": \"14_25.txt\",\n  \"assertion\": \"assertEquals ( expected, string )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, string ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"string\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_26.txt": "{\n  \"file\": \"14_26.txt\",\n  \"assertion\": \"assertEquals ( str, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( str, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"str\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_27.txt": "{\n  \"file\": \"14_27.txt\",\n  \"assertion\": \"assertEquals ( line, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( line, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"line\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_28.txt": "{\n  \"file\": \"14_28.txt\",\n  \"assertion\": \"assertEquals ( expected, line )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, line ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"line\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_29.txt": "{\n  \"file\": \"14_29.txt\",\n  \"assertion\": \"assertEquals ( body, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( body, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"body\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_3.txt": "{\n  \"file\": \"14_3.txt\",\n  \"assertion\": \"assertEquals (pected, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals (pected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_4.txt": "{\n  \"file\": \"14_4.txt\",\n  \"assertion\": \"assertEquals ( code, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( code, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"code\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "14_5.txt": "{\n  \"file\": \"14_5.txt\",\n  \"assertion\": \"assertEquals ( expected, code )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, code ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"code\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"code\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "14_6.txt": "{\n  \"file\": \"14_6.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "14_7.txt": "{\n  \"file\": \"14_7.txt\",\n  \"assertion\": \"assertEquals ( tree, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( tree, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tree\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"ParseTree\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"incompatible type\"\n}",
  "14_8.txt": "{\n  \"file\": \"14_8.txt\",\n  \"assertion\": \"assertEquals ( expected, tree )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expected, tree ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tree\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"tree\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"ParseTree\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"incompatible type\"\n}",
  "14_9.txt": "{\n  \"file\": \"14_9.txt\",\n  \"assertion\": \"assertEquals ( expecting, expected )\\r\\n\",\n  \"test\": \"class X {public void test10 ( ) { String code \\u003d \\\"a\\u003csp\\u003e\\u003d\\u003csp\\u003e!(2\\u003csp\\u003e|\\u003csp\\u003e2\\u003csp\\u003exor\\u003csp\\u003e2\\u003csp\\u003e*\\u003csp\\u003e2)\\\" ; String expected \\u003d \\\"2\\u003csp\\u003e2\\u003csp\\u003eMUL\\u003csp\\u003e2\\u003csp\\u003eXOR\\u003csp\\u003e2\\u003csp\\u003eOR\\u003csp\\u003eNOT\\u003csp\\u003e0\\u003csp\\u003eMSTORE\\\" ; SerpentParser parser \\u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \\u003d parser . parse ( ) ; String result \\u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \\u003d result . replaceAll ( \\\"\\\\\\\\s+\\\" , \\\"\\u003csp\\u003e\\\" ) ; result \\u003d result . trim ( ) ; assertEquals ( expecting, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse() { RLPList paramsList \\u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \\u003d new ArrayList ( ) ; for ( int i \\u003d 1 ; i \\u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \\u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \\u003d true ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "15_0.txt": "{\n  \"file\": \"15_0.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_1.txt": "{\n  \"file\": \"15_1.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_10.txt": "{\n  \"file\": \"15_10.txt\",\n  \"assertion\": \"assertEquals ( 5, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 5, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_11.txt": "{\n  \"file\": \"15_11.txt\",\n  \"assertion\": \"assertEquals ( 7, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 7, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_12.txt": "{\n  \"file\": \"15_12.txt\",\n  \"assertion\": \"assertEquals ( 3, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 3, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_13.txt": "{\n  \"file\": \"15_13.txt\",\n  \"assertion\": \"assertEquals ( 4, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 4, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_14.txt": "{\n  \"file\": \"15_14.txt\",\n  \"assertion\": \"assertEquals ( 6, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 6, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_15.txt": "{\n  \"file\": \"15_15.txt\",\n  \"assertion\": \"assertEquals ( 5, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 5, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_16.txt": "{\n  \"file\": \"15_16.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 2. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_17.txt": "{\n  \"file\": \"15_17.txt\",\n  \"assertion\": \"assertEquals ( 8, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 8, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_18.txt": "{\n  \"file\": \"15_18.txt\",\n  \"assertion\": \"assertEquals ( 9, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 9, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_19.txt": "{\n  \"file\": \"15_19.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. length ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 2. length ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_2.txt": "{\n  \"file\": \"15_2.txt\",\n  \"assertion\": \"assertEquals ( 0, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_20.txt": "{\n  \"file\": \"15_20.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 2. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_21.txt": "{\n  \"file\": \"15_21.txt\",\n  \"assertion\": \"assertEquals ( 0, 2. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 2. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_22.txt": "{\n  \"file\": \"15_22.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 0. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_23.txt": "{\n  \"file\": \"15_23.txt\",\n  \"assertion\": \"assertEquals ( 8, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 8, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_24.txt": "{\n  \"file\": \"15_24.txt\",\n  \"assertion\": \"assertEquals ( 9, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 9, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_25.txt": "{\n  \"file\": \"15_25.txt\",\n  \"assertion\": \"assertEquals ( 10, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 10, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_26.txt": "{\n  \"file\": \"15_26.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. length ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 2. length ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_27.txt": "{\n  \"file\": \"15_27.txt\",\n  \"assertion\": \"assertEquals ( 0, 2. length ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 2. length ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_28.txt": "{\n  \"file\": \"15_28.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. length ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 0. length ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_29.txt": "{\n  \"file\": \"15_29.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 0. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_3.txt": "{\n  \"file\": \"15_3.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_4.txt": "{\n  \"file\": \"15_4.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_5.txt": "{\n  \"file\": \"15_5.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_6.txt": "{\n  \"file\": \"15_6.txt\",\n  \"assertion\": \"assertEquals ( 7, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 7, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_7.txt": "{\n  \"file\": \"15_7.txt\",\n  \"assertion\": \"assertEquals ( 3, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 3, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_8.txt": "{\n  \"file\": \"15_8.txt\",\n  \"assertion\": \"assertEquals ( 4, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 4, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "15_9.txt": "{\n  \"file\": \"15_9.txt\",\n  \"assertion\": \"assertEquals ( 6, 2. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetJavaClassesByRegExp ( ) { String regexp \\u003d \\\".*Lock.*\\\" ; Collection result \\u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 6, 2. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 6, result. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "16_0.txt": "{\n  \"file\": \"16_0.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_1.txt": "{\n  \"file\": \"16_1.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_10.txt": "{\n  \"file\": \"16_10.txt\",\n  \"assertion\": \"assertEquals ( tx, output [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"output[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_11.txt": "{\n  \"file\": \"16_11.txt\",\n  \"assertion\": \"assertEquals ( tx, result [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_12.txt": "{\n  \"file\": \"16_12.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 10 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 10 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[10]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_13.txt": "{\n  \"file\": \"16_13.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 100 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 100 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[100]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_14.txt": "{\n  \"file\": \"16_14.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 15 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 15 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[15]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_15.txt": "{\n  \"file\": \"16_15.txt\",\n  \"assertion\": \"assertEquals ( tx, ret [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, ret [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_16.txt": "{\n  \"file\": \"16_16.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 4 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 4 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[4]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_17.txt": "{\n  \"file\": \"16_17.txt\",\n  \"assertion\": \"assertEquals ( tx, test [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, test [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"test[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_18.txt": "{\n  \"file\": \"16_18.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 15 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 15 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[15]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_19.txt": "{\n  \"file\": \"16_19.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 4 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 4 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[4]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_2.txt": "{\n  \"file\": \"16_2.txt\",\n  \"assertion\": \"assertEquals ( tx, output [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"output[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_20.txt": "{\n  \"file\": \"16_20.txt\",\n  \"assertion\": \"assertEquals ( tx, output [ 10 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 10 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"output[10]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_21.txt": "{\n  \"file\": \"16_21.txt\",\n  \"assertion\": \"assertEquals ( tx, output [ 100 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 100 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"output[100]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_22.txt": "{\n  \"file\": \"16_22.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 16 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 16 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[16]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_23.txt": "{\n  \"file\": \"16_23.txt\",\n  \"assertion\": \"assertEquals ( tx, result [ 10 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 10 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result[10]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_24.txt": "{\n  \"file\": \"16_24.txt\",\n  \"assertion\": \"assertEquals ( tx, result [ 100 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 100 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result[100]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_25.txt": "{\n  \"file\": \"16_25.txt\",\n  \"assertion\": \"assertEquals ( tx, 2 [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 2 [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_26.txt": "{\n  \"file\": \"16_26.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[2]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_27.txt": "{\n  \"file\": \"16_27.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 16 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 16 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[16]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_28.txt": "{\n  \"file\": \"16_28.txt\",\n  \"assertion\": \"assertEquals ( tx, target [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, target [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"target[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_29.txt": "{\n  \"file\": \"16_29.txt\",\n  \"assertion\": \"assertEquals ( tx, return [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, return [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "16_3.txt": "{\n  \"file\": \"16_3.txt\",\n  \"assertion\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_4.txt": "{\n  \"file\": \"16_4.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_5.txt": "{\n  \"file\": \"16_5.txt\",\n  \"assertion\": \"assertEquals ( tx, expected [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_6.txt": "{\n  \"file\": \"16_6.txt\",\n  \"assertion\": \"assertEquals ( tx, response [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, response [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"response[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_7.txt": "{\n  \"file\": \"16_7.txt\",\n  \"assertion\": \"assertEquals ( tx, out [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, out [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"out[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_8.txt": "{\n  \"file\": \"16_8.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 10 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 10 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[10]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "16_9.txt": "{\n  \"file\": \"16_9.txt\",\n  \"assertion\": \"assertEquals ( tx, 0 [ 100 ] )\\r\\n\",\n  \"test\": \"class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \\u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \\u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \\u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 100 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \\u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( tx, result [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"tx\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tx\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Transaction\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0[100]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_0.txt": "{\n  \"file\": \"17_0.txt\",\n  \"assertion\": \"assertNull ( form )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( form ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"form\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"form\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"CE\\\\u003cString\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "17_1.txt": "{\n  \"file\": \"17_1.txt\",\n  \"assertion\": \"assertNull (form )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull (form ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"form\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"form\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"CE\\\\u003cString\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "17_10.txt": "{\n  \"file\": \"17_10.txt\",\n  \"assertion\": \"assertNull ( label )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( label ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"label\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_11.txt": "{\n  \"file\": \"17_11.txt\",\n  \"assertion\": \"assertNull ( text )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( text ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"text\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_12.txt": "{\n  \"file\": \"17_12.txt\",\n  \"assertion\": \"assertNull ( question )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( question ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"question\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_13.txt": "{\n  \"file\": \"17_13.txt\",\n  \"assertion\": \"assertNull ( parent )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( parent ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"parent\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_14.txt": "{\n  \"file\": \"17_14.txt\",\n  \"assertion\": \"assertNull ( hand )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( hand ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hand\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_15.txt": "{\n  \"file\": \"17_15.txt\",\n  \"assertion\": \"assertNull ( word )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( word ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"word\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_16.txt": "{\n  \"file\": \"17_16.txt\",\n  \"assertion\": \"assertNull ( type )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( type ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"type\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_17.txt": "{\n  \"file\": \"17_17.txt\",\n  \"assertion\": \"assertNull ( answer )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( answer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"answer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_18.txt": "{\n  \"file\": \"17_18.txt\",\n  \"assertion\": \"assertNull ( model )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( model ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"model\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_19.txt": "{\n  \"file\": \"17_19.txt\",\n  \"assertion\": \"assertNull ( term )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( term ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"term\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_2.txt": "{\n  \"file\": \"17_2.txt\",\n  \"assertion\": \"assertNull ( Form )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( Form ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Form\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_20.txt": "{\n  \"file\": \"17_20.txt\",\n  \"assertion\": \"assertNull ( reform )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( reform ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"reform\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_21.txt": "{\n  \"file\": \"17_21.txt\",\n  \"assertion\": \"assertNull ( sign )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( sign ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"sign\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_22.txt": "{\n  \"file\": \"17_22.txt\",\n  \"assertion\": \"assertNull ( list )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( list ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"list\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_23.txt": "{\n  \"file\": \"17_23.txt\",\n  \"assertion\": \"assertNull ( ad )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( ad ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ad\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_24.txt": "{\n  \"file\": \"17_24.txt\",\n  \"assertion\": \"assertNull ( user )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( user ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"user\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_25.txt": "{\n  \"file\": \"17_25.txt\",\n  \"assertion\": \"assertNull ( page )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( page ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"page\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_26.txt": "{\n  \"file\": \"17_26.txt\",\n  \"assertion\": \"assertNull ( stream )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( stream ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"stream\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_27.txt": "{\n  \"file\": \"17_27.txt\",\n  \"assertion\": \"assertNull ( control )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( control ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"control\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_28.txt": "{\n  \"file\": \"17_28.txt\",\n  \"assertion\": \"assertNull ( board )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( board ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"board\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_29.txt": "{\n  \"file\": \"17_29.txt\",\n  \"assertion\": \"assertNull ( FORM )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( FORM ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"FORM\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_3.txt": "{\n  \"file\": \"17_3.txt\",\n  \"assertion\": \"assertNull ( name )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_4.txt": "{\n  \"file\": \"17_4.txt\",\n  \"assertion\": \"assertNull ( forms )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( forms ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"forms\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_5.txt": "{\n  \"file\": \"17_5.txt\",\n  \"assertion\": \"assertNull ( field )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( field ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"field\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_6.txt": "{\n  \"file\": \"17_6.txt\",\n  \"assertion\": \"assertNull ( test )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( test ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"test\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_7.txt": "{\n  \"file\": \"17_7.txt\",\n  \"assertion\": \"assertNull ( body )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( body ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"body\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_8.txt": "{\n  \"file\": \"17_8.txt\",\n  \"assertion\": \"assertNull ( post )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( post ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"post\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "17_9.txt": "{\n  \"file\": \"17_9.txt\",\n  \"assertion\": \"assertNull ( content )\\r\\n\",\n  \"test\": \"class X {public void formNullTest ( ) { CE \\u003c String \\u003e form \\u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( content ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \\u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( form )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"content\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "18_0.txt": "{\n  \"file\": \"18_0.txt\",\n  \"assertion\": \"assertFalse ( panel. page v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. page v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_1.txt": "{\n  \"file\": \"18_1.txt\",\n  \"assertion\": \"assertFalse ( panel. button v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. button v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_10.txt": "{\n  \"file\": \"18_10.txt\",\n  \"assertion\": \"assertFalse ( panel. pageP visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. pageP visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_11.txt": "{\n  \"file\": \"18_11.txt\",\n  \"assertion\": \"assertFalse ( panel. pageTV visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. pageTV visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_12.txt": "{\n  \"file\": \"18_12.txt\",\n  \"assertion\": \"assertFalse ( panel. is v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. is v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_13.txt": "{\n  \"file\": \"18_13.txt\",\n  \"assertion\": \"assertFalse ( panel. can v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. can v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_14.txt": "{\n  \"file\": \"18_14.txt\",\n  \"assertion\": \"assertFalse ( panel. show v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. show v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_15.txt": "{\n  \"file\": \"18_15.txt\",\n  \"assertion\": \"assertFalse ( panel. pageView visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. pageView visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_16.txt": "{\n  \"file\": \"18_16.txt\",\n  \"assertion\": \"assertFalse ( panel. button v invisible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. button v invisible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_17.txt": "{\n  \"file\": \"18_17.txt\",\n  \"assertion\": \"assertFalse ( panel. pagev visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. pagev visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_18.txt": "{\n  \"file\": \"18_18.txt\",\n  \"assertion\": \"assertFalse ( panel. buttonP visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. buttonP visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_19.txt": "{\n  \"file\": \"18_19.txt\",\n  \"assertion\": \"assertFalse ( panel. check v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. check v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_2.txt": "{\n  \"file\": \"18_2.txt\",\n  \"assertion\": \"assertFalse ( panel. user v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. user v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_20.txt": "{\n  \"file\": \"18_20.txt\",\n  \"assertion\": \"assertFalse ( panel. buttonTV visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. buttonTV visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_21.txt": "{\n  \"file\": \"18_21.txt\",\n  \"assertion\": \"assertFalse ( panel. page V visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. page V visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_22.txt": "{\n  \"file\": \"18_22.txt\",\n  \"assertion\": \"assertFalse ( panel. buttonView visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. buttonView visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_23.txt": "{\n  \"file\": \"18_23.txt\",\n  \"assertion\": \"assertFalse ( panel. has v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. has v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_24.txt": "{\n  \"file\": \"18_24.txt\",\n  \"assertion\": \"assertFalse ( panel. page vabled ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. page vabled ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_25.txt": "{\n  \"file\": \"18_25.txt\",\n  \"assertion\": \"assertFalse ( panel. buttonv visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. buttonv visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_26.txt": "{\n  \"file\": \"18_26.txt\",\n  \"assertion\": \"assertFalse ( panel. user v accessible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. user v accessible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_27.txt": "{\n  \"file\": \"18_27.txt\",\n  \"assertion\": \"assertFalse ( panel. pageVersion visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. pageVersion visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_28.txt": "{\n  \"file\": \"18_28.txt\",\n  \"assertion\": \"assertFalse ( panel. view v accessible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. view v accessible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_29.txt": "{\n  \"file\": \"18_29.txt\",\n  \"assertion\": \"assertFalse ( panel. pageG visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. pageG visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_3.txt": "{\n  \"file\": \"18_3.txt\",\n  \"assertion\": \"assertFalse ( panel. view v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. view v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_4.txt": "{\n  \"file\": \"18_4.txt\",\n  \"assertion\": \"assertFalse ( panel. page v accessible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. page v accessible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_5.txt": "{\n  \"file\": \"18_5.txt\",\n  \"assertion\": \"assertFalse ( panel. page vable ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. page vable ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_6.txt": "{\n  \"file\": \"18_6.txt\",\n  \"assertion\": \"assertFalse ( panel. button v accessible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. button v accessible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_7.txt": "{\n  \"file\": \"18_7.txt\",\n  \"assertion\": \"assertFalse ( panel. page v invisible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. page v invisible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_8.txt": "{\n  \"file\": \"18_8.txt\",\n  \"assertion\": \"assertFalse ( panel. icon v visible ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. icon v visible ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "18_9.txt": "{\n  \"file\": \"18_9.txt\",\n  \"assertion\": \"assertFalse ( panel. button vable ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEditPlainTiff ( ) { final LayerInfo layer \\u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \\u003d tester . getLastRenderedPage ( ) . get ( \\\"form:panel\\\" ) ; assertFalse ( panel. button vable ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void isVisible() { return ( ( configurationModel ) \\u003d\\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\\u003d null ) ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( panel. isVisible ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_0.txt": "{\n  \"file\": \"19_0.txt\",\n  \"assertion\": \"assertEquals ( 1, entry. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entry. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_1.txt": "{\n  \"file\": \"19_1.txt\",\n  \"assertion\": \"assertEquals ( 3, entry. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, entry. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_10.txt": "{\n  \"file\": \"19_10.txt\",\n  \"assertion\": \"assertEquals ( 1, entry. total total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entry. total total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_11.txt": "{\n  \"file\": \"19_11.txt\",\n  \"assertion\": \"assertEquals ( 5, entries. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 5, entries. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_12.txt": "{\n  \"file\": \"19_12.txt\",\n  \"assertion\": \"assertEquals ( 1, entry. size total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entry. size total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_13.txt": "{\n  \"file\": \"19_13.txt\",\n  \"assertion\": \"assertEquals ( 1, count. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, count. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_14.txt": "{\n  \"file\": \"19_14.txt\",\n  \"assertion\": \"assertEquals ( 4, entry. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 4, entry. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_15.txt": "{\n  \"file\": \"19_15.txt\",\n  \"assertion\": \"assertEquals ( 3, entry. set total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, entry. set total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_16.txt": "{\n  \"file\": \"19_16.txt\",\n  \"assertion\": \"assertEquals ( 2, entry. set total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, entry. set total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_17.txt": "{\n  \"file\": \"19_17.txt\",\n  \"assertion\": \"assertEquals ( 1, entry. number total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entry. number total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_18.txt": "{\n  \"file\": \"19_18.txt\",\n  \"assertion\": \"assertEquals ( 3, result. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, result. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_19.txt": "{\n  \"file\": \"19_19.txt\",\n  \"assertion\": \"assertEquals ( 3, entry. total total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, entry. total total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_2.txt": "{\n  \"file\": \"19_2.txt\",\n  \"assertion\": \"assertEquals ( 2, entry. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, entry. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_20.txt": "{\n  \"file\": \"19_20.txt\",\n  \"assertion\": \"assertEquals ( 2, result. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, result. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_21.txt": "{\n  \"file\": \"19_21.txt\",\n  \"assertion\": \"assertEquals ( 5, entry. set total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 5, entry. set total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_22.txt": "{\n  \"file\": \"19_22.txt\",\n  \"assertion\": \"assertEquals ( 1, entry. return total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entry. return total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_23.txt": "{\n  \"file\": \"19_23.txt\",\n  \"assertion\": \"assertEquals ( 2, entry. total total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, entry. total total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_24.txt": "{\n  \"file\": \"19_24.txt\",\n  \"assertion\": \"assertEquals ( 3, entry. size total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, entry. size total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_25.txt": "{\n  \"file\": \"19_25.txt\",\n  \"assertion\": \"assertEquals ( 3, count. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, count. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_26.txt": "{\n  \"file\": \"19_26.txt\",\n  \"assertion\": \"assertEquals ( 2, entry. size total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, entry. size total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_27.txt": "{\n  \"file\": \"19_27.txt\",\n  \"assertion\": \"assertEquals ( 2, count. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, count. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_28.txt": "{\n  \"file\": \"19_28.txt\",\n  \"assertion\": \"assertEquals ( 5, result. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 5, result. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_29.txt": "{\n  \"file\": \"19_29.txt\",\n  \"assertion\": \"assertEquals ( 1, entries. set total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entries. set total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_3.txt": "{\n  \"file\": \"19_3.txt\",\n  \"assertion\": \"assertEquals ( 5, entry. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 5, entry. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_4.txt": "{\n  \"file\": \"19_4.txt\",\n  \"assertion\": \"assertEquals ( 1, entries. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entries. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_5.txt": "{\n  \"file\": \"19_5.txt\",\n  \"assertion\": \"assertEquals ( 1, entry. set total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, entry. set total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_6.txt": "{\n  \"file\": \"19_6.txt\",\n  \"assertion\": \"assertEquals ( 3, entries. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 3, entries. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_7.txt": "{\n  \"file\": \"19_7.txt\",\n  \"assertion\": \"assertEquals ( 0, entry. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 0, entry. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_8.txt": "{\n  \"file\": \"19_8.txt\",\n  \"assertion\": \"assertEquals ( 2, entries. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 2, entries. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "19_9.txt": "{\n  \"file\": \"19_9.txt\",\n  \"assertion\": \"assertEquals ( 1, result. count total results ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \\u003d new PersonEntry ( new Person ( ) , 1 , 1 , \\\"name\\\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \\\"name\\\" ) ; assertEquals ( 1, result. count total results ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getTotalResults() { return totalResults ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, entry. getTotalResults ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_0.txt": "{\n  \"file\": \"1_0.txt\",\n  \"assertion\": \"assertEquals ( users, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_1.txt": "{\n  \"file\": \"1_1.txt\",\n  \"assertion\": \"assertEquals ( 0, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_10.txt": "{\n  \"file\": \"1_10.txt\",\n  \"assertion\": \"assertEquals ( user, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( user, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_11.txt": "{\n  \"file\": \"1_11.txt\",\n  \"assertion\": \"assertEquals ( 1, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_12.txt": "{\n  \"file\": \"1_12.txt\",\n  \"assertion\": \"assertEquals ( 0, Users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, Users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_13.txt": "{\n  \"file\": \"1_13.txt\",\n  \"assertion\": \"assertEquals ( Users, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( Users, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_14.txt": "{\n  \"file\": \"1_14.txt\",\n  \"assertion\": \"assertEquals (Users, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (Users, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_15.txt": "{\n  \"file\": \"1_15.txt\",\n  \"assertion\": \"assertEquals ( users,Users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users,Users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_16.txt": "{\n  \"file\": \"1_16.txt\",\n  \"assertion\": \"assertEquals ( null, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( null, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_17.txt": "{\n  \"file\": \"1_17.txt\",\n  \"assertion\": \"assertEquals ( users, null. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, null. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_18.txt": "{\n  \"file\": \"1_18.txt\",\n  \"assertion\": \"assertEquals ( 0, users. null ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. null ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_19.txt": "{\n  \"file\": \"1_19.txt\",\n  \"assertion\": \"assertEquals ( users, 0. null ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, 0. null ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_2.txt": "{\n  \"file\": \"1_2.txt\",\n  \"assertion\": \"assertEquals ( users, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_20.txt": "{\n  \"file\": \"1_20.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_21.txt": "{\n  \"file\": \"1_21.txt\",\n  \"assertion\": \"assertEquals ( users, users. empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, users. empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"users\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"users\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"List\\\\u003cUser\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"empty\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "1_22.txt": "{\n  \"file\": \"1_22.txt\",\n  \"assertion\": \"assertEquals ( 0,Users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0,Users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_23.txt": "{\n  \"file\": \"1_23.txt\",\n  \"assertion\": \"assertEquals (Users, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (Users, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_24.txt": "{\n  \"file\": \"1_24.txt\",\n  \"assertion\": \"assertEquals ( null, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( null, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_25.txt": "{\n  \"file\": \"1_25.txt\",\n  \"assertion\": \"assertEquals ( 0, null. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, null. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_26.txt": "{\n  \"file\": \"1_26.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. null ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, 0. null ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_27.txt": "{\n  \"file\": \"1_27.txt\",\n  \"assertion\": \"assertEquals ( 0, users. empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"empty\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "1_28.txt": "{\n  \"file\": \"1_28.txt\",\n  \"assertion\": \"assertEquals ( users, 0. empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, 0. empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_29.txt": "{\n  \"file\": \"1_29.txt\",\n  \"assertion\": \"assertEquals ( empty, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( empty, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_3.txt": "{\n  \"file\": \"1_3.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_4.txt": "{\n  \"file\": \"1_4.txt\",\n  \"assertion\": \"assertEquals ( user, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( user, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_5.txt": "{\n  \"file\": \"1_5.txt\",\n  \"assertion\": \"assertEquals ( users, user. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, user. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_6.txt": "{\n  \"file\": \"1_6.txt\",\n  \"assertion\": \"assertEquals ( Users, users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( Users, users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_7.txt": "{\n  \"file\": \"1_7.txt\",\n  \"assertion\": \"assertEquals ( users, Users. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, Users. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_8.txt": "{\n  \"file\": \"1_8.txt\",\n  \"assertion\": \"assertEquals ( users, users. null ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, users. null ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "1_9.txt": "{\n  \"file\": \"1_9.txt\",\n  \"assertion\": \"assertEquals ( 0, user. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \\u003d this . newDao ( ) ; Topic topic \\u003d new Topic ( ) ; topic . setId ( 13 ) ; List \\u003c User \\u003e users \\u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, user. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \\u003c User \\u003e users \\u003d session . createQuery ( ( \\\"select\\u003csp\\u003eu\\u003csp\\u003efrom\\u003csp\\u003eTopicWatch\\u003csp\\u003etw\\u003csp\\u003e\\\" + ( \\\"\\u003csp\\u003einner\\u003csp\\u003ejoin\\u003csp\\u003etw.user\\u003csp\\u003eu\\u003csp\\u003ewhere\\u003csp\\u003etw.topic\\u003csp\\u003e\\u003d\\u003csp\\u003e:topic\\u003csp\\u003e\\\" + \\\"\\u003csp\\u003eand\\u003csp\\u003e(tw.read\\u003csp\\u003e\\u003d\\u003csp\\u003etrue\\u003csp\\u003eor\\u003csp\\u003eu.notifyAlways\\u003csp\\u003e\\u003d\\u003csp\\u003etrue)\\\" ) ) ) . setEntity ( \\\"topic\\\" , topic ) . setComment ( \\\"topicWatchDAO.getUsersWaitingNotification\\\" ) . list ( ) ; if ( ( users . size ( ) ) \\u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, users. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "20_0.txt": "Unknown assertion type",
  "20_1.txt": "Unknown assertion type",
  "20_10.txt": "Unknown assertion type",
  "20_11.txt": "Unknown assertion type",
  "20_12.txt": "Unknown assertion type",
  "20_13.txt": "Unknown assertion type",
  "20_14.txt": "Unknown assertion type",
  "20_15.txt": "Unknown assertion type",
  "20_16.txt": "Unknown assertion type",
  "20_17.txt": "Unknown assertion type",
  "20_18.txt": "Unknown assertion type",
  "20_19.txt": "Unknown assertion type",
  "20_2.txt": "Unknown assertion type",
  "20_20.txt": "Unknown assertion type",
  "20_21.txt": "Unknown assertion type",
  "20_22.txt": "Unknown assertion type",
  "20_23.txt": "Unknown assertion type",
  "20_24.txt": "Unknown assertion type",
  "20_25.txt": "Unknown assertion type",
  "20_26.txt": "Unknown assertion type",
  "20_27.txt": "Unknown assertion type",
  "20_28.txt": "Unknown assertion type",
  "20_29.txt": "Unknown assertion type",
  "20_3.txt": "Unknown assertion type",
  "20_4.txt": "Unknown assertion type",
  "20_5.txt": "Unknown assertion type",
  "20_6.txt": "Unknown assertion type",
  "20_7.txt": "Unknown assertion type",
  "20_8.txt": "Unknown assertion type",
  "20_9.txt": "Unknown assertion type",
  "21_0.txt": "{\n  \"file\": \"21_0.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Double. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_1.txt": "{\n  \"file\": \"21_1.txt\",\n  \"assertion\": \"assertTrue ( value. value ( \\\". 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \\\". 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_10.txt": "{\n  \"file\": \"21_10.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Math. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Math. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_11.txt": "{\n  \"file\": \"21_11.txt\",\n  \"assertion\": \"assertTrue ( value. value ( math. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( math. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_12.txt": "{\n  \"file\": \"21_12.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 0. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 0. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_13.txt": "{\n  \"file\": \"21_13.txt\",\n  \"assertion\": \"assertTrue ( value. value ( (. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( (. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_14.txt": "{\n  \"file\": \"21_14.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 10. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 10. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_15.txt": "{\n  \"file\": \"21_15.txt\",\n  \"assertion\": \"assertTrue ( value. value ( is. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( is. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_16.txt": "{\n  \"file\": \"21_16.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 100. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 100. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_17.txt": "{\n  \"file\": \"21_17.txt\",\n  \"assertion\": \"assertTrue ( value. value ( (. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( (. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_18.txt": "{\n  \"file\": \"21_18.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 1. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 1. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_19.txt": "{\n  \"file\": \"21_19.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 1000. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 1000. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_2.txt": "{\n  \"file\": \"21_2.txt\",\n  \"assertion\": \"assertTrue ( value. value ( \\\"\\\". 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \\\"\\\". 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_20.txt": "{\n  \"file\": \"21_20.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 10. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 10. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_21.txt": "{\n  \"file\": \"21_21.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 7. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 7. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_22.txt": "{\n  \"file\": \"21_22.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 5. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 5. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_23.txt": "{\n  \"file\": \"21_23.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 100. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 100. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_24.txt": "{\n  \"file\": \"21_24.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Double. 0 F ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0 F ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_25.txt": "{\n  \"file\": \"21_25.txt\",\n  \"assertion\": \"assertTrue ( value. value ( \\\". 0 F ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \\\". 0 F ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_26.txt": "{\n  \"file\": \"21_26.txt\",\n  \"assertion\": \"assertTrue ( value. value ( \\\"\\\". 0 F ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \\\"\\\". 0 F ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_27.txt": "{\n  \"file\": \"21_27.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Math. 0 F ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Math. 0 F ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_28.txt": "{\n  \"file\": \"21_28.txt\",\n  \"assertion\": \"assertTrue ( value. value ( math. 0 F ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( math. 0 F ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_29.txt": "{\n  \"file\": \"21_29.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Double. 0\\u0027 ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0\\u0027 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_3.txt": "{\n  \"file\": \"21_3.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Math. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Math. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_4.txt": "{\n  \"file\": \"21_4.txt\",\n  \"assertion\": \"assertTrue ( value. value ( math. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( math. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_5.txt": "{\n  \"file\": \"21_5.txt\",\n  \"assertion\": \"assertTrue ( value. value ( 0. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 0. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_6.txt": "{\n  \"file\": \"21_6.txt\",\n  \"assertion\": \"assertTrue ( value. value ( is. 0 ) ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( is. 0 ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_7.txt": "{\n  \"file\": \"21_7.txt\",\n  \"assertion\": \"assertTrue ( value. value ( Double. 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "21_8.txt": "{\n  \"file\": \"21_8.txt\",\n  \"assertion\": \"assertTrue ( value. value ( \\\". 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \\\". 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "21_9.txt": "{\n  \"file\": \"21_9.txt\",\n  \"assertion\": \"assertTrue ( value. value ( \\\"\\\". 0\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \\u003d new MethodExpression ( new Abs ( null ) , \\\"evaluate\\\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \\u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \\\"\\\". 0\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( ( this ) \\u003d\\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \\u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \\u003d\\u003d null ? ( other . first ) \\u003d\\u003d null : first . first . equals ( ) ) \\u0026\\u0026 ( ( second ) \\u003d\\u003d null ? ( other . second ) \\u003d\\u003d null : second . second . equals ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. equals ( 1.0F ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "22_0.txt": "{\n  \"file\": \"22_0.txt\",\n  \"assertion\": \"assertNotNull ( result )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SchemaContext\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "22_1.txt": "{\n  \"file\": \"22_1.txt\",\n  \"assertion\": \"assertNotNull ( context )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( context ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"context\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_10.txt": "{\n  \"file\": \"22_10.txt\",\n  \"assertion\": \"assertNotNull ( exception )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( exception ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"exception\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_11.txt": "{\n  \"file\": \"22_11.txt\",\n  \"assertion\": \"assertNotNull ( return )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( return ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "22_12.txt": "{\n  \"file\": \"22_12.txt\",\n  \"assertion\": \"assertNotNull ( effect )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( effect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"effect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_13.txt": "{\n  \"file\": \"22_13.txt\",\n  \"assertion\": \"assertNotNull ( intersection )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( intersection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"intersection\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_14.txt": "{\n  \"file\": \"22_14.txt\",\n  \"assertion\": \"assertNotNull ( eclipse )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( eclipse ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eclipse\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_15.txt": "{\n  \"file\": \"22_15.txt\",\n  \"assertion\": \"assertNotNull ( target )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( target ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"target\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_16.txt": "{\n  \"file\": \"22_16.txt\",\n  \"assertion\": \"assertNotNull ( results )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_17.txt": "{\n  \"file\": \"22_17.txt\",\n  \"assertion\": \"assertNotNull ( expected )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_18.txt": "{\n  \"file\": \"22_18.txt\",\n  \"assertion\": \"assertNotNull ( correlation )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( correlation ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"correlation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_19.txt": "{\n  \"file\": \"22_19.txt\",\n  \"assertion\": \"assertNotNull ( null )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_2.txt": "{\n  \"file\": \"22_2.txt\",\n  \"assertion\": \"assertNotNull (result )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull (result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SchemaContext\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "22_20.txt": "{\n  \"file\": \"22_20.txt\",\n  \"assertion\": \"assertNotNull ( filter )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( filter ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"filter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_21.txt": "{\n  \"file\": \"22_21.txt\",\n  \"assertion\": \"assertNotNull ( expression )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( expression ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expression\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_22.txt": "{\n  \"file\": \"22_22.txt\",\n  \"assertion\": \"assertNotNull ( output )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( output ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"output\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_23.txt": "{\n  \"file\": \"22_23.txt\",\n  \"assertion\": \"assertNotNull ( project )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( project ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"project\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_24.txt": "{\n  \"file\": \"22_24.txt\",\n  \"assertion\": \"assertNotNull ( match )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( match ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_25.txt": "{\n  \"file\": \"22_25.txt\",\n  \"assertion\": \"assertNotNull ( support )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( support ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"support\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_26.txt": "{\n  \"file\": \"22_26.txt\",\n  \"assertion\": \"assertNotNull ( root )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( root ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"root\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_27.txt": "{\n  \"file\": \"22_27.txt\",\n  \"assertion\": \"assertNotNull ( value )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( value ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_28.txt": "{\n  \"file\": \"22_28.txt\",\n  \"assertion\": \"assertNotNull ( consequence )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( consequence ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"consequence\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_29.txt": "{\n  \"file\": \"22_29.txt\",\n  \"assertion\": \"assertNotNull ( product )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( product ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"product\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_3.txt": "{\n  \"file\": \"22_3.txt\",\n  \"assertion\": \"assertNotNull (Result )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull (Result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_4.txt": "{\n  \"file\": \"22_4.txt\",\n  \"assertion\": \"assertNotNull ( future )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( future ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"future\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_5.txt": "{\n  \"file\": \"22_5.txt\",\n  \"assertion\": \"assertNotNull ( cause )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( cause ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"cause\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_6.txt": "{\n  \"file\": \"22_6.txt\",\n  \"assertion\": \"assertNotNull ( instance )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( instance ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"instance\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_7.txt": "{\n  \"file\": \"22_7.txt\",\n  \"assertion\": \"assertNotNull ( Result )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( Result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_8.txt": "{\n  \"file\": \"22_8.txt\",\n  \"assertion\": \"assertNotNull ( answer )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( answer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"answer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "22_9.txt": "{\n  \"file\": \"22_9.txt\",\n  \"assertion\": \"assertNotNull ( brace )\\r\\n\",\n  \"test\": \"class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \\u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( brace ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"brace\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "23_0.txt": "{\n  \"file\": \"23_0.txt\",\n  \"assertion\": \"assertEquals ( time, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_1.txt": "{\n  \"file\": \"23_1.txt\",\n  \"assertion\": \"assertEquals ( time, 0. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, 0. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_10.txt": "{\n  \"file\": \"23_10.txt\",\n  \"assertion\": \"assertEquals ( modified, 0. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, 0. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_11.txt": "{\n  \"file\": \"23_11.txt\",\n  \"assertion\": \"assertEquals ( time, null. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, null. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_12.txt": "{\n  \"file\": \"23_12.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, 0. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_13.txt": "{\n  \"file\": \"23_13.txt\",\n  \"assertion\": \"assertEquals ( 1, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 1, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_14.txt": "{\n  \"file\": \"23_14.txt\",\n  \"assertion\": \"assertEquals ( date, date. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, date. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_15.txt": "{\n  \"file\": \"23_15.txt\",\n  \"assertion\": \"assertEquals ( modified, date. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, date. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_16.txt": "{\n  \"file\": \"23_16.txt\",\n  \"assertion\": \"assertEquals ( date, date. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, date. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_17.txt": "{\n  \"file\": \"23_17.txt\",\n  \"assertion\": \"assertEquals ( modified, date. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, date. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_18.txt": "{\n  \"file\": \"23_18.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 1, 0. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_19.txt": "{\n  \"file\": \"23_19.txt\",\n  \"assertion\": \"assertEquals ( 0, date. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, date. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_2.txt": "{\n  \"file\": \"23_2.txt\",\n  \"assertion\": \"assertEquals ( time, date. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, date. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_20.txt": "{\n  \"file\": \"23_20.txt\",\n  \"assertion\": \"assertEquals ( date, 0. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, 0. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_21.txt": "{\n  \"file\": \"23_21.txt\",\n  \"assertion\": \"assertEquals ( modified, 0. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, 0. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_22.txt": "{\n  \"file\": \"23_22.txt\",\n  \"assertion\": \"assertEquals ( 0, date. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, date. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_23.txt": "{\n  \"file\": \"23_23.txt\",\n  \"assertion\": \"assertEquals ( date, 0. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, 0. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_24.txt": "{\n  \"file\": \"23_24.txt\",\n  \"assertion\": \"assertEquals ( true, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( true, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_25.txt": "{\n  \"file\": \"23_25.txt\",\n  \"assertion\": \"assertEquals ( modified, 0. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, 0. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_26.txt": "{\n  \"file\": \"23_26.txt\",\n  \"assertion\": \"assertEquals ( time, annotation. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, annotation. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_27.txt": "{\n  \"file\": \"23_27.txt\",\n  \"assertion\": \"assertEquals ( null, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( null, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_28.txt": "{\n  \"file\": \"23_28.txt\",\n  \"assertion\": \"assertEquals ( date, null. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, null. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_29.txt": "{\n  \"file\": \"23_29.txt\",\n  \"assertion\": \"assertEquals ( time, null. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, null. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_3.txt": "{\n  \"file\": \"23_3.txt\",\n  \"assertion\": \"assertEquals ( date, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_4.txt": "{\n  \"file\": \"23_4.txt\",\n  \"assertion\": \"assertEquals ( time, date. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, date. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_5.txt": "{\n  \"file\": \"23_5.txt\",\n  \"assertion\": \"assertEquals ( modified, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_6.txt": "{\n  \"file\": \"23_6.txt\",\n  \"assertion\": \"assertEquals ( time, 0. date modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, 0. date modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_7.txt": "{\n  \"file\": \"23_7.txt\",\n  \"assertion\": \"assertEquals ( 0, date. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, date. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_8.txt": "{\n  \"file\": \"23_8.txt\",\n  \"assertion\": \"assertEquals ( date, 0. time modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, 0. time modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "23_9.txt": "{\n  \"file\": \"23_9.txt\",\n  \"assertion\": \"assertEquals ( time, 0. modified modified modified ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetModified3 ( ) { String time \\u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \\\".\\\" ) ) { time \\u003d ( time . substring ( 0 , time . indexOf ( \\u0027.\\u0027 ) ) ) + \\\"Z\\\" ; } else { time +\\u003d \\\"Z\\\" ; } out . println ( time ) ; Annotation annotation \\u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \\u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, 0. modified modified modified ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getModified() { return this . modified ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( time, result. getModified ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_0.txt": "{\n  \"file\": \"24_0.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. createOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_1.txt": "{\n  \"file\": \"24_1.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. concOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_10.txt": "{\n  \"file\": \"24_10.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. compOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. compOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_11.txt": "{\n  \"file\": \"24_11.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. toOperation ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. toOperation ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_12.txt": "{\n  \"file\": \"24_12.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. createOperation ( transports ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( transports ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_13.txt": "{\n  \"file\": \"24_13.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. compareOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. compareOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_14.txt": "{\n  \"file\": \"24_14.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. toOperation ( connections ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. toOperation ( connections ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_15.txt": "{\n  \"file\": \"24_15.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. create request ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. create request ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_16.txt": "{\n  \"file\": \"24_16.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. createOperation ( races ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( races ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_17.txt": "{\n  \"file\": \"24_17.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. newOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. newOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_18.txt": "{\n  \"file\": \"24_18.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. to request ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. to request ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_19.txt": "{\n  \"file\": \"24_19.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. CompOperation ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. CompOperation ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_2.txt": "{\n  \"file\": \"24_2.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. createOperation ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_20.txt": "{\n  \"file\": \"24_20.txt\",\n  \"assertion\": \"assertNull ( operations data.ors. createOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data.ors. createOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_21.txt": "{\n  \"file\": \"24_21.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. create request ( connections ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. create request ( connections ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_22.txt": "{\n  \"file\": \"24_22.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. concOperation ( transports ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( transports ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_23.txt": "{\n  \"file\": \"24_23.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. CompOperation ( connections ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. CompOperation ( connections ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_24.txt": "{\n  \"file\": \"24_24.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. conc request ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. conc request ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_25.txt": "{\n  \"file\": \"24_25.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. Comp request ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. Comp request ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_26.txt": "{\n  \"file\": \"24_26.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. concOperation ( races ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( races ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_27.txt": "{\n  \"file\": \"24_27.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. compOperation ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. compOperation ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_28.txt": "{\n  \"file\": \"24_28.txt\",\n  \"assertion\": \"assertNull ( operations data.ors. concOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data.ors. concOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_29.txt": "{\n  \"file\": \"24_29.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. conc request ( connections ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. conc request ( connections ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_3.txt": "{\n  \"file\": \"24_3.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. toOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. toOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_4.txt": "{\n  \"file\": \"24_4.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. createOperation ( connections ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( connections ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_5.txt": "{\n  \"file\": \"24_5.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. create request ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. create request ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_6.txt": "{\n  \"file\": \"24_6.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. concOperation ( types ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( types ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_7.txt": "{\n  \"file\": \"24_7.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. CompOperation ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. CompOperation ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_8.txt": "{\n  \"file\": \"24_8.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. concOperation ( connections ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( connections ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "24_9.txt": "{\n  \"file\": \"24_9.txt\",\n  \"assertion\": \"assertNull ( operations data (ors. conc request ( messages ) )\\r\\n\",\n  \"test\": \"class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \\u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \\u003d new DefaultOperationDataProcessor ( state ) ; Map \\u003c TransportType , ChannelDirection \\u003e types \\u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. conc request ( messages ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\\u003d null ) { SyncRequest request \\u003d transport . createResolveRequest ( ) ; LOG . trace ( \\\"Created\\u003csp\\u003eResolve\\u003csp\\u003erequest\\u003csp\\u003e{}\\\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertNull ( operationsDataProcessor. compileRequest ( types ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_0.txt": "{\n  \"file\": \"25_0.txt\",\n  \"assertion\": \"assertEquals ( 0, 0s. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0s. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_1.txt": "{\n  \"file\": \"25_1.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ools. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ools. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_10.txt": "{\n  \"file\": \"25_10.txt\",\n  \"assertion\": \"assertEquals ( 0, 0\\u0027s. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0\\u0027s. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_11.txt": "{\n  \"file\": \"25_11.txt\",\n  \"assertion\": \"assertEquals ( 0, 0Map. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0Map. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_12.txt": "{\n  \"file\": \"25_12.txt\",\n  \"assertion\": \"assertEquals ( 0, 0irs. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0irs. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_13.txt": "{\n  \"file\": \"25_13.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ows. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ows. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_14.txt": "{\n  \"file\": \"25_14.txt\",\n  \"assertion\": \"assertEquals ( 0, 0S. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0S. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_15.txt": "{\n  \"file\": \"25_15.txt\",\n  \"assertion\": \"assertEquals ( 0, 0s. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0s. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_16.txt": "{\n  \"file\": \"25_16.txt\",\n  \"assertion\": \"assertEquals ( 1, 0s. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 1, 0s. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_17.txt": "{\n  \"file\": \"25_17.txt\",\n  \"assertion\": \"assertEquals ( 0, 1s. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 1s. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_18.txt": "{\n  \"file\": \"25_18.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ms. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ms. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_19.txt": "{\n  \"file\": \"25_19.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ocks. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ocks. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_2.txt": "{\n  \"file\": \"25_2.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ors. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ors. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_20.txt": "{\n  \"file\": \"25_20.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ols. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ols. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_21.txt": "{\n  \"file\": \"25_21.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ools. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ools. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_22.txt": "{\n  \"file\": \"25_22.txt\",\n  \"assertion\": \"assertEquals ( 1, 0ools. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 1, 0ools. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_23.txt": "{\n  \"file\": \"25_23.txt\",\n  \"assertion\": \"assertEquals ( 0, 1ools. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 1ools. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_24.txt": "{\n  \"file\": \"25_24.txt\",\n  \"assertion\": \"assertEquals ( 0, 0In. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0In. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_25.txt": "{\n  \"file\": \"25_25.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ds. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ds. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_26.txt": "{\n  \"file\": \"25_26.txt\",\n  \"assertion\": \"assertEquals ( 2, 0s. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 2, 0s. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_27.txt": "{\n  \"file\": \"25_27.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ors. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ors. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_28.txt": "{\n  \"file\": \"25_28.txt\",\n  \"assertion\": \"assertEquals ( 1, 0ors. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 1, 0ors. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_29.txt": "{\n  \"file\": \"25_29.txt\",\n  \"assertion\": \"assertEquals ( 0, 1ors. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 1ors. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_3.txt": "{\n  \"file\": \"25_3.txt\",\n  \"assertion\": \"assertEquals ( 0, 0o. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0o. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_4.txt": "{\n  \"file\": \"25_4.txt\",\n  \"assertion\": \"assertEquals ( 0, 0l. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0l. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_5.txt": "{\n  \"file\": \"25_5.txt\",\n  \"assertion\": \"assertEquals ( 0, 0os. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0os. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_6.txt": "{\n  \"file\": \"25_6.txt\",\n  \"assertion\": \"assertEquals ( 0, 0m. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0m. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_7.txt": "{\n  \"file\": \"25_7.txt\",\n  \"assertion\": \"assertEquals ( 0, 0d. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0d. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_8.txt": "{\n  \"file\": \"25_8.txt\",\n  \"assertion\": \"assertEquals ( 0, 0i. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0i. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "25_9.txt": "{\n  \"file\": \"25_9.txt\",\n  \"assertion\": \"assertEquals ( 0, 0g. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \\u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \\\"--output-type\\\" , \\\"nooutput\\\" } ) ; Factory factory \\u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \\\"./src/test/java/spoon/test/reference/Foo.java\\\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \\u003c Foo \\u003e foo \\u003d factory . Package ( ) . get ( \\\"spoon.test.reference\\\" ) . getType ( \\\"Foo\\\" ) ; Collection \\u003c CtExecutableReference \\u003c ? \\u003e \\u003e execs \\u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0g. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, execs. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_0.txt": "{\n  \"file\": \"26_0.txt\",\n  \"assertion\": \"assertTrue ( process process finished ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process process finished ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_1.txt": "{\n  \"file\": \"26_1.txt\",\n  \"assertion\": \"assertTrue ( process process died ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process process died ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_10.txt": "{\n  \"file\": \"26_10.txt\",\n  \"assertion\": \"assertTrue ( processprocess finished ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( processprocess finished ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_11.txt": "{\n  \"file\": \"26_11.txt\",\n  \"assertion\": \"assertTrue (process process finished ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue (process process finished ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_12.txt": "{\n  \"file\": \"26_12.txt\",\n  \"assertion\": \"assertTrue ( Process process finished ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( Process process finished ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_13.txt": "{\n  \"file\": \"26_13.txt\",\n  \"assertion\": \"assertTrue ( process processailed ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processailed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_14.txt": "{\n  \"file\": \"26_14.txt\",\n  \"assertion\": \"assertTrue ( process processED ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processED ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_15.txt": "{\n  \"file\": \"26_15.txt\",\n  \"assertion\": \"assertTrue ( process processEnd ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processEnd ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_16.txt": "{\n  \"file\": \"26_16.txt\",\n  \"assertion\": \"assertTrue ( process processopped ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processopped ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_17.txt": "{\n  \"file\": \"26_17.txt\",\n  \"assertion\": \"assertTrue ( process processired ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processired ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_18.txt": "{\n  \"file\": \"26_18.txt\",\n  \"assertion\": \"assertTrue ( process processied ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processied ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_19.txt": "{\n  \"file\": \"26_19.txt\",\n  \"assertion\": \"assertTrue ( process processDone ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processDone ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_2.txt": "{\n  \"file\": \"26_2.txt\",\n  \"assertion\": \"assertTrue ( process process ended ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process process ended ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_20.txt": "{\n  \"file\": \"26_20.txt\",\n  \"assertion\": \"assertTrue ( process processged ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processged ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_21.txt": "{\n  \"file\": \"26_21.txt\",\n  \"assertion\": \"assertTrue ( processes process finished ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( processes process finished ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_22.txt": "{\n  \"file\": \"26_22.txt\",\n  \"assertion\": \"assertTrue ( process processshed ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processshed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_23.txt": "{\n  \"file\": \"26_23.txt\",\n  \"assertion\": \"assertTrue ( process processined ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processined ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_24.txt": "{\n  \"file\": \"26_24.txt\",\n  \"assertion\": \"assertTrue ( process processowed ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processowed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_25.txt": "{\n  \"file\": \"26_25.txt\",\n  \"assertion\": \"assertTrue ( process processted ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processted ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_26.txt": "{\n  \"file\": \"26_26.txt\",\n  \"assertion\": \"assertTrue ( process processaned ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processaned ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_27.txt": "{\n  \"file\": \"26_27.txt\",\n  \"assertion\": \"assertTrue ( processprocess died ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( processprocess died ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_28.txt": "{\n  \"file\": \"26_28.txt\",\n  \"assertion\": \"assertTrue (process process died ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue (process process died ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_29.txt": "{\n  \"file\": \"26_29.txt\",\n  \"assertion\": \"assertTrue ( processing process finished ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( processing process finished ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_3.txt": "{\n  \"file\": \"26_3.txt\",\n  \"assertion\": \"assertTrue ( process processized ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processized ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_4.txt": "{\n  \"file\": \"26_4.txt\",\n  \"assertion\": \"assertTrue ( process processd ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processd ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_5.txt": "{\n  \"file\": \"26_5.txt\",\n  \"assertion\": \"assertTrue ( process process ed ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process process ed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_6.txt": "{\n  \"file\": \"26_6.txt\",\n  \"assertion\": \"assertTrue ( process processs ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processs ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_7.txt": "{\n  \"file\": \"26_7.txt\",\n  \"assertion\": \"assertTrue ( process processed ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_8.txt": "{\n  \"file\": \"26_8.txt\",\n  \"assertion\": \"assertTrue ( process processosed ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processosed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "26_9.txt": "{\n  \"file\": \"26_9.txt\",\n  \"assertion\": \"assertTrue ( process processended ( ) )\\r\\n\",\n  \"test\": \"class X {public void badFlow ( ) { final String aNummer \\u003d \\\"1607306140\\\" ; final String doelPartijCode \\u003d \\\"0599\\\" ; final String bulkSynchronisatievraag \\u003d ( ( doelPartijCode + \\\",\\\" ) + aNummer ) + \\\",testtekst\\\\n\\\" ; final Uc812Bericht uc812Bericht \\u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \\\"end\\\" ) ; assertTrue ( process processended ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void processEnded() { final JbpmContext jbpmContext \\u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \\u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( processEnded ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_0.txt": "{\n  \"file\": \"27_0.txt\",\n  \"assertion\": \"assertNull ( queue. removeue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_1.txt": "{\n  \"file\": \"27_1.txt\",\n  \"assertion\": \"assertNull ( queue. removeQueue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_10.txt": "{\n  \"file\": \"27_10.txt\",\n  \"assertion\": \"assertNull ( queue. removeue ( de Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( de Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_11.txt": "{\n  \"file\": \"27_11.txt\",\n  \"assertion\": \"assertNull ( queue. deue ( remove Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( remove Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_12.txt": "{\n  \"file\": \"27_12.txt\",\n  \"assertion\": \"assertNull ( queue. removeQueue ( connection Context ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( connection Context ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_13.txt": "{\n  \"file\": \"27_13.txt\",\n  \"assertion\": \"assertNull ( queue. relue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. relue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_14.txt": "{\n  \"file\": \"27_14.txt\",\n  \"assertion\": \"assertNull ( queue. deleteue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deleteue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_15.txt": "{\n  \"file\": \"27_15.txt\",\n  \"assertion\": \"assertNull ( queue. deQueue ( remove Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( remove Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_16.txt": "{\n  \"file\": \"27_16.txt\",\n  \"assertion\": \"assertNull ( queue. removeQueue ( de Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( de Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_17.txt": "{\n  \"file\": \"27_17.txt\",\n  \"assertion\": \"assertNull ( queue. deue ( null Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( null Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_18.txt": "{\n  \"file\": \"27_18.txt\",\n  \"assertion\": \"assertNull ( queue. relQueue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. relQueue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_19.txt": "{\n  \"file\": \"27_19.txt\",\n  \"assertion\": \"assertNull ( queue. deleteQueue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deleteQueue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_2.txt": "{\n  \"file\": \"27_2.txt\",\n  \"assertion\": \"assertNull ( queue. deue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_20.txt": "{\n  \"file\": \"27_20.txt\",\n  \"assertion\": \"assertNull ( queue. removeque ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeque ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_21.txt": "{\n  \"file\": \"27_21.txt\",\n  \"assertion\": \"assertNull ( queue. processue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. processue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_22.txt": "{\n  \"file\": \"27_22.txt\",\n  \"assertion\": \"assertNull ( queue. deQueue ( null Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( null Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_23.txt": "{\n  \"file\": \"27_23.txt\",\n  \"assertion\": \"assertNull ( queue. deue ( connection Context ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( connection Context ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_24.txt": "{\n  \"file\": \"27_24.txt\",\n  \"assertion\": \"assertNull ( queue. downue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. downue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_25.txt": "{\n  \"file\": \"27_25.txt\",\n  \"assertion\": \"assertNull ( queue. processQueue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. processQueue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_26.txt": "{\n  \"file\": \"27_26.txt\",\n  \"assertion\": \"assertNull ( queue. de ( ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. de ( ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_27.txt": "{\n  \"file\": \"27_27.txt\",\n  \"assertion\": \"assertNull ( queue. deue ( de Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( de Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_28.txt": "{\n  \"file\": \"27_28.txt\",\n  \"assertion\": \"assertNull ( pool. removeue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( pool. removeue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_29.txt": "{\n  \"file\": \"27_29.txt\",\n  \"assertion\": \"assertNull ( queue. deQueue ( connection Context ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( connection Context ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_3.txt": "{\n  \"file\": \"27_3.txt\",\n  \"assertion\": \"assertNull ( queue. deQueue ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_4.txt": "{\n  \"file\": \"27_4.txt\",\n  \"assertion\": \"assertNull ( queue. removeue ( remove Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( remove Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_5.txt": "{\n  \"file\": \"27_5.txt\",\n  \"assertion\": \"assertNull ( queue. removeQueue ( remove Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( remove Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_6.txt": "{\n  \"file\": \"27_6.txt\",\n  \"assertion\": \"assertNull ( queue. removeue ( null Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( null Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_7.txt": "{\n  \"file\": \"27_7.txt\",\n  \"assertion\": \"assertNull ( queue. removeQueue ( null Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( null Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_8.txt": "{\n  \"file\": \"27_8.txt\",\n  \"assertion\": \"assertNull ( queue. removeue ( connection Context ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( connection Context ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "27_9.txt": "{\n  \"file\": \"27_9.txt\",\n  \"assertion\": \"assertNull ( queue. remove ( ( connection Object ( ) ) )\\r\\n\",\n  \"test\": \"class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. remove ( ( connection Object ( ) ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void dequeue( Object  var24678 ) { Object found \\u003d null ; synchronized ( mutex ) { found \\u003d find ( obj ) ; if ( found !\\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\\r\\n\",\n  \"truth\": \"assertNull ( queue. dequeue ( new Object ( ) ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_0.txt": "{\n  \"file\": \"28_0.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_1.txt": "{\n  \"file\": \"28_1.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ation. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_10.txt": "{\n  \"file\": \"28_10.txt\",\n  \"assertion\": \"assertEquals ( 0, 0Failure. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Failure. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_11.txt": "{\n  \"file\": \"28_11.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 eventsFound ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsFound ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_12.txt": "{\n  \"file\": \"28_12.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 eventsEvents ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsEvents ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_13.txt": "{\n  \"file\": \"28_13.txt\",\n  \"assertion\": \"assertEquals ( 0, 0Event. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Event. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_14.txt": "{\n  \"file\": \"28_14.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ation. 0 eventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 eventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_15.txt": "{\n  \"file\": \"28_15.txt\",\n  \"assertion\": \"assertEquals ( 0, 0n. 0 eventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0n. 0 eventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_16.txt": "{\n  \"file\": \"28_16.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 metrics. 0 eventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 metrics. 0 eventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_17.txt": "{\n  \"file\": \"28_17.txt\",\n  \"assertion\": \"assertEquals ( 1, 0 validation. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 1, 0 validation. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_18.txt": "{\n  \"file\": \"28_18.txt\",\n  \"assertion\": \"assertEquals ( 0, 1 validation. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 1 validation. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_19.txt": "{\n  \"file\": \"28_19.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ation. 0 eventsed ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 eventsed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_2.txt": "{\n  \"file\": \"28_2.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 eventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_20.txt": "{\n  \"file\": \"28_20.txt\",\n  \"assertion\": \"assertEquals ( 0, 0f. 0 eventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0f. 0 eventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_21.txt": "{\n  \"file\": \"28_21.txt\",\n  \"assertion\": \"assertEquals ( 0, 0Error. 0 eventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Error. 0 eventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_22.txt": "{\n  \"file\": \"28_22.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 eventsError ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsError ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_23.txt": "{\n  \"file\": \"28_23.txt\",\n  \"assertion\": \"assertEquals ( 0, 0n. 0 eventsed ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0n. 0 eventsed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_24.txt": "{\n  \"file\": \"28_24.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 metrics. 0 eventsed ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 metrics. 0 eventsed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_25.txt": "{\n  \"file\": \"28_25.txt\",\n  \"assertion\": \"assertEquals ( 0, 0ation. 0 Events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 Events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_26.txt": "{\n  \"file\": \"28_26.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 EventsCount ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 EventsCount ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_27.txt": "{\n  \"file\": \"28_27.txt\",\n  \"assertion\": \"assertEquals ( 0, 0f. 0 eventsed ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0f. 0 eventsed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_28.txt": "{\n  \"file\": \"28_28.txt\",\n  \"assertion\": \"assertEquals ( 0, 0Error. 0 eventsed ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Error. 0 eventsed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_29.txt": "{\n  \"file\": \"28_29.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0Events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0Events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_3.txt": "{\n  \"file\": \"28_3.txt\",\n  \"assertion\": \"assertEquals ( 0, 0n. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0n. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_4.txt": "{\n  \"file\": \"28_4.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 metrics. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 metrics. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_5.txt": "{\n  \"file\": \"28_5.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 eventsed ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsed ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_6.txt": "{\n  \"file\": \"28_6.txt\",\n  \"assertion\": \"assertEquals ( 0, 0f. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0f. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_7.txt": "{\n  \"file\": \"28_7.txt\",\n  \"assertion\": \"assertEquals ( 0, 0Error. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Error. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_8.txt": "{\n  \"file\": \"28_8.txt\",\n  \"assertion\": \"assertEquals ( 0, 0 validation. 0 Events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 Events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "28_9.txt": "{\n  \"file\": \"28_9.txt\",\n  \"assertion\": \"assertEquals ( 0, 0x. 0 events size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \\u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \\u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \\u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0x. 0 events size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, vh. getEventsSize ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_0.txt": "{\n  \"file\": \"29_0.txt\",\n  \"assertion\": \"assertEquals ( parsed )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( parsed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_1.txt": "{\n  \"file\": \"29_1.txt\",\n  \"assertion\": \"assertEquals ( 0 )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_10.txt": "{\n  \"file\": \"29_10.txt\",\n  \"assertion\": \"assertEquals ( null )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_11.txt": "{\n  \"file\": \"29_11.txt\",\n  \"assertion\": \"assertEquals ( parse )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( parse ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_12.txt": "{\n  \"file\": \"29_12.txt\",\n  \"assertion\": \"assertEquals ( 6 )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 6 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_13.txt": "{\n  \"file\": \"29_13.txt\",\n  \"assertion\": \"assertEquals ( detected )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( detected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_14.txt": "{\n  \"file\": \"29_14.txt\",\n  \"assertion\": \"assertEquals ( mounted )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( mounted ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_15.txt": "{\n  \"file\": \"29_15.txt\",\n  \"assertion\": \"assertEquals ( declared )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( declared ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_16.txt": "{\n  \"file\": \"29_16.txt\",\n  \"assertion\": \"assertEquals ( formatted )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( formatted ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_17.txt": "{\n  \"file\": \"29_17.txt\",\n  \"assertion\": \"assertEquals ( passed )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( passed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_18.txt": "{\n  \"file\": \"29_18.txt\",\n  \"assertion\": \"assertEquals ( texted )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( texted ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_19.txt": "{\n  \"file\": \"29_19.txt\",\n  \"assertion\": \"assertEquals ( resolved )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( resolved ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_2.txt": "{\n  \"file\": \"29_2.txt\",\n  \"assertion\": \"assertEquals ( 1 )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_20.txt": "{\n  \"file\": \"29_20.txt\",\n  \"assertion\": \"assertEquals ( chopped )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( chopped ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_21.txt": "{\n  \"file\": \"29_21.txt\",\n  \"assertion\": \"assertEquals ( split )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( split ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_22.txt": "{\n  \"file\": \"29_22.txt\",\n  \"assertion\": \"assertEquals ( spoken )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( spoken ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_23.txt": "{\n  \"file\": \"29_23.txt\",\n  \"assertion\": \"assertEquals ( interpreted )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( interpreted ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_24.txt": "{\n  \"file\": \"29_24.txt\",\n  \"assertion\": \"assertEquals ( used )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( used ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_25.txt": "{\n  \"file\": \"29_25.txt\",\n  \"assertion\": \"assertEquals ( looked )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( looked ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_26.txt": "{\n  \"file\": \"29_26.txt\",\n  \"assertion\": \"assertEquals ( rooted )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( rooted ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_27.txt": "{\n  \"file\": \"29_27.txt\",\n  \"assertion\": \"assertEquals ( listened )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( listened ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_28.txt": "{\n  \"file\": \"29_28.txt\",\n  \"assertion\": \"assertEquals (ed )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals (ed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_29.txt": "{\n  \"file\": \"29_29.txt\",\n  \"assertion\": \"assertEquals ( read )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( read ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_3.txt": "{\n  \"file\": \"29_3.txt\",\n  \"assertion\": \"assertEquals ( 5 )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_4.txt": "{\n  \"file\": \"29_4.txt\",\n  \"assertion\": \"assertEquals ( expected )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_5.txt": "{\n  \"file\": \"29_5.txt\",\n  \"assertion\": \"assertEquals ( 3 )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_6.txt": "{\n  \"file\": \"29_6.txt\",\n  \"assertion\": \"assertEquals ( recognized )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( recognized ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_7.txt": "{\n  \"file\": \"29_7.txt\",\n  \"assertion\": \"assertEquals ( parser )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( parser ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_8.txt": "{\n  \"file\": \"29_8.txt\",\n  \"assertion\": \"assertEquals ( sent )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( sent ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "29_9.txt": "{\n  \"file\": \"29_9.txt\",\n  \"assertion\": \"assertEquals ( 2 )\\r\\n\",\n  \"test\": \"class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \\u003d parseJson ( \\\"message\\\" , \\\"other\\u003csp\\u003emessage\\u003csp\\u003ein\\u003csp\\u003ebody\\\" ) ; String parsed \\u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { return new S3Utilities ( this ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( parsed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_0.txt": "{\n  \"file\": \"2_0.txt\",\n  \"assertion\": \"assertNull ( doc. image images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. image images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_1.txt": "{\n  \"file\": \"2_1.txt\",\n  \"assertion\": \"assertNull ( doc. is images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. is images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_10.txt": "{\n  \"file\": \"2_10.txt\",\n  \"assertion\": \"assertNull ( doc. source images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. source images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_11.txt": "{\n  \"file\": \"2_11.txt\",\n  \"assertion\": \"assertNull ( doc. new images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. new images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"doc.new images()\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "2_12.txt": "{\n  \"file\": \"2_12.txt\",\n  \"assertion\": \"assertNull ( doc. [ images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. [ images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_13.txt": "{\n  \"file\": \"2_13.txt\",\n  \"assertion\": \"assertNull ( doc. open images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. open images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_14.txt": "{\n  \"file\": \"2_14.txt\",\n  \"assertion\": \"assertNull ( doc. : images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. : images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_15.txt": "{\n  \"file\": \"2_15.txt\",\n  \"assertion\": \"assertNull ( doc. public images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. public images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_16.txt": "{\n  \"file\": \"2_16.txt\",\n  \"assertion\": \"assertNull ( doc. imageMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. imageMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"imageMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_17.txt": "{\n  \"file\": \"2_17.txt\",\n  \"assertion\": \"assertNull ( doc. download images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. download images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_18.txt": "{\n  \"file\": \"2_18.txt\",\n  \"assertion\": \"assertNull ( doc. available images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. available images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_19.txt": "{\n  \"file\": \"2_19.txt\",\n  \"assertion\": \"assertNull ( doc. -\\u003e images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. -\\u003e images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_2.txt": "{\n  \"file\": \"2_2.txt\",\n  \"assertion\": \"assertNull ( doc. get images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. get images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_20.txt": "{\n  \"file\": \"2_20.txt\",\n  \"assertion\": \"assertNull ( doc. create images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. create images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_21.txt": "{\n  \"file\": \"2_21.txt\",\n  \"assertion\": \"assertNull ( doc. isMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. isMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"isMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_22.txt": "{\n  \"file\": \"2_22.txt\",\n  \"assertion\": \"assertNull ( doc. export images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. export images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_23.txt": "{\n  \"file\": \"2_23.txt\",\n  \"assertion\": \"assertNull ( doc. imageImage ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. imageImage ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"imageImage\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_24.txt": "{\n  \"file\": \"2_24.txt\",\n  \"assertion\": \"assertNull ( doc. getMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. getMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"getMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_25.txt": "{\n  \"file\": \"2_25.txt\",\n  \"assertion\": \"assertNull ( doc. allMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. allMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"allMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_26.txt": "{\n  \"file\": \"2_26.txt\",\n  \"assertion\": \"assertNull ( doc. gMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. gMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"gMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_27.txt": "{\n  \"file\": \"2_27.txt\",\n  \"assertion\": \"assertNull ( doc. addMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. addMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"addMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_28.txt": "{\n  \"file\": \"2_28.txt\",\n  \"assertion\": \"assertNull ( doc. toMedia ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. toMedia ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"toMedia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "2_29.txt": "{\n  \"file\": \"2_29.txt\",\n  \"assertion\": \"assertNull ( doc. find images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. find images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_3.txt": "{\n  \"file\": \"2_3.txt\",\n  \"assertion\": \"assertNull ( doc. all images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. all images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_4.txt": "{\n  \"file\": \"2_4.txt\",\n  \"assertion\": \"assertNull ( doc. g images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. g images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_5.txt": "{\n  \"file\": \"2_5.txt\",\n  \"assertion\": \"assertNull ( doc. add images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. add images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_6.txt": "{\n  \"file\": \"2_6.txt\",\n  \"assertion\": \"assertNull ( doc. to images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. to images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_7.txt": "{\n  \"file\": \"2_7.txt\",\n  \"assertion\": \"assertNull ( doc. int images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. int images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_8.txt": "{\n  \"file\": \"2_8.txt\",\n  \"assertion\": \"assertNull ( doc. has images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. has images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "2_9.txt": "{\n  \"file\": \"2_9.txt\",\n  \"assertion\": \"assertNull ( doc. i images ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \\u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. i images ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getImages() { return this . images ; } }\\r\\n\",\n  \"truth\": \"assertNull ( doc. getImages ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "30_0.txt": "{\n  \"file\": \"30_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_1.txt": "{\n  \"file\": \"30_1.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_10.txt": "{\n  \"file\": \"30_10.txt\",\n  \"assertion\": \"assertEquals ( expected, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_11.txt": "{\n  \"file\": \"30_11.txt\",\n  \"assertion\": \"assertEquals ( content, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( content, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"content\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_12.txt": "{\n  \"file\": \"30_12.txt\",\n  \"assertion\": \"assertEquals ( expected, content )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, content ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"content\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_13.txt": "{\n  \"file\": \"30_13.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_14.txt": "{\n  \"file\": \"30_14.txt\",\n  \"assertion\": \"assertEquals ( expected, null )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_15.txt": "{\n  \"file\": \"30_15.txt\",\n  \"assertion\": \"assertEquals (expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals (expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_16.txt": "{\n  \"file\": \"30_16.txt\",\n  \"assertion\": \"assertEquals ( unexpected, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( unexpected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_17.txt": "{\n  \"file\": \"30_17.txt\",\n  \"assertion\": \"assertEquals ( assumed, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( assumed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_18.txt": "{\n  \"file\": \"30_18.txt\",\n  \"assertion\": \"assertEquals ( email, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( email, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"email\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_19.txt": "{\n  \"file\": \"30_19.txt\",\n  \"assertion\": \"assertEquals ( expectations, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expectations, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expectations\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_2.txt": "{\n  \"file\": \"30_2.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_20.txt": "{\n  \"file\": \"30_20.txt\",\n  \"assertion\": \"assertEquals ( found, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( found, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"found\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_21.txt": "{\n  \"file\": \"30_21.txt\",\n  \"assertion\": \"assertEquals ( expected, found )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, found ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"found\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_22.txt": "{\n  \"file\": \"30_22.txt\",\n  \"assertion\": \"assertEquals ( 200, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( 200, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"200\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_23.txt": "{\n  \"file\": \"30_23.txt\",\n  \"assertion\": \"assertEquals ( expects, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expects, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expects\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_24.txt": "{\n  \"file\": \"30_24.txt\",\n  \"assertion\": \"assertEquals ( sent, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( sent, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"sent\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_25.txt": "{\n  \"file\": \"30_25.txt\",\n  \"assertion\": \"assertEquals ( observed, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( observed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"observed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_26.txt": "{\n  \"file\": \"30_26.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_27.txt": "{\n  \"file\": \"30_27.txt\",\n  \"assertion\": \"assertEquals ( expected, 10 )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_28.txt": "{\n  \"file\": \"30_28.txt\",\n  \"assertion\": \"assertEquals ( supposed, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( supposed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"supposed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_29.txt": "{\n  \"file\": \"30_29.txt\",\n  \"assertion\": \"assertEquals ( detected, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( detected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"detected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_3.txt": "{\n  \"file\": \"30_3.txt\",\n  \"assertion\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, actual ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"actual\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"actual\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "30_4.txt": "{\n  \"file\": \"30_4.txt\",\n  \"assertion\": \"assertEquals ( actual, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( actual, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"actual\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "30_5.txt": "{\n  \"file\": \"30_5.txt\",\n  \"assertion\": \"assertEquals ( expecting, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expecting, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_6.txt": "{\n  \"file\": \"30_6.txt\",\n  \"assertion\": \"assertEquals ( expected, expecting )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, expecting ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_7.txt": "{\n  \"file\": \"30_7.txt\",\n  \"assertion\": \"assertEquals ( expectation, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expectation, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expectation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_8.txt": "{\n  \"file\": \"30_8.txt\",\n  \"assertion\": \"assertEquals (pected, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals (pected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "30_9.txt": "{\n  \"file\": \"30_9.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void testRender ( ) { String templateVariable \\u003d \\\"Hello\\u003csp\\u003eRocker!\\\" ; String expected \\u003d String . format ( \\\"\\u003ch1\\u003e%s\\u003c/h1\\u003e\\\\n\\\" , templateVariable ) ; String actual \\u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_0.txt": "{\n  \"file\": \"31_0.txt\",\n  \"assertion\": \"assertEquals ( ret, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_1.txt": "{\n  \"file\": \"31_1.txt\",\n  \"assertion\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 1, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_10.txt": "{\n  \"file\": \"31_10.txt\",\n  \"assertion\": \"assertEquals ( ret, rc )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, rc ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"rc\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_11.txt": "{\n  \"file\": \"31_11.txt\",\n  \"assertion\": \"assertEquals ( true, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( true, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_12.txt": "{\n  \"file\": \"31_12.txt\",\n  \"assertion\": \"assertEquals ( ret, true )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_13.txt": "{\n  \"file\": \"31_13.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 1, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_14.txt": "{\n  \"file\": \"31_14.txt\",\n  \"assertion\": \"assertEquals ( exit, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( exit, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"exit\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_15.txt": "{\n  \"file\": \"31_15.txt\",\n  \"assertion\": \"assertEquals ( ret, exit )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, exit ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"exit\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_16.txt": "{\n  \"file\": \"31_16.txt\",\n  \"assertion\": \"assertEquals ( 10, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 10, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_17.txt": "{\n  \"file\": \"31_17.txt\",\n  \"assertion\": \"assertEquals ( ret, 10 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_18.txt": "{\n  \"file\": \"31_18.txt\",\n  \"assertion\": \"assertEquals ( Ret, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( Ret, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"Ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_19.txt": "{\n  \"file\": \"31_19.txt\",\n  \"assertion\": \"assertEquals ( ret, Ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, Ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"Ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_2.txt": "{\n  \"file\": \"31_2.txt\",\n  \"assertion\": \"assertEquals ( ret, 1 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_20.txt": "{\n  \"file\": \"31_20.txt\",\n  \"assertion\": \"assertEquals (ret, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals (ret, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_21.txt": "{\n  \"file\": \"31_21.txt\",\n  \"assertion\": \"assertEquals ( ret,ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret,ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_22.txt": "{\n  \"file\": \"31_22.txt\",\n  \"assertion\": \"assertEquals ( return, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( return, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "31_23.txt": "{\n  \"file\": \"31_23.txt\",\n  \"assertion\": \"assertEquals ( ret, return )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, return ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "31_24.txt": "{\n  \"file\": \"31_24.txt\",\n  \"assertion\": \"assertEquals ( 1, 0 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 1, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_25.txt": "{\n  \"file\": \"31_25.txt\",\n  \"assertion\": \"assertEquals ( 0, 1 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 0, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_26.txt": "{\n  \"file\": \"31_26.txt\",\n  \"assertion\": \"assertEquals ( RET, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( RET, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"RET\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_27.txt": "{\n  \"file\": \"31_27.txt\",\n  \"assertion\": \"assertEquals ( ret, RET )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, RET ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"RET\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_28.txt": "{\n  \"file\": \"31_28.txt\",\n  \"assertion\": \"assertEquals ( success, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( success, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"success\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_29.txt": "{\n  \"file\": \"31_29.txt\",\n  \"assertion\": \"assertEquals ( ret, success )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, success ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"success\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_3.txt": "{\n  \"file\": \"31_3.txt\",\n  \"assertion\": \"assertEquals ( 0, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 0, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_4.txt": "{\n  \"file\": \"31_4.txt\",\n  \"assertion\": \"assertEquals ( ret, 0 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_5.txt": "{\n  \"file\": \"31_5.txt\",\n  \"assertion\": \"assertEquals ( 2, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 2, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_6.txt": "{\n  \"file\": \"31_6.txt\",\n  \"assertion\": \"assertEquals ( ret, 2 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_7.txt": "{\n  \"file\": \"31_7.txt\",\n  \"assertion\": \"assertEquals ( 3, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( 3, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_8.txt": "{\n  \"file\": \"31_8.txt\",\n  \"assertion\": \"assertEquals ( ret, 3 )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( ret, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "31_9.txt": "{\n  \"file\": \"31_9.txt\",\n  \"assertion\": \"assertEquals ( rc, ret )\\r\\n\",\n  \"test\": \"class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \\\"/testDir\\\" ) ) ; int ret \\u003d mFsShell . run ( \\\"test\\\" , \\\"-f\\\" , \\\"/testDir\\\" ) ; assertEquals ( rc, ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \\u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \\u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \\u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \\\"Exception\\u003csp\\u003eencountered\\u003csp\\u003ewhen\\u003csp\\u003estarting\\u003csp\\u003ea\\u003csp\\u003ejob.\\\" , e ) ; continue ; } JobInfo jobInfo \\u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \\u003d\\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \\u003d\\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \\\"Job\\u003csp\\u003e{}\\u003csp\\u003efailed\\u003csp\\u003eto\\u003csp\\u003ecomplete:\\u003csp\\u003e{}\\\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \\\"Failed\\u003csp\\u003eto\\u003csp\\u003esuccessfully\\u003csp\\u003ecomplete\\u003csp\\u003ethe\\u003csp\\u003ejob.\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, ret )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"ret\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"rc\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "32_0.txt": "{\n  \"file\": \"32_0.txt\",\n  \"assertion\": \"assertEquals ( v. dense ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. dense ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dense\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_1.txt": "{\n  \"file\": \"32_1.txt\",\n  \"assertion\": \"assertEquals ( v. + ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. + ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "32_10.txt": "{\n  \"file\": \"32_10.txt\",\n  \"assertion\": \"assertEquals ( v. dense ( v ), m )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. dense ( v ), m ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"m\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dense\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"m\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"DenseMatrix\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_11.txt": "{\n  \"file\": \"32_11.txt\",\n  \"assertion\": \"assertEquals ( v. dense ( m ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. dense ( m ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dense\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_12.txt": "{\n  \"file\": \"32_12.txt\",\n  \"assertion\": \"assertEquals ( v. + ( v ), m )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. + ( v ), m ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "32_13.txt": "{\n  \"file\": \"32_13.txt\",\n  \"assertion\": \"assertEquals ( v. + ( m ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. + ( m ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "32_14.txt": "{\n  \"file\": \"32_14.txt\",\n  \"assertion\": \"assertEquals ( m. + ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( m. + ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "32_15.txt": "{\n  \"file\": \"32_15.txt\",\n  \"assertion\": \"assertEquals ( v. row ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. row ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"row\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_16.txt": "{\n  \"file\": \"32_16.txt\",\n  \"assertion\": \"assertEquals ( v. add ( v ), m )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. add ( v ), m ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"m\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"add\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"m\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"DenseMatrix\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_17.txt": "{\n  \"file\": \"32_17.txt\",\n  \"assertion\": \"assertEquals ( m. add ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( m. add ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"add\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_18.txt": "{\n  \"file\": \"32_18.txt\",\n  \"assertion\": \"assertEquals ( v. add ( m ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. add ( m ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"add\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_19.txt": "{\n  \"file\": \"32_19.txt\",\n  \"assertion\": \"assertEquals ( v. columns ( v ), m )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. columns ( v ), m ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"m\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"columns\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"m\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"DenseMatrix\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_2.txt": "{\n  \"file\": \"32_2.txt\",\n  \"assertion\": \"assertEquals ( v. add ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. add ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"add\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_20.txt": "{\n  \"file\": \"32_20.txt\",\n  \"assertion\": \"assertEquals ( m. columns ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( m. columns ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"columns\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_21.txt": "{\n  \"file\": \"32_21.txt\",\n  \"assertion\": \"assertEquals ( v. columns ( m ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. columns ( m ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"columns\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_22.txt": "{\n  \"file\": \"32_22.txt\",\n  \"assertion\": \"assertEquals ( v. multiply ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. multiply ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"multiply\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_23.txt": "{\n  \"file\": \"32_23.txt\",\n  \"assertion\": \"assertEquals ( v. plus ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. plus ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"plus\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"plus\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "32_24.txt": "{\n  \"file\": \"32_24.txt\",\n  \"assertion\": \"assertEquals ( v. exp ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. exp ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"exp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_25.txt": "{\n  \"file\": \"32_25.txt\",\n  \"assertion\": \"assertEquals ( v. get ( v ), m )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. get ( v ), m ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"m\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"get\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"m\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"DenseMatrix\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_26.txt": "{\n  \"file\": \"32_26.txt\",\n  \"assertion\": \"assertEquals ( m. get ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( m. get ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"get\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_27.txt": "{\n  \"file\": \"32_27.txt\",\n  \"assertion\": \"assertEquals ( v. get ( m ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. get ( m ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"get\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_28.txt": "{\n  \"file\": \"32_28.txt\",\n  \"assertion\": \"assertEquals ( v. create ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. create ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"create\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_29.txt": "{\n  \"file\": \"32_29.txt\",\n  \"assertion\": \"assertEquals ( u. dense ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( u. dense ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dense\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_3.txt": "{\n  \"file\": \"32_3.txt\",\n  \"assertion\": \"assertEquals ( v. columns ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. columns ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"columns\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_4.txt": "{\n  \"file\": \"32_4.txt\",\n  \"assertion\": \"assertEquals ( v. get ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. get ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"get\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_5.txt": "{\n  \"file\": \"32_5.txt\",\n  \"assertion\": \"assertEquals ( v. sum ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. sum ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"sum\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_6.txt": "{\n  \"file\": \"32_6.txt\",\n  \"assertion\": \"assertEquals ( v. rows ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. rows ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"rows\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_7.txt": "{\n  \"file\": \"32_7.txt\",\n  \"assertion\": \"assertEquals ( v. mul ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. mul ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"mul\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_8.txt": "{\n  \"file\": \"32_8.txt\",\n  \"assertion\": \"assertEquals ( v. column ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( v. column ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"column\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "32_9.txt": "{\n  \"file\": \"32_9.txt\",\n  \"assertion\": \"assertEquals ( m. dense ( v ), v )\\r\\n\",\n  \"test\": \"class X {public void testSprSparseDense2 ( ) { double alpha \\u003d 3.0 ; SparseVector v \\u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \\u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \\u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \\u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \\u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\\u003e i \\u003e\\u003d j ) ; assertEquals ( m. dense ( v ), v ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( m. plus ( a ), mu )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"v\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dense\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"v\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SparseVector\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "33_0.txt": "{\n  \"file\": \"33_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_1.txt": "{\n  \"file\": \"33_1.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_10.txt": "{\n  \"file\": \"33_10.txt\",\n  \"assertion\": \"assertEquals (expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals (expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_11.txt": "{\n  \"file\": \"33_11.txt\",\n  \"assertion\": \"assertEquals ( expecting, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expecting, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_12.txt": "{\n  \"file\": \"33_12.txt\",\n  \"assertion\": \"assertEquals ( expected, expecting )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, expecting ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_13.txt": "{\n  \"file\": \"33_13.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_14.txt": "{\n  \"file\": \"33_14.txt\",\n  \"assertion\": \"assertEquals ( expected, 0 )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_15.txt": "{\n  \"file\": \"33_15.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_16.txt": "{\n  \"file\": \"33_16.txt\",\n  \"assertion\": \"assertEquals ( expected, 10 )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_17.txt": "{\n  \"file\": \"33_17.txt\",\n  \"assertion\": \"assertEquals ( unexpected, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( unexpected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_18.txt": "{\n  \"file\": \"33_18.txt\",\n  \"assertion\": \"assertEquals ( expected, unexpected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, unexpected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_19.txt": "{\n  \"file\": \"33_19.txt\",\n  \"assertion\": \"assertEquals ( assumed, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( assumed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_2.txt": "{\n  \"file\": \"33_2.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_20.txt": "{\n  \"file\": \"33_20.txt\",\n  \"assertion\": \"assertEquals ( expected, assumed )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, assumed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_21.txt": "{\n  \"file\": \"33_21.txt\",\n  \"assertion\": \"assertEquals ( 8, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( 8, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_22.txt": "{\n  \"file\": \"33_22.txt\",\n  \"assertion\": \"assertEquals ( expectations, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expectations, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expectations\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_23.txt": "{\n  \"file\": \"33_23.txt\",\n  \"assertion\": \"assertEquals ( exp, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( exp, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"exp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_24.txt": "{\n  \"file\": \"33_24.txt\",\n  \"assertion\": \"assertEquals ( expected, exp )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, exp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"exp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_25.txt": "{\n  \"file\": \"33_25.txt\",\n  \"assertion\": \"assertEquals ( 123, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( 123, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"123\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_26.txt": "{\n  \"file\": \"33_26.txt\",\n  \"assertion\": \"assertEquals ( predicted, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( predicted, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"predicted\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_27.txt": "{\n  \"file\": \"33_27.txt\",\n  \"assertion\": \"assertEquals ( observed, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( observed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"observed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_28.txt": "{\n  \"file\": \"33_28.txt\",\n  \"assertion\": \"assertEquals ( expected, observed )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, observed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"observed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_29.txt": "{\n  \"file\": \"33_29.txt\",\n  \"assertion\": \"assertEquals ( anticipated, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( anticipated, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"anticipated\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_3.txt": "{\n  \"file\": \"33_3.txt\",\n  \"assertion\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, actual ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"actual\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"actual\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "33_4.txt": "{\n  \"file\": \"33_4.txt\",\n  \"assertion\": \"assertEquals ( actual, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( actual, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"actual\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "33_5.txt": "{\n  \"file\": \"33_5.txt\",\n  \"assertion\": \"assertEquals (pected, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals (pected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_6.txt": "{\n  \"file\": \"33_6.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_7.txt": "{\n  \"file\": \"33_7.txt\",\n  \"assertion\": \"assertEquals ( expected, null )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_8.txt": "{\n  \"file\": \"33_8.txt\",\n  \"assertion\": \"assertEquals ( expectation, expected )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expectation, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expectation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "33_9.txt": "{\n  \"file\": \"33_9.txt\",\n  \"assertion\": \"assertEquals ( expected, expectation )\\r\\n\",\n  \"test\": \"class X {public void testPaseNegativeInfinity ( ) { String source \\u003d \\\"(-Infinity)\\u003csp\\u003e-\\u003csp\\u003e(Infinity)i\\\" ; Complex expected \\u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \\u003d complexFormat . parse ( source ) ; assertEquals ( expected, expectation ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \\\"Parsing:\\u003csp\\u003e\\\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \\u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \\u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \\u003d\\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \\u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Complex\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expectation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "34_0.txt": "{\n  \"file\": \"34_0.txt\",\n  \"assertion\": \"assertNotNull ( instance. all m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. all m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_1.txt": "{\n  \"file\": \"34_1.txt\",\n  \"assertion\": \"assertNotNull ( instance. start m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. start m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_10.txt": "{\n  \"file\": \"34_10.txt\",\n  \"assertion\": \"assertNotNull ( instance. get M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. get M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_11.txt": "{\n  \"file\": \"34_11.txt\",\n  \"assertion\": \"assertNotNull ( instance. to m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. to m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_12.txt": "{\n  \"file\": \"34_12.txt\",\n  \"assertion\": \"assertNotNull ( instance. g m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. g m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_13.txt": "{\n  \"file\": \"34_13.txt\",\n  \"assertion\": \"assertNotNull ( instance. __ m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. __ m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_14.txt": "{\n  \"file\": \"34_14.txt\",\n  \"assertion\": \"assertNotNull ( instance. m M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. m M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_15.txt": "{\n  \"file\": \"34_15.txt\",\n  \"assertion\": \"assertNotNull ( instance. my m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. my m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_16.txt": "{\n  \"file\": \"34_16.txt\",\n  \"assertion\": \"assertNotNull ( instance. to M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. to M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_17.txt": "{\n  \"file\": \"34_17.txt\",\n  \"assertion\": \"assertNotNull ( instance. g M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. g M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_18.txt": "{\n  \"file\": \"34_18.txt\",\n  \"assertion\": \"assertNotNull ( instance. check m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. check m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_19.txt": "{\n  \"file\": \"34_19.txt\",\n  \"assertion\": \"assertNotNull ( instance. all mM mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. all mM mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_2.txt": "{\n  \"file\": \"34_2.txt\",\n  \"assertion\": \"assertNotNull ( instance. is m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. is m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_20.txt": "{\n  \"file\": \"34_20.txt\",\n  \"assertion\": \"assertNotNull ( instance. start mM mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. start mM mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_21.txt": "{\n  \"file\": \"34_21.txt\",\n  \"assertion\": \"assertNotNull ( instance. __ M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. __ M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_22.txt": "{\n  \"file\": \"34_22.txt\",\n  \"assertion\": \"assertNotNull ( instance. is mM mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. is mM mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_23.txt": "{\n  \"file\": \"34_23.txt\",\n  \"assertion\": \"assertNotNull ( instance. my M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. my M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_24.txt": "{\n  \"file\": \"34_24.txt\",\n  \"assertion\": \"assertNotNull ( instance. e mM mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. e mM mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_25.txt": "{\n  \"file\": \"34_25.txt\",\n  \"assertion\": \"assertNotNull ( instance. cache m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. cache m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_26.txt": "{\n  \"file\": \"34_26.txt\",\n  \"assertion\": \"assertNotNull ( instance. pop m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. pop m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_27.txt": "{\n  \"file\": \"34_27.txt\",\n  \"assertion\": \"assertNotNull ( instance. current m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. current m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_28.txt": "{\n  \"file\": \"34_28.txt\",\n  \"assertion\": \"assertNotNull ( instance. find m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. find m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_29.txt": "{\n  \"file\": \"34_29.txt\",\n  \"assertion\": \"assertNotNull ( instance. check M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. check M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_3.txt": "{\n  \"file\": \"34_3.txt\",\n  \"assertion\": \"assertNotNull ( instance. e m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. e m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_4.txt": "{\n  \"file\": \"34_4.txt\",\n  \"assertion\": \"assertNotNull ( instance. all M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. all M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_5.txt": "{\n  \"file\": \"34_5.txt\",\n  \"assertion\": \"assertNotNull ( instance. get m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. get m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_6.txt": "{\n  \"file\": \"34_6.txt\",\n  \"assertion\": \"assertNotNull ( instance. start M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. start M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_7.txt": "{\n  \"file\": \"34_7.txt\",\n  \"assertion\": \"assertNotNull ( instance. is M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. is M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_8.txt": "{\n  \"file\": \"34_8.txt\",\n  \"assertion\": \"assertNotNull ( instance. e M mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. e M mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "34_9.txt": "{\n  \"file\": \"34_9.txt\",\n  \"assertion\": \"assertNotNull ( instance. m m mapping ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \\u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \\u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; IAtomContainer Molecule2 \\u003d sp . parseSmiles ( \\\"O1C\\u003dCC\\u003dC1\\\" ) ; CDKRMapHandler instance \\u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. m m mapping ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getMappings() { return mappings ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( instance. getMappings ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_0.txt": "{\n  \"file\": \"35_0.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_1.txt": "{\n  \"file\": \"35_1.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_10.txt": "{\n  \"file\": \"35_10.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll Bar ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll Bar ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_11.txt": "{\n  \"file\": \"35_11.txt\",\n  \"assertion\": \"assertEquals ( expected scroll Bar 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll Bar 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_12.txt": "{\n  \"file\": \"35_12.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll *0 )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll *0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_13.txt": "{\n  \"file\": \"35_13.txt\",\n  \"assertion\": \"assertEquals ( expected scroll_ 0, expected scroll * height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll * height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_14.txt": "{\n  \"file\": \"35_14.txt\",\n  \"assertion\": \"assertEquals ( expectedEl * 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedEl * 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_15.txt": "{\n  \"file\": \"35_15.txt\",\n  \"assertion\": \"assertEquals ( expected scroll bar 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll bar 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_16.txt": "{\n  \"file\": \"35_16.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll bar ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll bar ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_17.txt": "{\n  \"file\": \"35_17.txt\",\n  \"assertion\": \"assertEquals ( expectedC * 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedC * 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_18.txt": "{\n  \"file\": \"35_18.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expectedC * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expectedC * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_19.txt": "{\n  \"file\": \"35_19.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll Bar ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll Bar ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_2.txt": "{\n  \"file\": \"35_2.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll, ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_20.txt": "{\n  \"file\": \"35_20.txt\",\n  \"assertion\": \"assertEquals ( expected scroll Bar 0, expected scroll, ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll Bar 0, expected scroll, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_21.txt": "{\n  \"file\": \"35_21.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll *0 )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll *0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_22.txt": "{\n  \"file\": \"35_22.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll,0 )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll,0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_23.txt": "{\n  \"file\": \"35_23.txt\",\n  \"assertion\": \"assertEquals ( expected scroll_ 0, expected scroll, height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll, height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_24.txt": "{\n  \"file\": \"35_24.txt\",\n  \"assertion\": \"assertEquals ( expectedEl * 0, expected scroll, ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedEl * 0, expected scroll, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_25.txt": "{\n  \"file\": \"35_25.txt\",\n  \"assertion\": \"assertEquals ( expectedEl, 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedEl, 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_26.txt": "{\n  \"file\": \"35_26.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll bar ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll bar ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_27.txt": "{\n  \"file\": \"35_27.txt\",\n  \"assertion\": \"assertEquals ( expected scroll bar 0, expected scroll, ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll bar 0, expected scroll, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_28.txt": "{\n  \"file\": \"35_28.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * ), expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * ), expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_29.txt": "{\n  \"file\": \"35_29.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll Bar height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll Bar height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_3.txt": "{\n  \"file\": \"35_3.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll * height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll * height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_4.txt": "{\n  \"file\": \"35_4.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll, ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_5.txt": "{\n  \"file\": \"35_5.txt\",\n  \"assertion\": \"assertEquals ( expected scroll_ 0, expected scroll * ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll * ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_6.txt": "{\n  \"file\": \"35_6.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll * height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll * height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_7.txt": "{\n  \"file\": \"35_7.txt\",\n  \"assertion\": \"assertEquals ( expected scroll * 0, expected scroll, height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll, height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_8.txt": "{\n  \"file\": \"35_8.txt\",\n  \"assertion\": \"assertEquals ( expected scroll_ 0, expected scroll, ) )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "35_9.txt": "{\n  \"file\": \"35_9.txt\",\n  \"assertion\": \"assertEquals ( expected scroll, 0, expected scroll, height )\\r\\n\",\n  \"test\": \"class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \\u003d mock ( AbsolutePanel . class ) ; final Element element \\u003d mock ( Element . class ) ; final Integer offsetHeight \\u003d 1014 ; final Integer clientHeight \\u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \\u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \\u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll, height ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_0.txt": "{\n  \"file\": \"36_0.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. set genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_1.txt": "{\n  \"file\": \"36_1.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. set genle ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genle ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_10.txt": "{\n  \"file\": \"36_10.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. tag genle ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genle ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_11.txt": "{\n  \"file\": \"36_11.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. set genret ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genret ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_12.txt": "{\n  \"file\": \"36_12.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. set genrep ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genrep ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_13.txt": "{\n  \"file\": \"36_13.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. tag gen re ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag gen re ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_14.txt": "{\n  \"file\": \"36_14.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. set general ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set general ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_15.txt": "{\n  \"file\": \"36_15.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. get genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. get genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_16.txt": "{\n  \"file\": \"36_16.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. get genle ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. get genle ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_17.txt": "{\n  \"file\": \"36_17.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. v genret ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genret ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_18.txt": "{\n  \"file\": \"36_18.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. v genrep ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genrep ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_19.txt": "{\n  \"file\": \"36_19.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. get gen re ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. get gen re ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_2.txt": "{\n  \"file\": \"36_2.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. set gen re ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set gen re ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_20.txt": "{\n  \"file\": \"36_20.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. v general ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v general ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_21.txt": "{\n  \"file\": \"36_21.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. int genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. int genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_22.txt": "{\n  \"file\": \"36_22.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. gen genret ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genret ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_23.txt": "{\n  \"file\": \"36_23.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. int genle ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. int genle ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_24.txt": "{\n  \"file\": \"36_24.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. gen genrep ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genrep ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_25.txt": "{\n  \"file\": \"36_25.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. gen general ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen general ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_26.txt": "{\n  \"file\": \"36_26.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. int gen re ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. int gen re ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_27.txt": "{\n  \"file\": \"36_27.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. tag genret ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genret ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_28.txt": "{\n  \"file\": \"36_28.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. tag genrep ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genrep ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_29.txt": "{\n  \"file\": \"36_29.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. t genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. t genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_3.txt": "{\n  \"file\": \"36_3.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. v genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_4.txt": "{\n  \"file\": \"36_4.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. v genle ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genle ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_5.txt": "{\n  \"file\": \"36_5.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. v gen re ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v gen re ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_6.txt": "{\n  \"file\": \"36_6.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. gen genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_7.txt": "{\n  \"file\": \"36_7.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. gen genle ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genle ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_8.txt": "{\n  \"file\": \"36_8.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. gen gen re ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen gen re ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "36_9.txt": "{\n  \"file\": \"36_9.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. tag genber ( ) )\\r\\n\",\n  \"test\": \"class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \\u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \\u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genber ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\\u003d null ) \\u0026\\u0026 ( ( id3v2Tag . getGenre ( ) ) !\\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 10, wrapper. getGenre ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_0.txt": "{\n  \"file\": \"37_0.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_1.txt": "{\n  \"file\": \"37_1.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d second instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d second instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_10.txt": "{\n  \"file\": \"37_10.txt\",\n  \"assertion\": \"assertTrue ( ( firstance \\u003d\\u003d second instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstance \\u003d\\u003d second instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_11.txt": "{\n  \"file\": \"37_11.txt\",\n  \"assertion\": \"assertTrue ( ( secondance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( secondance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_12.txt": "{\n  \"file\": \"37_12.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d secondance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d secondance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_13.txt": "{\n  \"file\": \"37_13.txt\",\n  \"assertion\": \"assertTrue ( ( second instance \\u003d\\u003d firstance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \\u003d\\u003d firstance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_14.txt": "{\n  \"file\": \"37_14.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d firstOne ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d firstOne ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_15.txt": "{\n  \"file\": \"37_15.txt\",\n  \"assertion\": \"assertTrue ( ( firstinstance \\u003d\\u003d second instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstinstance \\u003d\\u003d second instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_16.txt": "{\n  \"file\": \"37_16.txt\",\n  \"assertion\": \"assertTrue ( ( secondinstance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( secondinstance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_17.txt": "{\n  \"file\": \"37_17.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d secondinstance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d secondinstance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_18.txt": "{\n  \"file\": \"37_18.txt\",\n  \"assertion\": \"assertTrue ( ( second instance \\u003d\\u003d firstinstance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \\u003d\\u003d firstinstance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_19.txt": "{\n  \"file\": \"37_19.txt\",\n  \"assertion\": \"assertTrue ( ( initial instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( initial instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_2.txt": "{\n  \"file\": \"37_2.txt\",\n  \"assertion\": \"assertTrue ( ( second instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_20.txt": "{\n  \"file\": \"37_20.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d initial instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d initial instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_21.txt": "{\n  \"file\": \"37_21.txt\",\n  \"assertion\": \"assertTrue ( ( last instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( last instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_22.txt": "{\n  \"file\": \"37_22.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d last instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d last instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_23.txt": "{\n  \"file\": \"37_23.txt\",\n  \"assertion\": \"assertTrue ( ( firstInstance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstInstance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_24.txt": "{\n  \"file\": \"37_24.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d firstInstance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d firstInstance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_25.txt": "{\n  \"file\": \"37_25.txt\",\n  \"assertion\": \"assertTrue ( ( First instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( First instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_26.txt": "{\n  \"file\": \"37_26.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d First instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d First instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_27.txt": "{\n  \"file\": \"37_27.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d firstSame ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d firstSame ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_28.txt": "{\n  \"file\": \"37_28.txt\",\n  \"assertion\": \"assertTrue ( ( third instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( third instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_29.txt": "{\n  \"file\": \"37_29.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d third instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d third instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_3.txt": "{\n  \"file\": \"37_3.txt\",\n  \"assertion\": \"assertTrue ( ( second instance \\u003d\\u003d second instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \\u003d\\u003d second instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_4.txt": "{\n  \"file\": \"37_4.txt\",\n  \"assertion\": \"assertTrue ( ( firstance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_5.txt": "{\n  \"file\": \"37_5.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d firstance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d firstance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_6.txt": "{\n  \"file\": \"37_6.txt\",\n  \"assertion\": \"assertTrue ( ( firstinstance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstinstance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_7.txt": "{\n  \"file\": \"37_7.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003d firstinstance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003d firstinstance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_8.txt": "{\n  \"file\": \"37_8.txt\",\n  \"assertion\": \"assertTrue ( (first instance \\u003d\\u003d first instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( (first instance \\u003d\\u003d first instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "37_9.txt": "{\n  \"file\": \"37_9.txt\",\n  \"assertion\": \"assertTrue ( ( first instance \\u003d\\u003dfirst instance ) )\\r\\n\",\n  \"test\": \"class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \\u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \\u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \\u003d\\u003dfirst instance ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getS3Client() { String smr_stage \\u003d System . getenv ( ) . System . get ( \\\"SMR_STAGE\\\" ) ; if ( smr_stage . equals ( \\\"DEV\\\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( firstInstance \\u003d\\u003d secondInstance ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_0.txt": "{\n  \"file\": \"38_0.txt\",\n  \"assertion\": \"assertEquals ( job, job ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_1.txt": "{\n  \"file\": \"38_1.txt\",\n  \"assertion\": \"assertEquals ( job, job ). outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_10.txt": "{\n  \"file\": \"38_10.txt\",\n  \"assertion\": \"assertEquals ( job, job ). serialJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). serialJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_11.txt": "{\n  \"file\": \"38_11.txt\",\n  \"assertion\": \"assertEquals ( job, jobJob. runJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, jobJob. runJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"job\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"job\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"JobConf\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"runJob\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "38_12.txt": "{\n  \"file\": \"38_12.txt\",\n  \"assertion\": \"assertEquals ( job, j ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, j ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_13.txt": "{\n  \"file\": \"38_13.txt\",\n  \"assertion\": \"assertEquals ( j, job ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( j, job ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_14.txt": "{\n  \"file\": \"38_14.txt\",\n  \"assertion\": \"assertEquals ( job, job ). run string ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). run string ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_15.txt": "{\n  \"file\": \"38_15.txt\",\n  \"assertion\": \"assertEquals ( job, j ). outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, j ). outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_16.txt": "{\n  \"file\": \"38_16.txt\",\n  \"assertion\": \"assertEquals ( j, job ). outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( j, job ). outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_17.txt": "{\n  \"file\": \"38_17.txt\",\n  \"assertion\": \"assertEquals ( job, job ). target String ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). target String ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_18.txt": "{\n  \"file\": \"38_18.txt\",\n  \"assertion\": \"assertEquals ( job, job ). output String ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). output String ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_19.txt": "{\n  \"file\": \"38_19.txt\",\n  \"assertion\": \"assertEquals ( 1, job ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( 1, job ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_2.txt": "{\n  \"file\": \"38_2.txt\",\n  \"assertion\": \"assertEquals ( job, job ). runJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). runJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_20.txt": "{\n  \"file\": \"38_20.txt\",\n  \"assertion\": \"assertEquals ( job, job ). toJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). toJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_21.txt": "{\n  \"file\": \"38_21.txt\",\n  \"assertion\": \"assertEquals ( 1, job ). outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( 1, job ). outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_22.txt": "{\n  \"file\": \"38_22.txt\",\n  \"assertion\": \"assertEquals ( job, job ). debugJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). debugJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_23.txt": "{\n  \"file\": \"38_23.txt\",\n  \"assertion\": \"assertEquals ( ), job ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( ), job ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_24.txt": "{\n  \"file\": \"38_24.txt\",\n  \"assertion\": \"assertEquals ( job, ) ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, ) ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_25.txt": "{\n  \"file\": \"38_25.txt\",\n  \"assertion\": \"assertEquals ( job, job ). createJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). createJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_26.txt": "{\n  \"file\": \"38_26.txt\",\n  \"assertion\": \"assertEquals ( ), job ). outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( ), job ). outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_27.txt": "{\n  \"file\": \"38_27.txt\",\n  \"assertion\": \"assertEquals ( job, ) ). outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, ) ). outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_28.txt": "{\n  \"file\": \"38_28.txt\",\n  \"assertion\": \"assertEquals ( 0, job ). targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( 0, job ). targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_29.txt": "{\n  \"file\": \"38_29.txt\",\n  \"assertion\": \"assertEquals ( job, job ). newJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). newJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_3.txt": "{\n  \"file\": \"38_3.txt\",\n  \"assertion\": \"assertEquals ( job, job ). strJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). strJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_4.txt": "{\n  \"file\": \"38_4.txt\",\n  \"assertion\": \"assertEquals ( job, jobJob. targetJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, jobJob. targetJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"job\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"job\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"JobConf\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"targetJob\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "38_5.txt": "{\n  \"file\": \"38_5.txt\",\n  \"assertion\": \"assertEquals ( job, jobJob. outputJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, jobJob. outputJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"job\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"job\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"JobConf\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"outputJob\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "38_6.txt": "{\n  \"file\": \"38_6.txt\",\n  \"assertion\": \"assertEquals ( job, job ). target string ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). target string ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_7.txt": "{\n  \"file\": \"38_7.txt\",\n  \"assertion\": \"assertEquals ( job, job ). nextJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). nextJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_8.txt": "{\n  \"file\": \"38_8.txt\",\n  \"assertion\": \"assertEquals ( job, job ). output string ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). output string ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "38_9.txt": "{\n  \"file\": \"38_9.txt\",\n  \"assertion\": \"assertEquals ( job, job ). startJob ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCommitter ( ) { JobConf job \\u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \\u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \\u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \\u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \\u003d \\\"test.txt\\\" ; Reporter reporter \\u003d Reporter . NULL ; FileSystem localFs \\u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \\u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \\u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \\u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \\u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key1 ) . append ( \\\"\\\\n\\\" ) ; expectedOutput . append ( key2 ) . append ( \\u0027\\\\t\\u0027 ) . append ( val2 ) . append ( \\\"\\\\n\\\" ) ; String output \\u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). startJob ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \\\"OzoneFileSystem{URI\\u003d\\\" + ( uri ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"workingDir\\u003d\\\" ) + ( workingDir ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"userName\\u003d\\\" ) + ( userName ) ) + \\\",\\u003csp\\u003e\\\" ) + \\\"statistics\\u003d\\\" ) + ( statistics ) ) + \\\"}\\\" ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( output, expectedOutput. toString ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "39_0.txt": "{\n  \"file\": \"39_0.txt\",\n  \"assertion\": \"assertNull ( result )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"FileUploadHandler\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "39_1.txt": "{\n  \"file\": \"39_1.txt\",\n  \"assertion\": \"assertNull ( test )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( test ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"test\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_10.txt": "{\n  \"file\": \"39_10.txt\",\n  \"assertion\": \"assertNull (Result )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull (Result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_11.txt": "{\n  \"file\": \"39_11.txt\",\n  \"assertion\": \"assertNull ( call )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( call ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"call\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_12.txt": "{\n  \"file\": \"39_12.txt\",\n  \"assertion\": \"assertNull ( return )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( return ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "39_13.txt": "{\n  \"file\": \"39_13.txt\",\n  \"assertion\": \"assertNull ( handle )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( handle ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"handle\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_14.txt": "{\n  \"file\": \"39_14.txt\",\n  \"assertion\": \"assertNull ( end )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( end ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"end\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_15.txt": "{\n  \"file\": \"39_15.txt\",\n  \"assertion\": \"assertNull ( results )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_16.txt": "{\n  \"file\": \"39_16.txt\",\n  \"assertion\": \"assertNull ( 2 )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_17.txt": "{\n  \"file\": \"39_17.txt\",\n  \"assertion\": \"assertNull ( continue )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( continue ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "39_18.txt": "{\n  \"file\": \"39_18.txt\",\n  \"assertion\": \"assertNull ( server )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( server ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"server\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_19.txt": "{\n  \"file\": \"39_19.txt\",\n  \"assertion\": \"assertNull ( successor )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( successor ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"successor\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_2.txt": "{\n  \"file\": \"39_2.txt\",\n  \"assertion\": \"assertNull ( match )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( match ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_20.txt": "{\n  \"file\": \"39_20.txt\",\n  \"assertion\": \"assertNull ( callback )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( callback ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"callback\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_21.txt": "{\n  \"file\": \"39_21.txt\",\n  \"assertion\": \"assertNull ( function )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( function ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"function\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_22.txt": "{\n  \"file\": \"39_22.txt\",\n  \"assertion\": \"assertNull ( cause )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( cause ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"cause\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_23.txt": "{\n  \"file\": \"39_23.txt\",\n  \"assertion\": \"assertNull ( output )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( output ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"output\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_24.txt": "{\n  \"file\": \"39_24.txt\",\n  \"assertion\": \"assertNull ( Result )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( Result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_25.txt": "{\n  \"file\": \"39_25.txt\",\n  \"assertion\": \"assertNull ( type )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( type ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"type\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_26.txt": "{\n  \"file\": \"39_26.txt\",\n  \"assertion\": \"assertNull ( target )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( target ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"target\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_27.txt": "{\n  \"file\": \"39_27.txt\",\n  \"assertion\": \"assertNull ( ret )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( ret ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ret\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_28.txt": "{\n  \"file\": \"39_28.txt\",\n  \"assertion\": \"assertNull ( client )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( client ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"client\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_29.txt": "{\n  \"file\": \"39_29.txt\",\n  \"assertion\": \"assertNull ( rule )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( rule ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"rule\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_3.txt": "{\n  \"file\": \"39_3.txt\",\n  \"assertion\": \"assertNull ( future )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( future ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"future\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_4.txt": "{\n  \"file\": \"39_4.txt\",\n  \"assertion\": \"assertNull (result )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull (result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"FileUploadHandler\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "39_5.txt": "{\n  \"file\": \"39_5.txt\",\n  \"assertion\": \"assertNull ( answer )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( answer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"answer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_6.txt": "{\n  \"file\": \"39_6.txt\",\n  \"assertion\": \"assertNull ( null )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_7.txt": "{\n  \"file\": \"39_7.txt\",\n  \"assertion\": \"assertNull ( combine )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( combine ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"combine\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_8.txt": "{\n  \"file\": \"39_8.txt\",\n  \"assertion\": \"assertNull ( instance )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( instance ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"instance\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "39_9.txt": "{\n  \"file\": \"39_9.txt\",\n  \"assertion\": \"assertNull ( value )\\r\\n\",\n  \"test\": \"class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \\\"testId\\\" , testHandler ) ; handlerStore . deregisterHandler ( \\\"testId\\\" ) ; FileUploadHandler result \\u003d handlerStore . getHandler ( \\\"testId\\\" ) ; assertNull ( value ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\\r\\n\",\n  \"truth\": \"assertNull ( result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_0.txt": "{\n  \"file\": \"3_0.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_1.txt": "{\n  \"file\": \"3_1.txt\",\n  \"assertion\": \"assertEquals ( 1, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_10.txt": "{\n  \"file\": \"3_10.txt\",\n  \"assertion\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, counter ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"counter\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"counter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_11.txt": "{\n  \"file\": \"3_11.txt\",\n  \"assertion\": \"assertEquals ( counter, 1 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( counter, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"counter\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"counter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_12.txt": "{\n  \"file\": \"3_12.txt\",\n  \"assertion\": \"assertEquals ( 3, 1 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 3, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_13.txt": "{\n  \"file\": \"3_13.txt\",\n  \"assertion\": \"assertEquals ( 1, 3 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_14.txt": "{\n  \"file\": \"3_14.txt\",\n  \"assertion\": \"assertEquals ( 10, 1 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 10, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_15.txt": "{\n  \"file\": \"3_15.txt\",\n  \"assertion\": \"assertEquals ( 1, 10 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_16.txt": "{\n  \"file\": \"3_16.txt\",\n  \"assertion\": \"assertEquals ( 4, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 4, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_17.txt": "{\n  \"file\": \"3_17.txt\",\n  \"assertion\": \"assertEquals ( 2, 4 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_18.txt": "{\n  \"file\": \"3_18.txt\",\n  \"assertion\": \"assertEquals ( 5, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 5, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"5\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_19.txt": "{\n  \"file\": \"3_19.txt\",\n  \"assertion\": \"assertEquals ( 20, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 20, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"20\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_2.txt": "{\n  \"file\": \"3_2.txt\",\n  \"assertion\": \"assertEquals ( 2, 1 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_20.txt": "{\n  \"file\": \"3_20.txt\",\n  \"assertion\": \"assertEquals ( 2, 20 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 20 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"20\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_21.txt": "{\n  \"file\": \"3_21.txt\",\n  \"assertion\": \"assertEquals ( 4, 1 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 4, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_22.txt": "{\n  \"file\": \"3_22.txt\",\n  \"assertion\": \"assertEquals ( 1, 4 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_23.txt": "{\n  \"file\": \"3_23.txt\",\n  \"assertion\": \"assertEquals ( 1000, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1000, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1000\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_24.txt": "{\n  \"file\": \"3_24.txt\",\n  \"assertion\": \"assertEquals ( 2, 1000 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 1000 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1000\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_25.txt": "{\n  \"file\": \"3_25.txt\",\n  \"assertion\": \"assertEquals ( counter, counter )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( counter, counter ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"counter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"counter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_26.txt": "{\n  \"file\": \"3_26.txt\",\n  \"assertion\": \"assertEquals ( 100, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 100, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"100\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_27.txt": "{\n  \"file\": \"3_27.txt\",\n  \"assertion\": \"assertEquals ( 2, 100 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 100 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"100\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_28.txt": "{\n  \"file\": \"3_28.txt\",\n  \"assertion\": \"assertEquals ( 16, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 16, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"16\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_29.txt": "{\n  \"file\": \"3_29.txt\",\n  \"assertion\": \"assertEquals ( 2, 16 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 16 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"16\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_3.txt": "{\n  \"file\": \"3_3.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_4.txt": "{\n  \"file\": \"3_4.txt\",\n  \"assertion\": \"assertEquals ( 2, counter )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, counter ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"counter\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"counter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_5.txt": "{\n  \"file\": \"3_5.txt\",\n  \"assertion\": \"assertEquals ( counter, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( counter, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"counter\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"counter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_6.txt": "{\n  \"file\": \"3_6.txt\",\n  \"assertion\": \"assertEquals ( 3, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 3, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_7.txt": "{\n  \"file\": \"3_7.txt\",\n  \"assertion\": \"assertEquals ( 2, 3 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_8.txt": "{\n  \"file\": \"3_8.txt\",\n  \"assertion\": \"assertEquals ( 10, 2 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 10, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "3_9.txt": "{\n  \"file\": \"3_9.txt\",\n  \"assertion\": \"assertEquals ( 2, 10 )\\r\\n\",\n  \"test\": \"class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \\u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \\u003c String , Object \\u003e config \\u003d new HashMap ( ) ; int counter \\u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \\\"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\\\" ) ; serializer . configure ( config , null ) ; counter \\u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get() { return this . t ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, counter )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "40_0.txt": "{\n  \"file\": \"40_0.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_1.txt": "{\n  \"file\": \"40_1.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int8 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int8 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_10.txt": "{\n  \"file\": \"40_10.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_11.txt": "{\n  \"file\": \"40_11.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 Int80 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int80 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_12.txt": "{\n  \"file\": \"40_12.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7int8 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int8 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_13.txt": "{\n  \"file\": \"40_13.txt\",\n  \"assertion\": \"assertEquals ( 8, 1. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 8, 1. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_14.txt": "{\n  \"file\": \"40_14.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 8 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 8 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_15.txt": "{\n  \"file\": \"40_15.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 Int10 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int10 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_16.txt": "{\n  \"file\": \"40_16.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 intf ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 intf ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_17.txt": "{\n  \"file\": \"40_17.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 Int ++ ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int ++ ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_18.txt": "{\n  \"file\": \"40_18.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7int80 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int80 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_19.txt": "{\n  \"file\": \"40_19.txt\",\n  \"assertion\": \"assertEquals ( 7, value. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, value. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_2.txt": "{\n  \"file\": \"40_2.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int80 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int80 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_20.txt": "{\n  \"file\": \"40_20.txt\",\n  \"assertion\": \"assertEquals ( 7, field. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, field. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_21.txt": "{\n  \"file\": \"40_21.txt\",\n  \"assertion\": \"assertEquals ( 9, 1. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 9, 1. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_22.txt": "{\n  \"file\": \"40_22.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 intfield ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 intfield ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_23.txt": "{\n  \"file\": \"40_23.txt\",\n  \"assertion\": \"assertEquals ( 7, number. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, number. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_24.txt": "{\n  \"file\": \"40_24.txt\",\n  \"assertion\": \"assertEquals ( 8, 1. 7 int8 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 8, 1. 7 int8 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_25.txt": "{\n  \"file\": \"40_25.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 8 int8 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 8 int8 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_26.txt": "{\n  \"file\": \"40_26.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7int10 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int10 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_27.txt": "{\n  \"file\": \"40_27.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7int ++ ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int ++ ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_28.txt": "{\n  \"file\": \"40_28.txt\",\n  \"assertion\": \"assertEquals ( 7, java. 7 int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, java. 7 int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_29.txt": "{\n  \"file\": \"40_29.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7In field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7In field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_3.txt": "{\n  \"file\": \"40_3.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int10 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int10 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_4.txt": "{\n  \"file\": \"40_4.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int ++ ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int ++ ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_5.txt": "{\n  \"file\": \"40_5.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 Int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_6.txt": "{\n  \"file\": \"40_6.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int15 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int15 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_7.txt": "{\n  \"file\": \"40_7.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 int Field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int Field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_8.txt": "{\n  \"file\": \"40_8.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7int field ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int field ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "40_9.txt": "{\n  \"file\": \"40_9.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 7 Int8 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetIn ( ) { TstJavaBean bean \\u003d new TstJavaBean ( ) ; BaseProperty \\u003c Integer \\u003e INT_FIELD \\u003d new BaseProperty ( \\\"intField\\\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int8 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIntField() { return intField ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 7, bean. getIntField ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_0.txt": "{\n  \"file\": \"41_0.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_1.txt": "{\n  \"file\": \"41_1.txt\",\n  \"assertion\": \"assertEquals ( expected, 1, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 1, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_10.txt": "{\n  \"file\": \"41_10.txt\",\n  \"assertion\": \"assertEquals ( expectedTarget 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTarget 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_11.txt": "{\n  \"file\": \"41_11.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expected Count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expected Count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_12.txt": "{\n  \"file\": \"41_12.txt\",\n  \"assertion\": \"assertEquals ( expected transaction 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected transaction 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_13.txt": "{\n  \"file\": \"41_13.txt\",\n  \"assertion\": \"assertEquals ( expectedEntity 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedEntity 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_14.txt": "{\n  \"file\": \"41_14.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expectedCode )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedCode ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_15.txt": "{\n  \"file\": \"41_15.txt\",\n  \"assertion\": \"assertEquals ( expectedTo 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTo 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_16.txt": "{\n  \"file\": \"41_16.txt\",\n  \"assertion\": \"assertEquals ( expectedDefault count, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedDefault count, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_17.txt": "{\n  \"file\": \"41_17.txt\",\n  \"assertion\": \"assertEquals ( expected, 1, expectedCount )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 1, expectedCount ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_18.txt": "{\n  \"file\": \"41_18.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expectedcount )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedcount ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_19.txt": "{\n  \"file\": \"41_19.txt\",\n  \"assertion\": \"assertEquals ( expectedTask 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTask 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_2.txt": "{\n  \"file\": \"41_2.txt\",\n  \"assertion\": \"assertEquals ( expected, count, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, count, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_20.txt": "{\n  \"file\": \"41_20.txt\",\n  \"assertion\": \"assertEquals ( expectedT 1, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedT 1, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_21.txt": "{\n  \"file\": \"41_21.txt\",\n  \"assertion\": \"assertEquals ( expected,Max, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected,Max, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_22.txt": "{\n  \"file\": \"41_22.txt\",\n  \"assertion\": \"assertEquals ( expected, count, expectedCount )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, count, expectedCount ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_23.txt": "{\n  \"file\": \"41_23.txt\",\n  \"assertion\": \"assertEquals ( expected,Count, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected,Count, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_24.txt": "{\n  \"file\": \"41_24.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expectedCont )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedCont ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_25.txt": "{\n  \"file\": \"41_25.txt\",\n  \"assertion\": \"assertEquals ( expectedNot 1, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedNot 1, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_26.txt": "{\n  \"file\": \"41_26.txt\",\n  \"assertion\": \"assertEquals ( expectedTen 1, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTen 1, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_27.txt": "{\n  \"file\": \"41_27.txt\",\n  \"assertion\": \"assertEquals ( expectedRequest 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedRequest 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_28.txt": "{\n  \"file\": \"41_28.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expectedTotal )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedTotal ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_29.txt": "{\n  \"file\": \"41_29.txt\",\n  \"assertion\": \"assertEquals ( expected,2, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected,2, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_3.txt": "{\n  \"file\": \"41_3.txt\",\n  \"assertion\": \"assertEquals ( expectedDefault 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedDefault 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_4.txt": "{\n  \"file\": \"41_4.txt\",\n  \"assertion\": \"assertEquals ( expected, 0, expectedCount )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedCount ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_5.txt": "{\n  \"file\": \"41_5.txt\",\n  \"assertion\": \"assertEquals ( expected, ), expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, ), expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_6.txt": "{\n  \"file\": \"41_6.txt\",\n  \"assertion\": \"assertEquals ( expectedT 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedT 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_7.txt": "{\n  \"file\": \"41_7.txt\",\n  \"assertion\": \"assertEquals ( expectedNot 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedNot 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_8.txt": "{\n  \"file\": \"41_8.txt\",\n  \"assertion\": \"assertEquals ( expectedTen 0, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTen 0, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "41_9.txt": "{\n  \"file\": \"41_9.txt\",\n  \"assertion\": \"assertEquals ( expectedDefault 1, expected count )\\r\\n\",\n  \"test\": \"class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \\u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \\u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedDefault 1, expected count ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedTransactionCount, actualCount )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "42_0.txt": "{\n  \"file\": \"42_0.txt\",\n  \"assertion\": \"assertTrue ( true )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_1.txt": "{\n  \"file\": \"42_1.txt\",\n  \"assertion\": \"assertTrue ( false )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( false ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"false\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_10.txt": "{\n  \"file\": \"42_10.txt\",\n  \"assertion\": \"assertTrue ( untrue )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( untrue ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"untrue\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_11.txt": "{\n  \"file\": \"42_11.txt\",\n  \"assertion\": \"assertTrue (false )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue (false ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"false\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_12.txt": "{\n  \"file\": \"42_12.txt\",\n  \"assertion\": \"assertTrue ( 0 )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_13.txt": "{\n  \"file\": \"42_13.txt\",\n  \"assertion\": \"assertTrue ( FALSE )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( FALSE ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"FALSE\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_14.txt": "{\n  \"file\": \"42_14.txt\",\n  \"assertion\": \"assertTrue ( testing )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( testing ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"testing\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_15.txt": "{\n  \"file\": \"42_15.txt\",\n  \"assertion\": \"assertTrue ( boolean )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( boolean ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "42_16.txt": "{\n  \"file\": \"42_16.txt\",\n  \"assertion\": \"assertTrue ( ) )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "42_17.txt": "{\n  \"file\": \"42_17.txt\",\n  \"assertion\": \"assertTrue ( test )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( test ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"test\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_18.txt": "{\n  \"file\": \"42_18.txt\",\n  \"assertion\": \"assertTrue ( opposite )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( opposite ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"opposite\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_19.txt": "{\n  \"file\": \"42_19.txt\",\n  \"assertion\": \"assertTrue ( changed )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( changed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"changed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_2.txt": "{\n  \"file\": \"42_2.txt\",\n  \"assertion\": \"assertTrue ( TRUE )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( TRUE ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"TRUE\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_20.txt": "{\n  \"file\": \"42_20.txt\",\n  \"assertion\": \"assertTrue ( return )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( return ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "42_21.txt": "{\n  \"file\": \"42_21.txt\",\n  \"assertion\": \"assertTrue ( null )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_22.txt": "{\n  \"file\": \"42_22.txt\",\n  \"assertion\": \"assertTrue ( unlock )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( unlock ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"unlock\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_23.txt": "{\n  \"file\": \"42_23.txt\",\n  \"assertion\": \"assertTrue ( released )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( released ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"released\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_24.txt": "{\n  \"file\": \"42_24.txt\",\n  \"assertion\": \"assertTrue ( restored )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( restored ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"restored\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_25.txt": "{\n  \"file\": \"42_25.txt\",\n  \"assertion\": \"assertTrue ( correct )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( correct ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"correct\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_26.txt": "{\n  \"file\": \"42_26.txt\",\n  \"assertion\": \"assertTrue ( locked )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( locked ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"locked\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_27.txt": "{\n  \"file\": \"42_27.txt\",\n  \"assertion\": \"assertTrue (! )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue (! ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "42_28.txt": "{\n  \"file\": \"42_28.txt\",\n  \"assertion\": \"assertTrue ( continue )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( continue ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "42_29.txt": "{\n  \"file\": \"42_29.txt\",\n  \"assertion\": \"assertTrue ( check )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( check ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"check\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_3.txt": "{\n  \"file\": \"42_3.txt\",\n  \"assertion\": \"assertTrue (False )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue (False ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"False\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_4.txt": "{\n  \"file\": \"42_4.txt\",\n  \"assertion\": \"assertTrue ( True )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( True ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"True\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_5.txt": "{\n  \"file\": \"42_5.txt\",\n  \"assertion\": \"assertTrue (True )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue (True ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"True\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_6.txt": "{\n  \"file\": \"42_6.txt\",\n  \"assertion\": \"assertTrue ( False )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( False ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"False\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_7.txt": "{\n  \"file\": \"42_7.txt\",\n  \"assertion\": \"assertTrue (true )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue (true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_8.txt": "{\n  \"file\": \"42_8.txt\",\n  \"assertion\": \"assertTrue ( \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "42_9.txt": "{\n  \"file\": \"42_9.txt\",\n  \"assertion\": \"assertTrue ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testWithDifferentResource ( ) { LockManager \\u003c String \\u003e manager \\u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \\\"/resourceOne\\\" ) ; manager . lock ( \\\"/resourceTwo\\\" ) ; manager . unlock ( \\\"/resourceOne\\\" ) ; manager . unlock ( \\\"/resourceTwo\\\" ) ; assertTrue ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void unlock( T  var24678 ) { ActiveLock lock \\u003d activeLocks . get ( resource ) ; if ( lock \\u003d\\u003d null ) { LOG . warn ( \\\"Trying\\u003csp\\u003eto\\u003csp\\u003erelease\\u003csp\\u003ethe\\u003csp\\u003elock\\u003csp\\u003eon\\u003csp\\u003e{},\\u003csp\\u003ewhich\\u003csp\\u003ewas\\u003csp\\u003enever\\u003csp\\u003eacquired.\\\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( true )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_0.txt": "{\n  \"file\": \"43_0.txt\",\n  \"assertion\": \"assertFalse ( did ruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_1.txt": "{\n  \"file\": \"43_1.txt\",\n  \"assertion\": \"assertFalse ( did rule apply )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did rule apply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_10.txt": "{\n  \"file\": \"43_10.txt\",\n  \"assertion\": \"assertFalse ( did ruleSet )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleSet ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_11.txt": "{\n  \"file\": \"43_11.txt\",\n  \"assertion\": \"assertFalse ( didRulesDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didRulesDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didRulesDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_12.txt": "{\n  \"file\": \"43_12.txt\",\n  \"assertion\": \"assertFalse ( had ruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( had ruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_13.txt": "{\n  \"file\": \"43_13.txt\",\n  \"assertion\": \"assertFalse ( didPolicy apply )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didPolicy apply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_14.txt": "{\n  \"file\": \"43_14.txt\",\n  \"assertion\": \"assertFalse ( didn ruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didn ruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_15.txt": "{\n  \"file\": \"43_15.txt\",\n  \"assertion\": \"assertFalse ( did rule Apply )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did rule Apply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_16.txt": "{\n  \"file\": \"43_16.txt\",\n  \"assertion\": \"assertFalse ( d ruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( d ruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_17.txt": "{\n  \"file\": \"43_17.txt\",\n  \"assertion\": \"assertFalse ( didruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didruleDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_18.txt": "{\n  \"file\": \"43_18.txt\",\n  \"assertion\": \"assertFalse ( did Rule apply )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did Rule apply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_19.txt": "{\n  \"file\": \"43_19.txt\",\n  \"assertion\": \"assertFalse (\\u0027d ruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse (\\u0027d ruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_2.txt": "{\n  \"file\": \"43_2.txt\",\n  \"assertion\": \"assertFalse ( didValueDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didValueDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didValueDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_20.txt": "{\n  \"file\": \"43_20.txt\",\n  \"assertion\": \"assertFalse ( didByteDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didByteDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didByteDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_21.txt": "{\n  \"file\": \"43_21.txt\",\n  \"assertion\": \"assertFalse ( didRootDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didRootDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didRootDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_22.txt": "{\n  \"file\": \"43_22.txt\",\n  \"assertion\": \"assertFalse ( did ruleLimit )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleLimit ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_23.txt": "{\n  \"file\": \"43_23.txt\",\n  \"assertion\": \"assertFalse ( did ruleFilter )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleFilter ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_24.txt": "{\n  \"file\": \"43_24.txt\",\n  \"assertion\": \"assertFalse ( did ruleWrite )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleWrite ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_25.txt": "{\n  \"file\": \"43_25.txt\",\n  \"assertion\": \"assertFalse ( didRuleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didRuleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didRuleDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_26.txt": "{\n  \"file\": \"43_26.txt\",\n  \"assertion\": \"assertFalse ( didMethodDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didMethodDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didMethodDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_27.txt": "{\n  \"file\": \"43_27.txt\",\n  \"assertion\": \"assertFalse ( did ruleAccept )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleAccept ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_28.txt": "{\n  \"file\": \"43_28.txt\",\n  \"assertion\": \"assertFalse ( DID ruleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( DID ruleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_29.txt": "{\n  \"file\": \"43_29.txt\",\n  \"assertion\": \"assertFalse ( didModel apply )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didModel apply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_3.txt": "{\n  \"file\": \"43_3.txt\",\n  \"assertion\": \"assertFalse ( didPolicyDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didPolicyDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didPolicyDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_4.txt": "{\n  \"file\": \"43_4.txt\",\n  \"assertion\": \"assertFalse ( did ruleFile )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleFile ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_5.txt": "{\n  \"file\": \"43_5.txt\",\n  \"assertion\": \"assertFalse ( did RuleDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did RuleDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_6.txt": "{\n  \"file\": \"43_6.txt\",\n  \"assertion\": \"assertFalse ( did ruleMap )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleMap ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_7.txt": "{\n  \"file\": \"43_7.txt\",\n  \"assertion\": \"assertFalse ( didModelDo )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didModelDo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"didModelDo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "43_8.txt": "{\n  \"file\": \"43_8.txt\",\n  \"assertion\": \"assertFalse ( didValue apply )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( didValue apply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "43_9.txt": "{\n  \"file\": \"43_9.txt\",\n  \"assertion\": \"assertFalse ( did ruleMessage )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \\u003d rule . apply ( new SafeMap ( create ( \\\"closeReason\\\" , \\\"permanent_relocation\\\" ) . map ( ) ) ) ; assertFalse ( did ruleMessage ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void map() { return map ; } }\\r\\n\",\n  \"truth\": \"assertFalse ( didRuleApply )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "44_0.txt": "{\n  \"file\": \"44_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_1.txt": "{\n  \"file\": \"44_1.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_10.txt": "{\n  \"file\": \"44_10.txt\",\n  \"assertion\": \"assertEquals ( expected, 0 )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_11.txt": "{\n  \"file\": \"44_11.txt\",\n  \"assertion\": \"assertEquals ( 8, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 8, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_12.txt": "{\n  \"file\": \"44_12.txt\",\n  \"assertion\": \"assertEquals ( expected, 8 )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 8 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_13.txt": "{\n  \"file\": \"44_13.txt\",\n  \"assertion\": \"assertEquals (expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals (expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_14.txt": "{\n  \"file\": \"44_14.txt\",\n  \"assertion\": \"assertEquals ( expected,expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected,expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_15.txt": "{\n  \"file\": \"44_15.txt\",\n  \"assertion\": \"assertEquals ( 3, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 3, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_16.txt": "{\n  \"file\": \"44_16.txt\",\n  \"assertion\": \"assertEquals ( 1, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 1, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_17.txt": "{\n  \"file\": \"44_17.txt\",\n  \"assertion\": \"assertEquals ( expected, 1 )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_18.txt": "{\n  \"file\": \"44_18.txt\",\n  \"assertion\": \"assertEquals ( 20, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 20, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"20\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_19.txt": "{\n  \"file\": \"44_19.txt\",\n  \"assertion\": \"assertEquals ( expected, 20 )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 20 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"20\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_2.txt": "{\n  \"file\": \"44_2.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_20.txt": "{\n  \"file\": \"44_20.txt\",\n  \"assertion\": \"assertEquals ( found, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( found, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"found\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_21.txt": "{\n  \"file\": \"44_21.txt\",\n  \"assertion\": \"assertEquals ( expected, found )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, found ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"found\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_22.txt": "{\n  \"file\": \"44_22.txt\",\n  \"assertion\": \"assertEquals ( 2, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 2, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_23.txt": "{\n  \"file\": \"44_23.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( \\\"\\\", expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_24.txt": "{\n  \"file\": \"44_24.txt\",\n  \"assertion\": \"assertEquals ( expecting, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expecting, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_25.txt": "{\n  \"file\": \"44_25.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_26.txt": "{\n  \"file\": \"44_26.txt\",\n  \"assertion\": \"assertEquals ( assumed, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( assumed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_27.txt": "{\n  \"file\": \"44_27.txt\",\n  \"assertion\": \"assertEquals ( expected, assumed )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, assumed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_28.txt": "{\n  \"file\": \"44_28.txt\",\n  \"assertion\": \"assertEquals ( supposed, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( supposed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"supposed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_29.txt": "{\n  \"file\": \"44_29.txt\",\n  \"assertion\": \"assertEquals ( allowed, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( allowed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"allowed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_3.txt": "{\n  \"file\": \"44_3.txt\",\n  \"assertion\": \"assertEquals (pected, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals (pected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_4.txt": "{\n  \"file\": \"44_4.txt\",\n  \"assertion\": \"assertEquals ( expected,pected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected,pected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_5.txt": "{\n  \"file\": \"44_5.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_6.txt": "{\n  \"file\": \"44_6.txt\",\n  \"assertion\": \"assertEquals ( expected, 10 )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_7.txt": "{\n  \"file\": \"44_7.txt\",\n  \"assertion\": \"assertEquals ( 123, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 123, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"123\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_8.txt": "{\n  \"file\": \"44_8.txt\",\n  \"assertion\": \"assertEquals ( expected, 123 )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 123 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"123\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "44_9.txt": "{\n  \"file\": \"44_9.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \\u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \\u003d \\\"(way[\\\\\\\"landuse\\\\\\\"~\\\\\\\"forest|wood\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"waterway\\\\\\\"\\u003d\\\\\\\"riverbank\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"bridge\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\\\\\"highway\\\\\\\"~\\\\\\\"_link\\\\\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\\u003e;);out\\u003csp\\u003emeta;\\\" ; String actual \\u003d ob . buildOverpassQuery ( ) ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_0.txt": "{\n  \"file\": \"45_0.txt\",\n  \"assertion\": \"assertNotNull ( h buffalo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( h buffalo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "45_1.txt": "{\n  \"file\": \"45_1.txt\",\n  \"assertion\": \"assertNotNull ( hhi )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hhi ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hhi\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_10.txt": "{\n  \"file\": \"45_10.txt\",\n  \"assertion\": \"assertNotNull ( hla )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hla ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hla\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_11.txt": "{\n  \"file\": \"45_11.txt\",\n  \"assertion\": \"assertNotNull ( hula )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hula ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hula\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_12.txt": "{\n  \"file\": \"45_12.txt\",\n  \"assertion\": \"assertNotNull ( haho )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( haho ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"haho\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_13.txt": "{\n  \"file\": \"45_13.txt\",\n  \"assertion\": \"assertNotNull ( halia )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( halia ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"halia\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_14.txt": "{\n  \"file\": \"45_14.txt\",\n  \"assertion\": \"assertNotNull ( hale )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hale ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hale\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_15.txt": "{\n  \"file\": \"45_15.txt\",\n  \"assertion\": \"assertNotNull ( hlo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hlo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hlo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_16.txt": "{\n  \"file\": \"45_16.txt\",\n  \"assertion\": \"assertNotNull ( hello )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hello ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hello\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_17.txt": "{\n  \"file\": \"45_17.txt\",\n  \"assertion\": \"assertNotNull ( hala )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hala ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hala\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_18.txt": "{\n  \"file\": \"45_18.txt\",\n  \"assertion\": \"assertNotNull ( hero )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hero ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hero\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_19.txt": "{\n  \"file\": \"45_19.txt\",\n  \"assertion\": \"assertNotNull ( homa )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( homa ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"homa\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_2.txt": "{\n  \"file\": \"45_2.txt\",\n  \"assertion\": \"assertNotNull ( hho )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hho ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hho\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_20.txt": "{\n  \"file\": \"45_20.txt\",\n  \"assertion\": \"assertNotNull ( hroma )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hroma ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hroma\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_21.txt": "{\n  \"file\": \"45_21.txt\",\n  \"assertion\": \"assertNotNull ( hloe )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hloe ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hloe\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_22.txt": "{\n  \"file\": \"45_22.txt\",\n  \"assertion\": \"assertNotNull ( holler )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( holler ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"holler\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_23.txt": "{\n  \"file\": \"45_23.txt\",\n  \"assertion\": \"assertNotNull ( halos )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( halos ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"halos\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_24.txt": "{\n  \"file\": \"45_24.txt\",\n  \"assertion\": \"assertNotNull (h buffalo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull (h buffalo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "45_25.txt": "{\n  \"file\": \"45_25.txt\",\n  \"assertion\": \"assertNotNull ( hoe )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hoe ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hoe\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_26.txt": "{\n  \"file\": \"45_26.txt\",\n  \"assertion\": \"assertNotNull ( hallo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hallo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hallo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_27.txt": "{\n  \"file\": \"45_27.txt\",\n  \"assertion\": \"assertNotNull ( hao )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hao ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hao\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_28.txt": "{\n  \"file\": \"45_28.txt\",\n  \"assertion\": \"assertNotNull ( H buffalo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( H buffalo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "45_29.txt": "{\n  \"file\": \"45_29.txt\",\n  \"assertion\": \"assertNotNull ( ha buffalo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( ha buffalo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "45_3.txt": "{\n  \"file\": \"45_3.txt\",\n  \"assertion\": \"assertNotNull ( hila )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hila ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hila\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_4.txt": "{\n  \"file\": \"45_4.txt\",\n  \"assertion\": \"assertNotNull ( haley )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( haley ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"haley\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_5.txt": "{\n  \"file\": \"45_5.txt\",\n  \"assertion\": \"assertNotNull ( hana )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hana ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hana\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_6.txt": "{\n  \"file\": \"45_6.txt\",\n  \"assertion\": \"assertNotNull ( halo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( halo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"halo\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"halo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Halo\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "45_7.txt": "{\n  \"file\": \"45_7.txt\",\n  \"assertion\": \"assertNotNull ( hacho )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hacho ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hacho\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_8.txt": "{\n  \"file\": \"45_8.txt\",\n  \"assertion\": \"assertNotNull ( holo )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( holo ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"holo\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "45_9.txt": "{\n  \"file\": \"45_9.txt\",\n  \"assertion\": \"assertNotNull ( hino )\\r\\n\",\n  \"test\": \"class X {public void halo ( ) { HaloBuilder b \\u003d new HaloBuilder ( null ) ; Halo halo \\u003d b . build ( ) ; assertNotNull ( hino ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \\u003c Identifier \\u003e ( ids ) ) ; } }\\r\\n\",\n  \"truth\": \"assertNotNull ( halo )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hino\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "46_0.txt": "{\n  \"file\": \"46_0.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_1.txt": "{\n  \"file\": \"46_1.txt\",\n  \"assertion\": \"assertEquals ( ), ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_10.txt": "{\n  \"file\": \"46_10.txt\",\n  \"assertion\": \"assertEquals ( ), ). name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_11.txt": "{\n  \"file\": \"46_11.txt\",\n  \"assertion\": \"assertEquals ( ), ). title ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). title ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_12.txt": "{\n  \"file\": \"46_12.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\",\\\"). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\",\\\"). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_13.txt": "{\n  \"file\": \"46_13.txt\",\n  \"assertion\": \"assertEquals ( null, ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( null, ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_14.txt": "{\n  \"file\": \"46_14.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_15.txt": "{\n  \"file\": \"46_15.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", text. \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", text. \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_16.txt": "{\n  \"file\": \"46_16.txt\",\n  \"assertion\": \"assertEquals (\\\"), ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals (\\\"), ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_17.txt": "{\n  \"file\": \"46_17.txt\",\n  \"assertion\": \"assertEquals ( ),\\\"). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ),\\\"). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_18.txt": "{\n  \"file\": \"46_18.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). read ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). read ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_19.txt": "{\n  \"file\": \"46_19.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). string ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). string ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_2.txt": "{\n  \"file\": \"46_2.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). text ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). text ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_20.txt": "{\n  \"file\": \"46_20.txt\",\n  \"assertion\": \"assertEquals ( \\u0027\\u0027, ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\u0027\\u0027, ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_21.txt": "{\n  \"file\": \"46_21.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). word ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). word ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_22.txt": "{\n  \"file\": \"46_22.txt\",\n  \"assertion\": \"assertEquals ( ), ). value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_23.txt": "{\n  \"file\": \"46_23.txt\",\n  \"assertion\": \"assertEquals ( \\\", ). text ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\", ). text ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_24.txt": "{\n  \"file\": \"46_24.txt\",\n  \"assertion\": \"assertEquals ( text, ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( text, ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_25.txt": "{\n  \"file\": \"46_25.txt\",\n  \"assertion\": \"assertEquals ( ), text. \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), text. \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_26.txt": "{\n  \"file\": \"46_26.txt\",\n  \"assertion\": \"assertEquals ( 1, ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( 1, ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_27.txt": "{\n  \"file\": \"46_27.txt\",\n  \"assertion\": \"assertEquals (\\\", ). text ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals (\\\", ). text ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_28.txt": "{\n  \"file\": \"46_28.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). get ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). get ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_29.txt": "{\n  \"file\": \"46_29.txt\",\n  \"assertion\": \"assertEquals ( ), ). read ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). read ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_3.txt": "{\n  \"file\": \"46_3.txt\",\n  \"assertion\": \"assertEquals ( ), ). text ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). text ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_4.txt": "{\n  \"file\": \"46_4.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). message ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). message ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_5.txt": "{\n  \"file\": \"46_5.txt\",\n  \"assertion\": \"assertEquals ( ), ). message ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). message ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_6.txt": "{\n  \"file\": \"46_6.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_7.txt": "{\n  \"file\": \"46_7.txt\",\n  \"assertion\": \"assertEquals ( \\\", ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\", ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_8.txt": "{\n  \"file\": \"46_8.txt\",\n  \"assertion\": \"assertEquals (\\\", ). \\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals (\\\", ). \\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "46_9.txt": "{\n  \"file\": \"46_9.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", ). title ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \\u003d mgmt . makePropertyKey ( \\\"text\\\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \\\"store1\\\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \\u003d tx . addVertex ( ) ; TitanVertex v2 \\u003d tx . addVertex ( ) ; TitanVertex v3 \\u003d tx . addVertex ( ) ; v1 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\u003csp\\u003eHello\\\" ) ; v2 . property ( \\\"text\\\" , \\\"Hello\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdfsd\\u003csp\\u003esdffs\\u003csp\\u003efsdsdf\\u003csp\\u003efdf\\u003csp\\u003efsdfsd\\u003csp\\u003eaera\\u003csp\\u003efsad\\u003csp\\u003eabab\\u003csp\\u003eabab\\u003csp\\u003efsdfsd\\u003csp\\u003esfdf\\\" ) ; v3 . property ( \\\"text\\\" , \\\"Hello\\\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \\u003c Double \\u003e scores \\u003d new HashSet \\u003c Double \\u003e ( ) ; for ( Result \\u003c TitanVertex \\u003e r : graph . indexQuery ( \\\"store1\\\" , \\\"v.text:(Hello)\\\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \\\"\\\", ). title ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return vertices . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 3, scores. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_0.txt": "{\n  \"file\": \"47_0.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 0, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_1.txt": "{\n  \"file\": \"47_1.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 1, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_10.txt": "{\n  \"file\": \"47_10.txt\",\n  \"assertion\": \"assertEquals ( 9, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 9, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_11.txt": "{\n  \"file\": \"47_11.txt\",\n  \"assertion\": \"assertEquals ( 8, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 8, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_12.txt": "{\n  \"file\": \"47_12.txt\",\n  \"assertion\": \"assertEquals (0, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals (0, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_13.txt": "{\n  \"file\": \"47_13.txt\",\n  \"assertion\": \"assertEquals ( 20, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 20, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_14.txt": "{\n  \"file\": \"47_14.txt\",\n  \"assertion\": \"assertEquals ( 100, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 100, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_15.txt": "{\n  \"file\": \"47_15.txt\",\n  \"assertion\": \"assertEquals ( 12, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 12, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_16.txt": "{\n  \"file\": \"47_16.txt\",\n  \"assertion\": \"assertEquals ( 50, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 50, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_17.txt": "{\n  \"file\": \"47_17.txt\",\n  \"assertion\": \"assertEquals ( 15, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 15, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_18.txt": "{\n  \"file\": \"47_18.txt\",\n  \"assertion\": \"assertEquals ( 16, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 16, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_19.txt": "{\n  \"file\": \"47_19.txt\",\n  \"assertion\": \"assertEquals ( zero, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( zero, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_2.txt": "{\n  \"file\": \"47_2.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 0, 0. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_20.txt": "{\n  \"file\": \"47_20.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. zero ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 0, 0. zero ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_21.txt": "{\n  \"file\": \"47_21.txt\",\n  \"assertion\": \"assertEquals ( null, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( null, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_22.txt": "{\n  \"file\": \"47_22.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 1000, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_23.txt": "{\n  \"file\": \"47_23.txt\",\n  \"assertion\": \"assertEquals ( 11, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 11, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_24.txt": "{\n  \"file\": \"47_24.txt\",\n  \"assertion\": \"assertEquals ( None, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( None, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_25.txt": "{\n  \"file\": \"47_25.txt\",\n  \"assertion\": \"assertEquals ( false, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( false, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_26.txt": "{\n  \"file\": \"47_26.txt\",\n  \"assertion\": \"assertEquals ( N, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( N, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_27.txt": "{\n  \"file\": \"47_27.txt\",\n  \"assertion\": \"assertEquals ( n, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( n, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_28.txt": "{\n  \"file\": \"47_28.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 1, 0. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_29.txt": "{\n  \"file\": \"47_29.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 0, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_3.txt": "{\n  \"file\": \"47_3.txt\",\n  \"assertion\": \"assertEquals ( 3, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 3, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_4.txt": "{\n  \"file\": \"47_4.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 2, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_5.txt": "{\n  \"file\": \"47_5.txt\",\n  \"assertion\": \"assertEquals ( 4, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 4, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_6.txt": "{\n  \"file\": \"47_6.txt\",\n  \"assertion\": \"assertEquals ( 5, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 5, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_7.txt": "{\n  \"file\": \"47_7.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 10, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_8.txt": "{\n  \"file\": \"47_8.txt\",\n  \"assertion\": \"assertEquals ( 7, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 7, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "47_9.txt": "{\n  \"file\": \"47_9.txt\",\n  \"assertion\": \"assertEquals ( 6, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \\u003c TaskSummary \\u003e tasks \\u003d taskService . getTasksAssignedAsBusinessAdministrator ( \\\"Bobba\\u003csp\\u003eFet\\\" , \\\"en-UK\\\" ) ; assertEquals ( 6, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return data . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, tasks. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "48_0.txt": "{\n  \"file\": \"48_0.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_1.txt": "{\n  \"file\": \"48_1.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_10.txt": "{\n  \"file\": \"48_10.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), 100 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 100 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"100\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_11.txt": "{\n  \"file\": \"48_11.txt\",\n  \"assertion\": \"assertEquals ( queue. size ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. size ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "48_12.txt": "{\n  \"file\": \"48_12.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), i )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), i ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"i\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"i\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_13.txt": "{\n  \"file\": \"48_13.txt\",\n  \"assertion\": \"assertEquals ( queue. count ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. count ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"count\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_14.txt": "{\n  \"file\": \"48_14.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), 50 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 50 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"50\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_15.txt": "{\n  \"file\": \"48_15.txt\",\n  \"assertion\": \"assertEquals ( queue. len ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. len ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"len\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_16.txt": "{\n  \"file\": \"48_16.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), i )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), i ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"i\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"i\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_17.txt": "{\n  \"file\": \"48_17.txt\",\n  \"assertion\": \"assertEquals ( queue. tick ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. tick ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tick\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_18.txt": "{\n  \"file\": \"48_18.txt\",\n  \"assertion\": \"assertEquals ( queue. poll ( ), 1000 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. poll ( ), 1000 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"poll\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1000\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_19.txt": "{\n  \"file\": \"48_19.txt\",\n  \"assertion\": \"assertEquals ( queue. suffix ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. suffix ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"suffix\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_2.txt": "{\n  \"file\": \"48_2.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_20.txt": "{\n  \"file\": \"48_20.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), 50 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 50 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"50\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_21.txt": "{\n  \"file\": \"48_21.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), size )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), size ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_22.txt": "{\n  \"file\": \"48_22.txt\",\n  \"assertion\": \"assertEquals ( queue. size ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. size ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "48_23.txt": "{\n  \"file\": \"48_23.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), 1 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_24.txt": "{\n  \"file\": \"48_24.txt\",\n  \"assertion\": \"assertEquals ( queue. next ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. next ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"next\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_25.txt": "{\n  \"file\": \"48_25.txt\",\n  \"assertion\": \"assertEquals ( queue. len ( ), 1000 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. len ( ), 1000 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"len\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1000\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_26.txt": "{\n  \"file\": \"48_26.txt\",\n  \"assertion\": \"assertEquals ( queue. count ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. count ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"count\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_27.txt": "{\n  \"file\": \"48_27.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), size )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), size ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_28.txt": "{\n  \"file\": \"48_28.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), 10 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_29.txt": "{\n  \"file\": \"48_29.txt\",\n  \"assertion\": \"assertEquals ( queue. tick ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. tick ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"tick\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_3.txt": "{\n  \"file\": \"48_3.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_4.txt": "{\n  \"file\": \"48_4.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), 1000 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 1000 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1000\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_5.txt": "{\n  \"file\": \"48_5.txt\",\n  \"assertion\": \"assertEquals ( queue. index ( ), 1000 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 1000 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"index\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1000\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_6.txt": "{\n  \"file\": \"48_6.txt\",\n  \"assertion\": \"assertEquals ( queue. poll ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. poll ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"poll\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_7.txt": "{\n  \"file\": \"48_7.txt\",\n  \"assertion\": \"assertEquals ( queue. len ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. len ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"len\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_8.txt": "{\n  \"file\": \"48_8.txt\",\n  \"assertion\": \"assertEquals ( queue. name ( ), 100 )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 100 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"100\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "48_9.txt": "{\n  \"file\": \"48_9.txt\",\n  \"assertion\": \"assertEquals ( queue. poll ( ), name )\\r\\n\",\n  \"test\": \"class X {public void differentIdentifierSize ( ) { FairQueue \\u003c Q \\u003e queue \\u003d new FairQueue ( ) ; int size \\u003d 100 ; for ( int i \\u003d 0 ; i \\u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. poll ( ), name ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return list . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( queue. size ( ), size )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"poll\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"name\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "49_0.txt": "{\n  \"file\": \"49_0.txt\",\n  \"assertion\": \"assertTrue ( edit added [ mode ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ mode ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_1.txt": "{\n  \"file\": \"49_1.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_10.txt": "{\n  \"file\": \"49_10.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ 10 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 10 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[10]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_11.txt": "{\n  \"file\": \"49_11.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 50 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 50 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_12.txt": "{\n  \"file\": \"49_12.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 9 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 9 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_13.txt": "{\n  \"file\": \"49_13.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ start ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ start ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[start]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_14.txt": "{\n  \"file\": \"49_14.txt\",\n  \"assertion\": \"assertTrue ( edit added [ : ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ : ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_15.txt": "{\n  \"file\": \"49_15.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_16.txt": "{\n  \"file\": \"49_16.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_17.txt": "{\n  \"file\": \"49_17.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ - ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ - ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_18.txt": "{\n  \"file\": \"49_18.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 8 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 8 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_19.txt": "{\n  \"file\": \"49_19.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ 50 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 50 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[50]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_2.txt": "{\n  \"file\": \"49_2.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ mode ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ mode ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[mode]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_20.txt": "{\n  \"file\": \"49_20.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 16 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 16 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_21.txt": "{\n  \"file\": \"49_21.txt\",\n  \"assertion\": \"assertTrue ( edit added [ i ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ i ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_22.txt": "{\n  \"file\": \"49_22.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ 9 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 9 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[9]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_23.txt": "{\n  \"file\": \"49_23.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 7 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 7 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_24.txt": "{\n  \"file\": \"49_24.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ : ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ : ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_25.txt": "{\n  \"file\": \"49_25.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 5 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 5 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_26.txt": "{\n  \"file\": \"49_26.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[2]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_27.txt": "{\n  \"file\": \"49_27.txt\",\n  \"assertion\": \"assertTrue ( edit added [ zero ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ zero ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_28.txt": "{\n  \"file\": \"49_28.txt\",\n  \"assertion\": \"assertTrue ( editPosted [ mode ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editPosted [ mode ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editPosted[mode]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_29.txt": "{\n  \"file\": \"49_29.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 6 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 6 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_3.txt": "{\n  \"file\": \"49_3.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[0]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "49_4.txt": "{\n  \"file\": \"49_4.txt\",\n  \"assertion\": \"assertTrue ( edit added [ j ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ j ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_5.txt": "{\n  \"file\": \"49_5.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 10 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 10 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_6.txt": "{\n  \"file\": \"49_6.txt\",\n  \"assertion\": \"assertTrue ( edit added [ start ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ start ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_7.txt": "{\n  \"file\": \"49_7.txt\",\n  \"assertion\": \"assertTrue ( edit added [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_8.txt": "{\n  \"file\": \"49_8.txt\",\n  \"assertion\": \"assertTrue ( edit added [ - ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ - ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "49_9.txt": "{\n  \"file\": \"49_9.txt\",\n  \"assertion\": \"assertTrue ( editAdd [ j ] )\\r\\n\",\n  \"test\": \"class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \\u003d new JEditorPane ( \\\"text/plain\\\" , \\\"Haf\\\" ) ; final boolean [ ] editAdded \\u003d new boolean [ ] { false } ; final Document doc \\u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \\u003d true ; } } ) ; final EditorCaret editorCaret \\u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ j ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \\u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\\u003d null ) { UndoableEdit caretUndoEdit \\u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\\r\\n\",\n  \"truth\": \"assertTrue ( editAdded [ 0 ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"editAdd[j]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "4_0.txt": "{\n  \"file\": \"4_0.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_1.txt": "{\n  \"file\": \"4_1.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_10.txt": "{\n  \"file\": \"4_10.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0Q time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Q time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_11.txt": "{\n  \"file\": \"4_11.txt\",\n  \"assertion\": \"assertEquals ( 1000, 1. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 1. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_12.txt": "{\n  \"file\": \"4_12.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 10, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_13.txt": "{\n  \"file\": \"4_13.txt\",\n  \"assertion\": \"assertEquals ( 50, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 50, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_14.txt": "{\n  \"file\": \"4_14.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0Timeout Time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Timeout Time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_15.txt": "{\n  \"file\": \"4_15.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0Q time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Q time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_16.txt": "{\n  \"file\": \"4_16.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0Time Time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Time Time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_17.txt": "{\n  \"file\": \"4_17.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_18.txt": "{\n  \"file\": \"4_18.txt\",\n  \"assertion\": \"assertEquals ( 0, 1. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 1. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_19.txt": "{\n  \"file\": \"4_19.txt\",\n  \"assertion\": \"assertEquals ( 100, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 100, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_2.txt": "{\n  \"file\": \"4_2.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0Timeout time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Timeout time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_20.txt": "{\n  \"file\": \"4_20.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0Timeout Time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Timeout Time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_21.txt": "{\n  \"file\": \"4_21.txt\",\n  \"assertion\": \"assertEquals ( 5, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 5, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_22.txt": "{\n  \"file\": \"4_22.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0Time Time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Time Time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_23.txt": "{\n  \"file\": \"4_23.txt\",\n  \"assertion\": \"assertEquals ( 15, 0. 0 wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 15, 0. 0 wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_24.txt": "{\n  \"file\": \"4_24.txt\",\n  \"assertion\": \"assertEquals ( 1000, 1. 0Timeout time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 1. 0Timeout time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_25.txt": "{\n  \"file\": \"4_25.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. 0Timeout time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 10, 0. 0Timeout time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_26.txt": "{\n  \"file\": \"4_26.txt\",\n  \"assertion\": \"assertEquals ( 50, 0. 0Timeout time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 50, 0. 0Timeout time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_27.txt": "{\n  \"file\": \"4_27.txt\",\n  \"assertion\": \"assertEquals ( 1000, 1. 0Time time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 1. 0Time time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_28.txt": "{\n  \"file\": \"4_28.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. 0Time time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 10, 0. 0Time time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_29.txt": "{\n  \"file\": \"4_29.txt\",\n  \"assertion\": \"assertEquals ( 50, 0. 0Time time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 50, 0. 0Time time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_3.txt": "{\n  \"file\": \"4_3.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0Time time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Time time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_4.txt": "{\n  \"file\": \"4_4.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0Timeout time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Timeout time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_5.txt": "{\n  \"file\": \"4_5.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0Time time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Time time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_6.txt": "{\n  \"file\": \"4_6.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0 wait Time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0 wait Time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_7.txt": "{\n  \"file\": \"4_7.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0 Wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0 Wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_8.txt": "{\n  \"file\": \"4_8.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0 wait Time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0 wait Time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "4_9.txt": "{\n  \"file\": \"4_9.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0 Wait time ( ) )\\r\\n\",\n  \"test\": \"class X {public void testEmptyInitialization ( ) { WaitTimer timer \\u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \\u003d 0 ; i \\u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0 Wait time ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, timer. getWaitTime ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_0.txt": "{\n  \"file\": \"50_0.txt\",\n  \"assertion\": \"assertEquals ( profile. user id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. user id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_1.txt": "{\n  \"file\": \"50_1.txt\",\n  \"assertion\": \"assertEquals ( profile. client id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. client id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_10.txt": "{\n  \"file\": \"50_10.txt\",\n  \"assertion\": \"assertEquals ( profile. userUser ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userUser ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_11.txt": "{\n  \"file\": \"50_11.txt\",\n  \"assertion\": \"assertEquals ( profile. token ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. token ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_12.txt": "{\n  \"file\": \"50_12.txt\",\n  \"assertion\": \"assertEquals ( profile. get id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. get id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_13.txt": "{\n  \"file\": \"50_13.txt\",\n  \"assertion\": \"assertEquals ( profile. session ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. session ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_14.txt": "{\n  \"file\": \"50_14.txt\",\n  \"assertion\": \"assertEquals ( profile. authent id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. authent id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_15.txt": "{\n  \"file\": \"50_15.txt\",\n  \"assertion\": \"assertEquals ( profile. authentication ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. authentication ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_16.txt": "{\n  \"file\": \"50_16.txt\",\n  \"assertion\": \"assertEquals ( profile. auth ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. auth ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_17.txt": "{\n  \"file\": \"50_17.txt\",\n  \"assertion\": \"assertEquals ( profile. userMe ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userMe ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_18.txt": "{\n  \"file\": \"50_18.txt\",\n  \"assertion\": \"assertEquals ( profile. userId ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userId ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_19.txt": "{\n  \"file\": \"50_19.txt\",\n  \"assertion\": \"assertEquals ( profile. login ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. login ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_2.txt": "{\n  \"file\": \"50_2.txt\",\n  \"assertion\": \"assertEquals ( profile. token id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. token id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_20.txt": "{\n  \"file\": \"50_20.txt\",\n  \"assertion\": \"assertEquals ( profile. userLogin ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userLogin ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_21.txt": "{\n  \"file\": \"50_21.txt\",\n  \"assertion\": \"assertEquals ( profile. access id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. access id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_22.txt": "{\n  \"file\": \"50_22.txt\",\n  \"assertion\": \"assertEquals ( profile. u id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. u id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_23.txt": "{\n  \"file\": \"50_23.txt\",\n  \"assertion\": \"assertEquals ( profile. userToken ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userToken ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_24.txt": "{\n  \"file\": \"50_24.txt\",\n  \"assertion\": \"assertEquals ( profile. to id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. to id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_25.txt": "{\n  \"file\": \"50_25.txt\",\n  \"assertion\": \"assertEquals ( profile. clientid ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. clientid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_26.txt": "{\n  \"file\": \"50_26.txt\",\n  \"assertion\": \"assertEquals ( profile. userID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_27.txt": "{\n  \"file\": \"50_27.txt\",\n  \"assertion\": \"assertEquals ( profile. is id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. is id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_28.txt": "{\n  \"file\": \"50_28.txt\",\n  \"assertion\": \"assertEquals ( profile. user Id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. user Id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_29.txt": "{\n  \"file\": \"50_29.txt\",\n  \"assertion\": \"assertEquals ( profile. clientUser ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. clientUser ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_3.txt": "{\n  \"file\": \"50_3.txt\",\n  \"assertion\": \"assertEquals ( profile. user ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. user ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_4.txt": "{\n  \"file\": \"50_4.txt\",\n  \"assertion\": \"assertEquals ( profile. session id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. session id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_5.txt": "{\n  \"file\": \"50_5.txt\",\n  \"assertion\": \"assertEquals ( profile. authentication id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. authentication id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_6.txt": "{\n  \"file\": \"50_6.txt\",\n  \"assertion\": \"assertEquals ( profile. auth id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. auth id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_7.txt": "{\n  \"file\": \"50_7.txt\",\n  \"assertion\": \"assertEquals ( profile. login id ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. login id ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_8.txt": "{\n  \"file\": \"50_8.txt\",\n  \"assertion\": \"assertEquals ( profile. userid ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "50_9.txt": "{\n  \"file\": \"50_9.txt\",\n  \"assertion\": \"assertEquals ( profile. client ID ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \\u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \\u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \\u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \\u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. client ID ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getId() { return id ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( profile. getId ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "51_0.txt": "{\n  \"file\": \"51_0.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. template ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. template ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"template\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_1.txt": "{\n  \"file\": \"51_1.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. weather ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. weather ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"weather\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_10.txt": "{\n  \"file\": \"51_10.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. shelter ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. shelter ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"shelter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_11.txt": "{\n  \"file\": \"51_11.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. report ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. report ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"report\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_12.txt": "{\n  \"file\": \"51_12.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. write ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. write ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"write\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_13.txt": "{\n  \"file\": \"51_13.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. render ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. render ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"render\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"render\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "51_14.txt": "{\n  \"file\": \"51_14.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. prepare ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. prepare ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"prepare\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_15.txt": "{\n  \"file\": \"51_15.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. rend ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. rend ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"rend\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_16.txt": "{\n  \"file\": \"51_16.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. dress ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. dress ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"dress\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_17.txt": "{\n  \"file\": \"51_17.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. tag ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. tag ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"tag\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_18.txt": "{\n  \"file\": \"51_18.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. apply ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. apply ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"apply\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_19.txt": "{\n  \"file\": \"51_19.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. paint ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. paint ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"paint\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_2.txt": "{\n  \"file\": \"51_2.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. html ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. html ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"html\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_20.txt": "{\n  \"file\": \"51_20.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. rear ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. rear ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"rear\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_21.txt": "{\n  \"file\": \"51_21.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. print ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. print ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"print\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_22.txt": "{\n  \"file\": \"51_22.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. rendered ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. rendered ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"rendered\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_23.txt": "{\n  \"file\": \"51_23.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. display ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. display ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"display\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_24.txt": "{\n  \"file\": \"51_24.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. styl ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. styl ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"styl\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_25.txt": "{\n  \"file\": \"51_25.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. renders ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. renders ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"renders\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_26.txt": "{\n  \"file\": \"51_26.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. gore ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. gore ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"gore\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_27.txt": "{\n  \"file\": \"51_27.txt\",\n  \"assertion\": \"assertEquals ( expect, expecting. template ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expect, expecting. template ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"template\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_28.txt": "{\n  \"file\": \"51_28.txt\",\n  \"assertion\": \"assertEquals ( expecting, expect. template ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expect. template ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"template\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_29.txt": "{\n  \"file\": \"51_29.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting.render ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting.render ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"render\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"render\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "51_3.txt": "{\n  \"file\": \"51_3.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. get ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. get ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"get\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_4.txt": "{\n  \"file\": \"51_4.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. gender ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. gender ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"gender\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_5.txt": "{\n  \"file\": \"51_5.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. replace ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. replace ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"replace\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_6.txt": "{\n  \"file\": \"51_6.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. rendering ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. rendering ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"rendering\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_7.txt": "{\n  \"file\": \"51_7.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. treatment ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. treatment ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"treatment\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_8.txt": "{\n  \"file\": \"51_8.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. repr ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. repr ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"repr\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "51_9.txt": "{\n  \"file\": \"51_9.txt\",\n  \"assertion\": \"assertEquals ( expecting, expecting. group ( ) )\\r\\n\",\n  \"test\": \"class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \\u003d new ST ( \\\"\\u003clast(names)\\u003e\\\" ) ; e . add ( \\\"names\\\" , new ArrayList \\u003c String \\u003e ( ) { { add ( \\\"Ter\\\" ) ; } } ) ; String expecting \\u003d \\\"Ter\\\" ; assertEquals ( expecting, expecting. group ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expecting, e. render ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"expecting\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "52_0.txt": "{\n  \"file\": \"52_0.txt\",\n  \"assertion\": \"assertFalse ( valid assidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid assidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_1.txt": "{\n  \"file\": \"52_1.txt\",\n  \"assertion\": \"assertFalse ( validPidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validPidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validPidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_10.txt": "{\n  \"file\": \"52_10.txt\",\n  \"assertion\": \"assertFalse ( validTest assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validTest assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_11.txt": "{\n  \"file\": \"52_11.txt\",\n  \"assertion\": \"assertFalse ( validPos assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validPos assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_12.txt": "{\n  \"file\": \"52_12.txt\",\n  \"assertion\": \"assertFalse ( valid asser )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid asser ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_13.txt": "{\n  \"file\": \"52_13.txt\",\n  \"assertion\": \"assertFalse ( validUnidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validUnidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validUnidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_14.txt": "{\n  \"file\": \"52_14.txt\",\n  \"assertion\": \"assertFalse ( validAll assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validAll assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_15.txt": "{\n  \"file\": \"52_15.txt\",\n  \"assertion\": \"assertFalse ( validIs assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validIs assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_16.txt": "{\n  \"file\": \"52_16.txt\",\n  \"assertion\": \"assertFalse ( valid Ass assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid Ass assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_17.txt": "{\n  \"file\": \"52_17.txt\",\n  \"assertion\": \"assertFalse ( validAlidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validAlidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validAlidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_18.txt": "{\n  \"file\": \"52_18.txt\",\n  \"assertion\": \"assertFalse ( validass assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validass assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_19.txt": "{\n  \"file\": \"52_19.txt\",\n  \"assertion\": \"assertFalse ( validUsidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validUsidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validUsidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_2.txt": "{\n  \"file\": \"52_2.txt\",\n  \"assertion\": \"assertFalse ( validTestidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validTestidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validTestidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_20.txt": "{\n  \"file\": \"52_20.txt\",\n  \"assertion\": \"assertFalse ( validPer )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validPer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validPer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_21.txt": "{\n  \"file\": \"52_21.txt\",\n  \"assertion\": \"assertFalse ( validTester )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validTester ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validTester\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_22.txt": "{\n  \"file\": \"52_22.txt\",\n  \"assertion\": \"assertFalse ( validAssidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validAssidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validAssidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_23.txt": "{\n  \"file\": \"52_23.txt\",\n  \"assertion\": \"assertFalse ( validClassidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validClassidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validClassidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_24.txt": "{\n  \"file\": \"52_24.txt\",\n  \"assertion\": \"assertFalse ( validGuidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validGuidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validGuidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_25.txt": "{\n  \"file\": \"52_25.txt\",\n  \"assertion\": \"assertFalse ( validAsidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validAsidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validAsidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_26.txt": "{\n  \"file\": \"52_26.txt\",\n  \"assertion\": \"assertFalse ( valid assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_27.txt": "{\n  \"file\": \"52_27.txt\",\n  \"assertion\": \"assertFalse ( validPoser )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validPoser ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validPoser\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_28.txt": "{\n  \"file\": \"52_28.txt\",\n  \"assertion\": \"assertFalse ( validDefidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validDefidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validDefidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_29.txt": "{\n  \"file\": \"52_29.txt\",\n  \"assertion\": \"assertFalse ( valid assign )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid assign ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_3.txt": "{\n  \"file\": \"52_3.txt\",\n  \"assertion\": \"assertFalse ( valid ass assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid ass assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_4.txt": "{\n  \"file\": \"52_4.txt\",\n  \"assertion\": \"assertFalse ( validPosidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validPosidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validPosidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_5.txt": "{\n  \"file\": \"52_5.txt\",\n  \"assertion\": \"assertFalse ( validAllidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validAllidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validAllidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_6.txt": "{\n  \"file\": \"52_6.txt\",\n  \"assertion\": \"assertFalse ( validIsidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validIsidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validIsidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_7.txt": "{\n  \"file\": \"52_7.txt\",\n  \"assertion\": \"assertFalse ( valid Assidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( valid Assidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "52_8.txt": "{\n  \"file\": \"52_8.txt\",\n  \"assertion\": \"assertFalse ( validassidate )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validassidate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validassidate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "52_9.txt": "{\n  \"file\": \"52_9.txt\",\n  \"assertion\": \"assertFalse ( validP assert )\\r\\n\",\n  \"test\": \"class X {public void testCreateCRLException ( ) { String crlfile \\u003d ( strFilePath ) + \\\"/ssl/server.p12\\\" ; boolean validAssert \\u003d true ; try { new MockUp \\u003c CertificateFactory \\u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \\u003d false ; } assertFalse ( validP assert ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void createCRL( String  var24678 ) { InputStream is \\u003d null ; try { CertificateFactory cf \\u003d CertificateFactory . getInstance ( \\\"X.509\\\" ) ; is \\u003d new FileInputStream ( crlfile ) ; Collection c \\u003d cf . generateCRLs ( is ) ; CRL [ ] crls \\u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecert\\u003csp\\u003efile.\\\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \\\"crl\\u003csp\\u003efile\\u003csp\\u003enot\\u003csp\\u003efound.\\\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \\\"bad\\u003csp\\u003ecrl\\u003csp\\u003efile.\\\" ) ; } finally { if ( is !\\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\\r\\n\",\n  \"truth\": \"assertFalse ( validAssert )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_0.txt": "{\n  \"file\": \"53_0.txt\",\n  \"assertion\": \"assertNull ( ec. e value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. e value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_1.txt": "{\n  \"file\": \"53_1.txt\",\n  \"assertion\": \"assertNull ( ec. pop value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. pop value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_10.txt": "{\n  \"file\": \"53_10.txt\",\n  \"assertion\": \"assertNull ( ec. to value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. to value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_11.txt": "{\n  \"file\": \"53_11.txt\",\n  \"assertion\": \"assertNull ( ec. s value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. s value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_12.txt": "{\n  \"file\": \"53_12.txt\",\n  \"assertion\": \"assertNull ( ec. int value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. int value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_13.txt": "{\n  \"file\": \"53_13.txt\",\n  \"assertion\": \"assertNull ( ec. current value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. current value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_14.txt": "{\n  \"file\": \"53_14.txt\",\n  \"assertion\": \"assertNull ( ec. _ value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. _ value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_15.txt": "{\n  \"file\": \"53_15.txt\",\n  \"assertion\": \"assertNull ( ec. read value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. read value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_16.txt": "{\n  \"file\": \"53_16.txt\",\n  \"assertion\": \"assertNull ( ec. eDefault ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eDefault ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eDefault\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_17.txt": "{\n  \"file\": \"53_17.txt\",\n  \"assertion\": \"assertNull ( ec. got value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. got value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_18.txt": "{\n  \"file\": \"53_18.txt\",\n  \"assertion\": \"assertNull ( ec. $ value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. $ value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_19.txt": "{\n  \"file\": \"53_19.txt\",\n  \"assertion\": \"assertNull ( ec. l value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. l value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_2.txt": "{\n  \"file\": \"53_2.txt\",\n  \"assertion\": \"assertNull ( ec. is value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. is value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_20.txt": "{\n  \"file\": \"53_20.txt\",\n  \"assertion\": \"assertNull ( ec. eKey ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eKey ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eKey\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_21.txt": "{\n  \"file\": \"53_21.txt\",\n  \"assertion\": \"assertNull ( ec. eException ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eException ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eException\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_22.txt": "{\n  \"file\": \"53_22.txt\",\n  \"assertion\": \"assertNull ( ec. return value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. return value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_23.txt": "{\n  \"file\": \"53_23.txt\",\n  \"assertion\": \"assertNull ( ec. eNull ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eNull ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eNull\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_24.txt": "{\n  \"file\": \"53_24.txt\",\n  \"assertion\": \"assertNull ( ec. un value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. un value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_25.txt": "{\n  \"file\": \"53_25.txt\",\n  \"assertion\": \"assertNull ( ec. float value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. float value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_26.txt": "{\n  \"file\": \"53_26.txt\",\n  \"assertion\": \"assertNull ( ec. m value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. m value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_27.txt": "{\n  \"file\": \"53_27.txt\",\n  \"assertion\": \"assertNull ( ec. eType ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eType ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eType\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_28.txt": "{\n  \"file\": \"53_28.txt\",\n  \"assertion\": \"assertNull ( ec. popDefault ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. popDefault ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"popDefault\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_29.txt": "{\n  \"file\": \"53_29.txt\",\n  \"assertion\": \"assertNull ( ec. evalue ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. evalue ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evalue\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "53_3.txt": "{\n  \"file\": \"53_3.txt\",\n  \"assertion\": \"assertNull ( ec. g value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. g value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_4.txt": "{\n  \"file\": \"53_4.txt\",\n  \"assertion\": \"assertNull ( ec. get value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. get value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_5.txt": "{\n  \"file\": \"53_5.txt\",\n  \"assertion\": \"assertNull ( ec. n value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. n value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_6.txt": "{\n  \"file\": \"53_6.txt\",\n  \"assertion\": \"assertNull ( ec. p value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. p value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_7.txt": "{\n  \"file\": \"53_7.txt\",\n  \"assertion\": \"assertNull ( ec. as value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. as value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_8.txt": "{\n  \"file\": \"53_8.txt\",\n  \"assertion\": \"assertNull ( ec. the value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. the value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "53_9.txt": "{\n  \"file\": \"53_9.txt\",\n  \"assertion\": \"assertNull ( ec. set value ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \\u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. set value ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getValue() { return value ; } }\\r\\n\",\n  \"truth\": \"assertNull ( ec. getValue ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_0.txt": "{\n  \"file\": \"54_0.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_1.txt": "{\n  \"file\": \"54_1.txt\",\n  \"assertion\": \"assertEquals ( 2, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 2, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_10.txt": "{\n  \"file\": \"54_10.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 1000 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 1000 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_11.txt": "{\n  \"file\": \"54_11.txt\",\n  \"assertion\": \"assertEquals ( 3, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 3, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_12.txt": "{\n  \"file\": \"54_12.txt\",\n  \"assertion\": \"assertEquals ( 1, 3 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 3 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_13.txt": "{\n  \"file\": \"54_13.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 3 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_14.txt": "{\n  \"file\": \"54_14.txt\",\n  \"assertion\": \"assertEquals ( 4, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 4, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_15.txt": "{\n  \"file\": \"54_15.txt\",\n  \"assertion\": \"assertEquals ( 1, 4 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 4 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_16.txt": "{\n  \"file\": \"54_16.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 4 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_17.txt": "{\n  \"file\": \"54_17.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 4 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 4 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_18.txt": "{\n  \"file\": \"54_18.txt\",\n  \"assertion\": \"assertEquals ( 5, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 5, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_19.txt": "{\n  \"file\": \"54_19.txt\",\n  \"assertion\": \"assertEquals ( 1, 5 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 5 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_2.txt": "{\n  \"file\": \"54_2.txt\",\n  \"assertion\": \"assertEquals ( 1, 2 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 2 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_20.txt": "{\n  \"file\": \"54_20.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 5 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_21.txt": "{\n  \"file\": \"54_21.txt\",\n  \"assertion\": \"assertEquals ( 10000, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 10000, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_22.txt": "{\n  \"file\": \"54_22.txt\",\n  \"assertion\": \"assertEquals ( 1, 10000 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 10000 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_23.txt": "{\n  \"file\": \"54_23.txt\",\n  \"assertion\": \"assertEquals ( 200, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 200, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_24.txt": "{\n  \"file\": \"54_24.txt\",\n  \"assertion\": \"assertEquals ( 1, 200 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 200 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_25.txt": "{\n  \"file\": \"54_25.txt\",\n  \"assertion\": \"assertEquals ( log, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( log, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_26.txt": "{\n  \"file\": \"54_26.txt\",\n  \"assertion\": \"assertEquals ( 1, log 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, log 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_27.txt": "{\n  \"file\": \"54_27.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 log 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 log 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_28.txt": "{\n  \"file\": \"54_28.txt\",\n  \"assertion\": \"assertEquals ( 9, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 9, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_29.txt": "{\n  \"file\": \"54_29.txt\",\n  \"assertion\": \"assertEquals ( 1, 9 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 9 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_3.txt": "{\n  \"file\": \"54_3.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 2 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 2 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_4.txt": "{\n  \"file\": \"54_4.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 2 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_5.txt": "{\n  \"file\": \"54_5.txt\",\n  \"assertion\": \"assertEquals ( 10, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 10, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_6.txt": "{\n  \"file\": \"54_6.txt\",\n  \"assertion\": \"assertEquals ( 1, 10 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 10 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_7.txt": "{\n  \"file\": \"54_7.txt\",\n  \"assertion\": \"assertEquals ( 1, 1 1 1 10 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_8.txt": "{\n  \"file\": \"54_8.txt\",\n  \"assertion\": \"assertEquals ( 1000, 1 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1000, 1 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "54_9.txt": "{\n  \"file\": \"54_9.txt\",\n  \"assertion\": \"assertEquals ( 1, 1000 1 1 1 )\\r\\n\",\n  \"test\": \"class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \\u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \\u003d \\\"/\\\" ; dataGeneratorFormatConfig . charset \\u003d \\\"UTF-8\\\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \\u003d true ; FlumeTarget flumeTarget \\u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \\u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \\u003c Record \\u003e logRecords \\u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \\u003d 0 ; Transaction transaction \\u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1000 1 1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void close() { generator . close ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, totalFlumeEvents )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_0.txt": "{\n  \"file\": \"55_0.txt\",\n  \"assertion\": \"assertEquals ( ), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_1.txt": "{\n  \"file\": \"55_1.txt\",\n  \"assertion\": \"assertEquals (), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_10.txt": "{\n  \"file\": \"55_10.txt\",\n  \"assertion\": \"assertEquals ( 2, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 2, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_11.txt": "{\n  \"file\": \"55_11.txt\",\n  \"assertion\": \"assertEquals (+), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (+), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_12.txt": "{\n  \"file\": \"55_12.txt\",\n  \"assertion\": \"assertEquals ( null, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( null, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_13.txt": "{\n  \"file\": \"55_13.txt\",\n  \"assertion\": \"assertEquals (*), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (*), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_14.txt": "{\n  \"file\": \"55_14.txt\",\n  \"assertion\": \"assertEquals ()\\\", ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()\\\", ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_15.txt": "{\n  \"file\": \"55_15.txt\",\n  \"assertion\": \"assertEquals ( 1, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 1, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_16.txt": "{\n  \"file\": \"55_16.txt\",\n  \"assertion\": \"assertEquals (,), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (,), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_17.txt": "{\n  \"file\": \"55_17.txt\",\n  \"assertion\": \"assertEquals ()?, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()?, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_18.txt": "{\n  \"file\": \"55_18.txt\",\n  \"assertion\": \"assertEquals (\\\"), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (\\\"), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_19.txt": "{\n  \"file\": \"55_19.txt\",\n  \"assertion\": \"assertEquals ()\\\\, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()\\\\, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_2.txt": "{\n  \"file\": \"55_2.txt\",\n  \"assertion\": \"assertEquals ()), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_20.txt": "{\n  \"file\": \"55_20.txt\",\n  \"assertion\": \"assertEquals (?), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (?), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_21.txt": "{\n  \"file\": \"55_21.txt\",\n  \"assertion\": \"assertEquals ( 3, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 3, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_22.txt": "{\n  \"file\": \"55_22.txt\",\n  \"assertion\": \"assertEquals ( }, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( }, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_23.txt": "{\n  \"file\": \"55_23.txt\",\n  \"assertion\": \"assertEquals (),, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (),, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_24.txt": "{\n  \"file\": \"55_24.txt\",\n  \"assertion\": \"assertEquals ( false, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( false, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_25.txt": "{\n  \"file\": \"55_25.txt\",\n  \"assertion\": \"assertEquals (,, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (,, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_26.txt": "{\n  \"file\": \"55_26.txt\",\n  \"assertion\": \"assertEquals ( 10, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 10, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_27.txt": "{\n  \"file\": \"55_27.txt\",\n  \"assertion\": \"assertEquals ( ], ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ], ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_28.txt": "{\n  \"file\": \"55_28.txt\",\n  \"assertion\": \"assertEquals ( ), list )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), list ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_29.txt": "{\n  \"file\": \"55_29.txt\",\n  \"assertion\": \"assertEquals ( list, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( list, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_3.txt": "{\n  \"file\": \"55_3.txt\",\n  \"assertion\": \"assertEquals ( 0, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 0, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_4.txt": "{\n  \"file\": \"55_4.txt\",\n  \"assertion\": \"assertEquals ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_5.txt": "{\n  \"file\": \"55_5.txt\",\n  \"assertion\": \"assertEquals ( ), expected )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_6.txt": "{\n  \"file\": \"55_6.txt\",\n  \"assertion\": \"assertEquals ( expected, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( expected, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_7.txt": "{\n  \"file\": \"55_7.txt\",\n  \"assertion\": \"assertEquals ( true, ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( true, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_8.txt": "{\n  \"file\": \"55_8.txt\",\n  \"assertion\": \"assertEquals (?), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (?), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "55_9.txt": "{\n  \"file\": \"55_9.txt\",\n  \"assertion\": \"assertEquals ( )), ) )\\r\\n\",\n  \"test\": \"class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \\u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \\u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \\u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \\u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \\u003c ConstraintDescriptor \\u003e listed \\u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \\u003c ConstraintDescriptor \\u003e expected \\u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( )), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getConstraintDescriptor() { return descriptor ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, listed )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_0.txt": "{\n  \"file\": \"56_0.txt\",\n  \"assertion\": \"assertNull ( g fun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_1.txt": "{\n  \"file\": \"56_1.txt\",\n  \"assertion\": \"assertNull ( gGun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gGun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_10.txt": "{\n  \"file\": \"56_10.txt\",\n  \"assertion\": \"assertNull ( gFac. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gFac. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_11.txt": "{\n  \"file\": \"56_11.txt\",\n  \"assertion\": \"assertNull ( gfun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gfun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_12.txt": "{\n  \"file\": \"56_12.txt\",\n  \"assertion\": \"assertNull ( gRun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gRun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_13.txt": "{\n  \"file\": \"56_13.txt\",\n  \"assertion\": \"assertNull ( g fun. gName ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gName ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_14.txt": "{\n  \"file\": \"56_14.txt\",\n  \"assertion\": \"assertNull ( gVal. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gVal. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_15.txt": "{\n  \"file\": \"56_15.txt\",\n  \"assertion\": \"assertNull ( gNum. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gNum. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_16.txt": "{\n  \"file\": \"56_16.txt\",\n  \"assertion\": \"assertNull ( g fun. gname ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gname ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_17.txt": "{\n  \"file\": \"56_17.txt\",\n  \"assertion\": \"assertNull ( gJs. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gJs. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_18.txt": "{\n  \"file\": \"56_18.txt\",\n  \"assertion\": \"assertNull ( gVar. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gVar. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_19.txt": "{\n  \"file\": \"56_19.txt\",\n  \"assertion\": \"assertNull ( g fun. gString ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gString ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_2.txt": "{\n  \"file\": \"56_2.txt\",\n  \"assertion\": \"assertNull ( gReg. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gReg. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_20.txt": "{\n  \"file\": \"56_20.txt\",\n  \"assertion\": \"assertNull ( gFunction. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gFunction. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_21.txt": "{\n  \"file\": \"56_21.txt\",\n  \"assertion\": \"assertNull ( gExec. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gExec. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_22.txt": "{\n  \"file\": \"56_22.txt\",\n  \"assertion\": \"assertNull (g fun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull (g fun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_23.txt": "{\n  \"file\": \"56_23.txt\",\n  \"assertion\": \"assertNull ( g fun. gUrl ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gUrl ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_24.txt": "{\n  \"file\": \"56_24.txt\",\n  \"assertion\": \"assertNull ( g fun. gDefault ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gDefault ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_25.txt": "{\n  \"file\": \"56_25.txt\",\n  \"assertion\": \"assertNull ( g fun. gFilter ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gFilter ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_26.txt": "{\n  \"file\": \"56_26.txt\",\n  \"assertion\": \"assertNull ( gp fun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gp fun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_27.txt": "{\n  \"file\": \"56_27.txt\",\n  \"assertion\": \"assertNull ( gMod. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gMod. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_28.txt": "{\n  \"file\": \"56_28.txt\",\n  \"assertion\": \"assertNull ( G fun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( G fun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_29.txt": "{\n  \"file\": \"56_29.txt\",\n  \"assertion\": \"assertNull ( gDone. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gDone. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_3.txt": "{\n  \"file\": \"56_3.txt\",\n  \"assertion\": \"assertNull ( gUt. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gUt. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_4.txt": "{\n  \"file\": \"56_4.txt\",\n  \"assertion\": \"assertNull ( g Fun. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g Fun. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_5.txt": "{\n  \"file\": \"56_5.txt\",\n  \"assertion\": \"assertNull ( g fun. gN ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gN ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_6.txt": "{\n  \"file\": \"56_6.txt\",\n  \"assertion\": \"assertNull ( gF. g name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( gF. g name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_7.txt": "{\n  \"file\": \"56_7.txt\",\n  \"assertion\": \"assertNull ( g fun. gId ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gId ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_8.txt": "{\n  \"file\": \"56_8.txt\",\n  \"assertion\": \"assertNull ( g fun. g Name ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. g Name ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "56_9.txt": "{\n  \"file\": \"56_9.txt\",\n  \"assertion\": \"assertNull ( g fun. gParent ( ) )\\r\\n\",\n  \"test\": \"class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \\u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \\\"\\\" ) ; assertNull ( g fun. gParent ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getName() { return name ; } }\\r\\n\",\n  \"truth\": \"assertNull ( gFun. getName ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "57_0.txt": "Unknown assertion type",
  "57_1.txt": "Unknown assertion type",
  "57_10.txt": "Unknown assertion type",
  "57_11.txt": "Unknown assertion type",
  "57_12.txt": "Unknown assertion type",
  "57_13.txt": "Unknown assertion type",
  "57_14.txt": "Unknown assertion type",
  "57_15.txt": "Unknown assertion type",
  "57_16.txt": "Unknown assertion type",
  "57_17.txt": "Unknown assertion type",
  "57_18.txt": "Unknown assertion type",
  "57_19.txt": "Unknown assertion type",
  "57_2.txt": "Unknown assertion type",
  "57_20.txt": "Unknown assertion type",
  "57_21.txt": "Unknown assertion type",
  "57_22.txt": "Unknown assertion type",
  "57_23.txt": "Unknown assertion type",
  "57_24.txt": "Unknown assertion type",
  "57_25.txt": "Unknown assertion type",
  "57_26.txt": "Unknown assertion type",
  "57_27.txt": "Unknown assertion type",
  "57_28.txt": "Unknown assertion type",
  "57_29.txt": "Unknown assertion type",
  "57_3.txt": "Unknown assertion type",
  "57_4.txt": "Unknown assertion type",
  "57_5.txt": "Unknown assertion type",
  "57_6.txt": "Unknown assertion type",
  "57_7.txt": "Unknown assertion type",
  "57_8.txt": "Unknown assertion type",
  "57_9.txt": "Unknown assertion type",
  "58_0.txt": "{\n  \"file\": \"58_0.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. add ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. add ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_1.txt": "{\n  \"file\": \"58_1.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. matches ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. matches ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_10.txt": "{\n  \"file\": \"58_10.txt\",\n  \"assertion\": \"assertEquals ( hash, 255 filter 2. add ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, 255 filter 2. add ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_11.txt": "{\n  \"file\": \"58_11.txt\",\n  \"assertion\": \"assertEquals ( hash, filter filter 2. add ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, filter filter 2. add ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_12.txt": "{\n  \"file\": \"58_12.txt\",\n  \"assertion\": \"assertEquals ( true, 255 filter 2. contains ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, 255 filter 2. contains ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_13.txt": "{\n  \"file\": \"58_13.txt\",\n  \"assertion\": \"assertEquals ( true, 255 filter 2. matches ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, 255 filter 2. matches ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_14.txt": "{\n  \"file\": \"58_14.txt\",\n  \"assertion\": \"assertEquals ( hash, 255 filter 2. matches ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, 255 filter 2. matches ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_15.txt": "{\n  \"file\": \"58_15.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. contains ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. contains ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_16.txt": "{\n  \"file\": \"58_16.txt\",\n  \"assertion\": \"assertEquals ( hash, filter filter 2. contains ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, filter filter 2. contains ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_17.txt": "{\n  \"file\": \"58_17.txt\",\n  \"assertion\": \"assertEquals ( hash, filter filter 2. matches ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, filter filter 2. matches ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_18.txt": "{\n  \"file\": \"58_18.txt\",\n  \"assertion\": \"assertEquals ( hash, 255 filter 2. add ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, 255 filter 2. add ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_19.txt": "{\n  \"file\": \"58_19.txt\",\n  \"assertion\": \"assertEquals ( true, 255 filter 2. contains ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, 255 filter 2. contains ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_2.txt": "{\n  \"file\": \"58_2.txt\",\n  \"assertion\": \"assertEquals ( true, 255 filter 2. add ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, 255 filter 2. add ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_20.txt": "{\n  \"file\": \"58_20.txt\",\n  \"assertion\": \"assertEquals ( hash, 255 filter 2. contains ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, 255 filter 2. contains ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_21.txt": "{\n  \"file\": \"58_21.txt\",\n  \"assertion\": \"assertEquals ( hash, 255 filter 2. matches ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, 255 filter 2. matches ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_22.txt": "{\n  \"file\": \"58_22.txt\",\n  \"assertion\": \"assertEquals ( hash, filter filter 2. contains ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, filter filter 2. contains ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_23.txt": "{\n  \"file\": \"58_23.txt\",\n  \"assertion\": \"assertEquals ( hash, 255 filter 2. contains ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, 255 filter 2. contains ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_24.txt": "{\n  \"file\": \"58_24.txt\",\n  \"assertion\": \"assertEquals ( 1, filter filter 2. add ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( 1, filter filter 2. add ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_25.txt": "{\n  \"file\": \"58_25.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. add ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. add ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_26.txt": "{\n  \"file\": \"58_26.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. exists ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. exists ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_27.txt": "{\n  \"file\": \"58_27.txt\",\n  \"assertion\": \"assertEquals ( false, filter filter 2. add ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( false, filter filter 2. add ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_28.txt": "{\n  \"file\": \"58_28.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. matches ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. matches ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_29.txt": "{\n  \"file\": \"58_29.txt\",\n  \"assertion\": \"assertEquals ( 1, filter filter 2. matches ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( 1, filter filter 2. matches ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_3.txt": "{\n  \"file\": \"58_3.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. add ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. add ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_4.txt": "{\n  \"file\": \"58_4.txt\",\n  \"assertion\": \"assertEquals ( hash, filter filter 2. add ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, filter filter 2. add ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_5.txt": "{\n  \"file\": \"58_5.txt\",\n  \"assertion\": \"assertEquals ( true, 255 filter 2. matches ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, 255 filter 2. matches ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_6.txt": "{\n  \"file\": \"58_6.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. contains ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. contains ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_7.txt": "{\n  \"file\": \"58_7.txt\",\n  \"assertion\": \"assertEquals ( true, filter filter 2. matches ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, filter filter 2. matches ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_8.txt": "{\n  \"file\": \"58_8.txt\",\n  \"assertion\": \"assertEquals ( hash, filter filter 2. matches ( true ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( hash, filter filter 2. matches ( true ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "58_9.txt": "{\n  \"file\": \"58_9.txt\",\n  \"assertion\": \"assertEquals ( true, 255 filter 2. add ( hash ) )\\r\\n\",\n  \"test\": \"class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( 1024 , 1000 ) ; Number160 hash \\u003d new Number160 ( \\\"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\\\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \\u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \\u003c Number160 \\u003e bloomFilter2 \\u003d new SimpleBloomFilter \\u003c Number160 \\u003e ( buf ) ; assertEquals ( true, 255 filter 2. add ( hash ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( true, bloomFilter2. contains ( hash ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "59_0.txt": "Unknown assertion type",
  "59_1.txt": "Unknown assertion type",
  "59_10.txt": "Unknown assertion type",
  "59_11.txt": "Unknown assertion type",
  "59_12.txt": "Unknown assertion type",
  "59_13.txt": "Unknown assertion type",
  "59_14.txt": "Unknown assertion type",
  "59_15.txt": "Unknown assertion type",
  "59_16.txt": "Unknown assertion type",
  "59_17.txt": "Unknown assertion type",
  "59_18.txt": "Unknown assertion type",
  "59_19.txt": "Unknown assertion type",
  "59_2.txt": "Unknown assertion type",
  "59_20.txt": "Unknown assertion type",
  "59_21.txt": "Unknown assertion type",
  "59_22.txt": "Unknown assertion type",
  "59_23.txt": "Unknown assertion type",
  "59_24.txt": "Unknown assertion type",
  "59_25.txt": "Unknown assertion type",
  "59_26.txt": "Unknown assertion type",
  "59_27.txt": "Unknown assertion type",
  "59_28.txt": "Unknown assertion type",
  "59_29.txt": "Unknown assertion type",
  "59_3.txt": "Unknown assertion type",
  "59_4.txt": "Unknown assertion type",
  "59_5.txt": "Unknown assertion type",
  "59_6.txt": "Unknown assertion type",
  "59_7.txt": "Unknown assertion type",
  "59_8.txt": "Unknown assertion type",
  "59_9.txt": "Unknown assertion type",
  "5_0.txt": "{\n  \"file\": \"5_0.txt\",\n  \"assertion\": \"assertEquals ( date, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_1.txt": "{\n  \"file\": \"5_1.txt\",\n  \"assertion\": \"assertEquals ( avg, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( avg, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "5_10.txt": "{\n  \"file\": \"5_10.txt\",\n  \"assertion\": \"assertEquals ( today, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( today, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"today\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_11.txt": "{\n  \"file\": \"5_11.txt\",\n  \"assertion\": \"assertEquals ( date, today )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, today ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"today\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_12.txt": "{\n  \"file\": \"5_12.txt\",\n  \"assertion\": \"assertEquals ( age, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( age, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"age\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_13.txt": "{\n  \"file\": \"5_13.txt\",\n  \"assertion\": \"assertEquals ( date, age )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, age ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"age\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_14.txt": "{\n  \"file\": \"5_14.txt\",\n  \"assertion\": \"assertEquals ( average, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( average, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"average\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_15.txt": "{\n  \"file\": \"5_15.txt\",\n  \"assertion\": \"assertEquals ( date, average )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, average ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"average\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_16.txt": "{\n  \"file\": \"5_16.txt\",\n  \"assertion\": \"assertEquals ( max, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( max, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"max\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_17.txt": "{\n  \"file\": \"5_17.txt\",\n  \"assertion\": \"assertEquals ( date, max )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, max ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"max\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_18.txt": "{\n  \"file\": \"5_18.txt\",\n  \"assertion\": \"assertEquals ( 7, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( 7, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"7\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_19.txt": "{\n  \"file\": \"5_19.txt\",\n  \"assertion\": \"assertEquals ( date, 7 )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, 7 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"7\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_2.txt": "{\n  \"file\": \"5_2.txt\",\n  \"assertion\": \"assertEquals ( date, avg )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, avg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"avg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "5_20.txt": "{\n  \"file\": \"5_20.txt\",\n  \"assertion\": \"assertEquals ( birthday, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( birthday, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"birthday\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_21.txt": "{\n  \"file\": \"5_21.txt\",\n  \"assertion\": \"assertEquals ( date, birthday )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, birthday ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"birthday\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_22.txt": "{\n  \"file\": \"5_22.txt\",\n  \"assertion\": \"assertEquals ( 42, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( 42, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"42\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_23.txt": "{\n  \"file\": \"5_23.txt\",\n  \"assertion\": \"assertEquals ( date, 42 )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, 42 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"42\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_24.txt": "{\n  \"file\": \"5_24.txt\",\n  \"assertion\": \"assertEquals ( min, avg )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( min, avg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"avg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"min\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_25.txt": "{\n  \"file\": \"5_25.txt\",\n  \"assertion\": \"assertEquals ( avg, min )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( avg, min ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"avg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"min\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_26.txt": "{\n  \"file\": \"5_26.txt\",\n  \"assertion\": \"assertEquals ( dat, avg )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( dat, avg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"avg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dat\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_27.txt": "{\n  \"file\": \"5_27.txt\",\n  \"assertion\": \"assertEquals ( avg, dat )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( avg, dat ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"avg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"dat\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_28.txt": "{\n  \"file\": \"5_28.txt\",\n  \"assertion\": \"assertEquals ( 10, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( 10, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_29.txt": "{\n  \"file\": \"5_29.txt\",\n  \"assertion\": \"assertEquals ( date, 10 )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_3.txt": "{\n  \"file\": \"5_3.txt\",\n  \"assertion\": \"assertEquals ( avg, avg )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( avg, avg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"avg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_4.txt": "{\n  \"file\": \"5_4.txt\",\n  \"assertion\": \"assertEquals ( min, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( min, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"min\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_5.txt": "{\n  \"file\": \"5_5.txt\",\n  \"assertion\": \"assertEquals ( date, min )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, min ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"min\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_6.txt": "{\n  \"file\": \"5_6.txt\",\n  \"assertion\": \"assertEquals ( dat, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( dat, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"dat\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_7.txt": "{\n  \"file\": \"5_7.txt\",\n  \"assertion\": \"assertEquals ( date, dat )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, dat ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"dat\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_8.txt": "{\n  \"file\": \"5_8.txt\",\n  \"assertion\": \"assertEquals ( now, date )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( now, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"now\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "5_9.txt": "{\n  \"file\": \"5_9.txt\",\n  \"assertion\": \"assertEquals ( date, now )\\r\\n\",\n  \"test\": \"class X {public void testAvg ( ) { BaseProperty \\u003c Date \\u003e avgProp \\u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \\u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \\u003d dateFormat . parse ( \\\"1/3/17\\\" ) ; assertEquals ( date, now ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \\u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e\\u0027%s\\u0027\\u003csp\\u003e:\\u003csp\\u003e%s\\\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \\u003d\\u003d null ) { throw new CayenneRuntimeException ( \\\"Error\\u003csp\\u003eparsing\\u003csp\\u003etemplate\\u003csp\\u003e%s\\\" , template ) ; } return nodeTree ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( date, avg )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"date\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Date\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"now\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "60_0.txt": "{\n  \"file\": \"60_0.txt\",\n  \"assertion\": \"assertFalse ( bid first. compare ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_1.txt": "{\n  \"file\": \"60_1.txt\",\n  \"assertion\": \"assertFalse ( bid 1. compare ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_10.txt": "{\n  \"file\": \"60_10.txt\",\n  \"assertion\": \"assertFalse ( bidId. is ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bidId. is ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_11.txt": "{\n  \"file\": \"60_11.txt\",\n  \"assertion\": \"assertFalse ( bid 1. compare ( bid 2 ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bid 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_12.txt": "{\n  \"file\": \"60_12.txt\",\n  \"assertion\": \"assertFalse ( bid first. is ( bid 2 ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bid 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_13.txt": "{\n  \"file\": \"60_13.txt\",\n  \"assertion\": \"assertFalse ( bid first. compare ( bidB ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bidB ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_14.txt": "{\n  \"file\": \"60_14.txt\",\n  \"assertion\": \"assertFalse ( bid 1. compare ( bid second ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bid second ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_15.txt": "{\n  \"file\": \"60_15.txt\",\n  \"assertion\": \"assertFalse ( bid first. is ( bid second ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bid second ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_16.txt": "{\n  \"file\": \"60_16.txt\",\n  \"assertion\": \"assertFalse ( bid2. compare ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid2. compare ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_17.txt": "{\n  \"file\": \"60_17.txt\",\n  \"assertion\": \"assertFalse ( bid 1. equal ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. equal ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_18.txt": "{\n  \"file\": \"60_18.txt\",\n  \"assertion\": \"assertFalse ( bid first. eq ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. eq ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_19.txt": "{\n  \"file\": \"60_19.txt\",\n  \"assertion\": \"assertFalse ( bid 1. is ( bid 2 ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. is ( bid 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_2.txt": "{\n  \"file\": \"60_2.txt\",\n  \"assertion\": \"assertFalse ( bid first. is ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_20.txt": "{\n  \"file\": \"60_20.txt\",\n  \"assertion\": \"assertFalse ( bidId. \\u003d\\u003d ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bidId. \\u003d\\u003d ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_21.txt": "{\n  \"file\": \"60_21.txt\",\n  \"assertion\": \"assertFalse ( bid first. compare ( bidb ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bidb ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_22.txt": "{\n  \"file\": \"60_22.txt\",\n  \"assertion\": \"assertFalse ( bid first. \\u003d\\u003d ( bid 2 ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. \\u003d\\u003d ( bid 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_23.txt": "{\n  \"file\": \"60_23.txt\",\n  \"assertion\": \"assertFalse ( bid 1. compare ( bidB ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bidB ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_24.txt": "{\n  \"file\": \"60_24.txt\",\n  \"assertion\": \"assertFalse ( bid first. is ( bidB ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bidB ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_25.txt": "{\n  \"file\": \"60_25.txt\",\n  \"assertion\": \"assertFalse ( bid 1. is ( bid second ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. is ( bid second ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_26.txt": "{\n  \"file\": \"60_26.txt\",\n  \"assertion\": \"assertFalse ( bidId. compare ( bid 2 ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bidId. compare ( bid 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_27.txt": "{\n  \"file\": \"60_27.txt\",\n  \"assertion\": \"assertFalse ( bid first. \\u003d\\u003d ( bid second ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. \\u003d\\u003d ( bid second ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_28.txt": "{\n  \"file\": \"60_28.txt\",\n  \"assertion\": \"assertFalse ( bid first. equ ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. equ ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_29.txt": "{\n  \"file\": \"60_29.txt\",\n  \"assertion\": \"assertFalse ( bid2. is ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid2. is ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_3.txt": "{\n  \"file\": \"60_3.txt\",\n  \"assertion\": \"assertFalse ( bid 1. is ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. is ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_4.txt": "{\n  \"file\": \"60_4.txt\",\n  \"assertion\": \"assertFalse ( bid first. \\u003d\\u003d ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. \\u003d\\u003d ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_5.txt": "{\n  \"file\": \"60_5.txt\",\n  \"assertion\": \"assertFalse ( bidId. compare ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bidId. compare ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_6.txt": "{\n  \"file\": \"60_6.txt\",\n  \"assertion\": \"assertFalse ( bid first. compare ( bid 2 ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bid 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_7.txt": "{\n  \"file\": \"60_7.txt\",\n  \"assertion\": \"assertFalse ( bid first. compare ( bid second ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bid second ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_8.txt": "{\n  \"file\": \"60_8.txt\",\n  \"assertion\": \"assertFalse ( bid 1. \\u003d\\u003d ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid 1. \\u003d\\u003d ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "60_9.txt": "{\n  \"file\": \"60_9.txt\",\n  \"assertion\": \"assertFalse ( bid first. equal ( bid ( ) )\\r\\n\",\n  \"test\": \"class X {public void CreateBNode ( ) { BID bid1 \\u003d dialect . createBNode ( ) ; BID bid2 \\u003d dialect . createBNode ( ) ; assertFalse ( bid first. equal ( bid ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void equals( Object  var24678 ) { if ( o \\u003d\\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \\u003d\\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\\r\\n\",\n  \"truth\": \"assertFalse ( bid1. equals ( bid2 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_0.txt": "{\n  \"file\": \"61_0.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_1.txt": "{\n  \"file\": \"61_1.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_10.txt": "{\n  \"file\": \"61_10.txt\",\n  \"assertion\": \"assertEquals ( null, null. 1 fileEmpty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileEmpty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_11.txt": "{\n  \"file\": \"61_11.txt\",\n  \"assertion\": \"assertEquals ( null, null. 1 fileSet ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileSet ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_12.txt": "{\n  \"file\": \"61_12.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 files ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 files ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_13.txt": "{\n  \"file\": \"61_13.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 file count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 file count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_14.txt": "{\n  \"file\": \"61_14.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 files ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 files ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_15.txt": "{\n  \"file\": \"61_15.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 file count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 file count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_16.txt": "{\n  \"file\": \"61_16.txt\",\n  \"assertion\": \"assertEquals ( null, null. 1 files ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 files ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_17.txt": "{\n  \"file\": \"61_17.txt\",\n  \"assertion\": \"assertEquals ( null, null. 1 file count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 file count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_18.txt": "{\n  \"file\": \"61_18.txt\",\n  \"assertion\": \"assertEquals ( 0, null. 0 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 0, null. 0 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_19.txt": "{\n  \"file\": \"61_19.txt\",\n  \"assertion\": \"assertEquals ( null, 0. 0 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 0. 0 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_2.txt": "{\n  \"file\": \"61_2.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 fileRule ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileRule ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_20.txt": "{\n  \"file\": \"61_20.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 FileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 FileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_21.txt": "{\n  \"file\": \"61_21.txt\",\n  \"assertion\": \"assertEquals ( 2, null. 0 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 2, null. 0 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_22.txt": "{\n  \"file\": \"61_22.txt\",\n  \"assertion\": \"assertEquals ( 0, null. 2 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 0, null. 2 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_23.txt": "{\n  \"file\": \"61_23.txt\",\n  \"assertion\": \"assertEquals ( null, 0. 2 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 0. 2 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_24.txt": "{\n  \"file\": \"61_24.txt\",\n  \"assertion\": \"assertEquals ( 0, null. 0 fileRule ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 0, null. 0 fileRule ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_25.txt": "{\n  \"file\": \"61_25.txt\",\n  \"assertion\": \"assertEquals ( null, 0. 0 fileRule ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 0. 0 fileRule ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_26.txt": "{\n  \"file\": \"61_26.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 FileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 FileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_27.txt": "{\n  \"file\": \"61_27.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 FileRule ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 FileRule ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_28.txt": "{\n  \"file\": \"61_28.txt\",\n  \"assertion\": \"assertEquals ( 1, null. 0 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 1, null. 0 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_29.txt": "{\n  \"file\": \"61_29.txt\",\n  \"assertion\": \"assertEquals ( null, 1. 0 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 1. 0 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_3.txt": "{\n  \"file\": \"61_3.txt\",\n  \"assertion\": \"assertEquals ( null, null. 1 fileRules ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileRules ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_4.txt": "{\n  \"file\": \"61_4.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 fileRule ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileRule ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_5.txt": "{\n  \"file\": \"61_5.txt\",\n  \"assertion\": \"assertEquals ( null, null. 1 fileRule ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileRule ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_6.txt": "{\n  \"file\": \"61_6.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 fileEmpty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileEmpty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_7.txt": "{\n  \"file\": \"61_7.txt\",\n  \"assertion\": \"assertEquals ( null, null. 0 fileSet ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileSet ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_8.txt": "{\n  \"file\": \"61_8.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 fileEmpty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileEmpty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "61_9.txt": "{\n  \"file\": \"61_9.txt\",\n  \"assertion\": \"assertEquals ( null, null. 2 fileSet ( ) )\\r\\n\",\n  \"test\": \"class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \\\"/src/Test.js\\\" , \\\"function(arg)\\u003csp\\u003e{\\u003csp\\u003enotDeclaredVariable\\u003csp\\u003e\\u003d\\u003csp\\u003e1;\\u003csp\\u003e}\\\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \\u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \\u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \\u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \\\"EmptyCatchBlock\\\" , \\\"java\\\" ) ; projectRuleSet \\u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \\u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \\u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileSet ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFileCount() { return fileCount ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, cmd. getFileCount ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "62_0.txt": "Unknown assertion type",
  "62_1.txt": "Unknown assertion type",
  "62_10.txt": "Unknown assertion type",
  "62_11.txt": "Unknown assertion type",
  "62_12.txt": "Unknown assertion type",
  "62_13.txt": "Unknown assertion type",
  "62_14.txt": "Unknown assertion type",
  "62_15.txt": "Unknown assertion type",
  "62_16.txt": "Unknown assertion type",
  "62_17.txt": "Unknown assertion type",
  "62_18.txt": "Unknown assertion type",
  "62_19.txt": "Unknown assertion type",
  "62_2.txt": "Unknown assertion type",
  "62_20.txt": "Unknown assertion type",
  "62_21.txt": "Unknown assertion type",
  "62_22.txt": "Unknown assertion type",
  "62_23.txt": "Unknown assertion type",
  "62_24.txt": "Unknown assertion type",
  "62_25.txt": "Unknown assertion type",
  "62_26.txt": "Unknown assertion type",
  "62_27.txt": "Unknown assertion type",
  "62_28.txt": "Unknown assertion type",
  "62_29.txt": "Unknown assertion type",
  "62_3.txt": "Unknown assertion type",
  "62_4.txt": "Unknown assertion type",
  "62_5.txt": "Unknown assertion type",
  "62_6.txt": "Unknown assertion type",
  "62_7.txt": "Unknown assertion type",
  "62_8.txt": "Unknown assertion type",
  "62_9.txt": "Unknown assertion type",
  "63_0.txt": "{\n  \"file\": \"63_0.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_1.txt": "{\n  \"file\": \"63_1.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 1.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 1.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_10.txt": "{\n  \"file\": \"63_10.txt\",\n  \"assertion\": \"assertEquals ( \\\"bar\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"bar\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"bar\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_11.txt": "{\n  \"file\": \"63_11.txt\",\n  \"assertion\": \"assertEquals ( \\\"10\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"10\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"10\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_12.txt": "{\n  \"file\": \"63_12.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", out.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", out.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_13.txt": "{\n  \"file\": \"63_13.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.gettext ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.gettext ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"gettext\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_14.txt": "{\n  \"file\": \"63_14.txt\",\n  \"assertion\": \"assertEquals ( \\\"1\\\", 1.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"1\\\", 1.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_15.txt": "{\n  \"file\": \"63_15.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 0.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 0.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_16.txt": "{\n  \"file\": \"63_16.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 1.getValue ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 1.getValue ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_17.txt": "{\n  \"file\": \"63_17.txt\",\n  \"assertion\": \"assertEquals ( \\\"2\\\", 1.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"2\\\", 1.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_18.txt": "{\n  \"file\": \"63_18.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", is.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", is.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_19.txt": "{\n  \"file\": \"63_19.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 1.getMessage ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 1.getMessage ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_2.txt": "{\n  \"file\": \"63_2.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 1000.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 1000.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_20.txt": "{\n  \"file\": \"63_20.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", true.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", true.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_21.txt": "{\n  \"file\": \"63_21.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.getResponse ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.getResponse ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getResponse\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_22.txt": "{\n  \"file\": \"63_22.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", message.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", message.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_23.txt": "{\n  \"file\": \"63_23.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 1.getLong ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 1.getLong ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_24.txt": "{\n  \"file\": \"63_24.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test. endT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test. endT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"endT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_25.txt": "{\n  \"file\": \"63_25.txt\",\n  \"assertion\": \"assertEquals ( \\\"foo\\\", 1.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"foo\\\", 1.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_26.txt": "{\n  \"file\": \"63_26.txt\",\n  \"assertion\": \"assertEquals ( \\\"bar\\\", 1.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"bar\\\", 1.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_27.txt": "{\n  \"file\": \"63_27.txt\",\n  \"assertion\": \"assertEquals ( \\\"hello\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"hello\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"hello\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_28.txt": "{\n  \"file\": \"63_28.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.getName ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.getName ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getName\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_29.txt": "{\n  \"file\": \"63_29.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test. messageT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test. messageT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"messageT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_3.txt": "{\n  \"file\": \"63_3.txt\",\n  \"assertion\": \"assertEquals ( \\\"1\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"1\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"1\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_4.txt": "{\n  \"file\": \"63_4.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.getValue ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.getValue ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getValue\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_5.txt": "{\n  \"file\": \"63_5.txt\",\n  \"assertion\": \"assertEquals ( \\\"2\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"2\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"2\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_6.txt": "{\n  \"file\": \"63_6.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.getMessage ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.getMessage ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getMessage\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_7.txt": "{\n  \"file\": \"63_7.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", test.getLong ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", test.getLong ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"test\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getLong\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "63_8.txt": "{\n  \"file\": \"63_8.txt\",\n  \"assertion\": \"assertEquals ( \\\"test\\\", 50.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"test\\\", 50.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "63_9.txt": "{\n  \"file\": \"63_9.txt\",\n  \"assertion\": \"assertEquals ( \\\"foo\\\", test.getT ( ) )\\r\\n\",\n  \"test\": \"class X {public void JndiConnectTest ( ) { String cmdLine \\u003d ( ( \\\"--jndi\\u003csp\\u003e/amqp/jndi.properties\\u003csp\\u003e-\\\" + ( co . nordlander . a . A . CMD_PUT ) ) + \\\"\\\\\\\"test\\\\\\\"\\\" ) + \\\"\\u003csp\\u003eTEST.QUEUE\\\" ; a . run ( cmdLine . split ( \\\"\\u003csp\\u003e\\\" ) ) ; MessageConsumer mc \\u003d session . createConsumer ( testQueue ) ; TextMessage msg \\u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \\\"foo\\\", test.getT ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void run( String [ ]  var24678 ) { Options opts \\u003d createOptions ( ) ; if ( ( args . length ) \\u003d\\u003d 0 ) { HelpFormatter helpFormatter \\u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003ea-\\u003cversion\\u003e-with-dependencies.jar\\\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \\u003d new PosixParser ( ) ; try { cmdLine \\u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \\u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \\u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \\\"tcp://localhost:61616\\\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \\\"\\\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \\u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \\u003d System . currentTimeMillis ( ) ; long elapsedTime \\u003d stopTime - startTime ; Long . output ( \\\"Operation\\u003csp\\u003ecompleted\\u003csp\\u003ein\\u003csp\\u003e\\\" , Long . toString ( elapsedTime ) , \\\"ms\\u003csp\\u003e(excluding\\u003csp\\u003econnect)\\\" ) ; } finally { try { if ( ( sess ) !\\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \\\"Active\\u003csp\\u003ethreads\\u003csp\\u003e{}\\\" , Thread . activeCount ( ) ) ; logger . debug ( \\\"At\\u003csp\\u003ethe\\u003csp\\u003eend\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003eroad\\\" ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( \\\"test\\\", msg. getText ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"stop parsing\": \"error in getTypeFromFM()\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"foo\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"getT\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "64_0.txt": "{\n  \"file\": \"64_0.txt\",\n  \"assertion\": \"assertEquals ( s s 2, SSL )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, SSL ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_1.txt": "{\n  \"file\": \"64_1.txt\",\n  \"assertion\": \"assertEquals ( s s 2, connection )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, connection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_10.txt": "{\n  \"file\": \"64_10.txt\",\n  \"assertion\": \"assertEquals ( s s 2, 1 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_11.txt": "{\n  \"file\": \"64_11.txt\",\n  \"assertion\": \"assertEquals ( s s 2, 3 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_12.txt": "{\n  \"file\": \"64_12.txt\",\n  \"assertion\": \"assertEquals ( s s 0, SSL )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, SSL ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_13.txt": "{\n  \"file\": \"64_13.txt\",\n  \"assertion\": \"assertEquals ( s s 0, connection )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, connection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_14.txt": "{\n  \"file\": \"64_14.txt\",\n  \"assertion\": \"assertEquals ( s s 0, 2 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_15.txt": "{\n  \"file\": \"64_15.txt\",\n  \"assertion\": \"assertEquals ( s s 2, 0 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_16.txt": "{\n  \"file\": \"64_16.txt\",\n  \"assertion\": \"assertEquals ( s s 2, 6 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 6 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_17.txt": "{\n  \"file\": \"64_17.txt\",\n  \"assertion\": \"assertEquals ( s s ), ) )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_18.txt": "{\n  \"file\": \"64_18.txt\",\n  \"assertion\": \"assertEquals ( s s 2, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_19.txt": "{\n  \"file\": \"64_19.txt\",\n  \"assertion\": \"assertEquals ( s s ), 1 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_2.txt": "{\n  \"file\": \"64_2.txt\",\n  \"assertion\": \"assertEquals ( s s 2, 2 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_20.txt": "{\n  \"file\": \"64_20.txt\",\n  \"assertion\": \"assertEquals ( s s 1, ) )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_21.txt": "{\n  \"file\": \"64_21.txt\",\n  \"assertion\": \"assertEquals ( s s 1, 1 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_22.txt": "{\n  \"file\": \"64_22.txt\",\n  \"assertion\": \"assertEquals ( s s ), 3 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_23.txt": "{\n  \"file\": \"64_23.txt\",\n  \"assertion\": \"assertEquals ( s s 1, 3 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_24.txt": "{\n  \"file\": \"64_24.txt\",\n  \"assertion\": \"assertEquals ( s s null, SSL )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s null, SSL ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_25.txt": "{\n  \"file\": \"64_25.txt\",\n  \"assertion\": \"assertEquals ( s s 2, 5 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_26.txt": "{\n  \"file\": \"64_26.txt\",\n  \"assertion\": \"assertEquals ( s s null, connection )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s null, connection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_27.txt": "{\n  \"file\": \"64_27.txt\",\n  \"assertion\": \"assertEquals ( s s ), 0 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_28.txt": "{\n  \"file\": \"64_28.txt\",\n  \"assertion\": \"assertEquals ( s s 0, ) )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_29.txt": "{\n  \"file\": \"64_29.txt\",\n  \"assertion\": \"assertEquals ( s s 1, 0 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_3.txt": "{\n  \"file\": \"64_3.txt\",\n  \"assertion\": \"assertEquals ( s s ), SSL )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), SSL ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_4.txt": "{\n  \"file\": \"64_4.txt\",\n  \"assertion\": \"assertEquals ( s s ), connection )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), connection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_5.txt": "{\n  \"file\": \"64_5.txt\",\n  \"assertion\": \"assertEquals ( s s 1, SSL )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, SSL ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_6.txt": "{\n  \"file\": \"64_6.txt\",\n  \"assertion\": \"assertEquals ( s s 1, connection )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, connection ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_7.txt": "{\n  \"file\": \"64_7.txt\",\n  \"assertion\": \"assertEquals ( s s ), 2 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_8.txt": "{\n  \"file\": \"64_8.txt\",\n  \"assertion\": \"assertEquals ( s s 2, ) )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "64_9.txt": "{\n  \"file\": \"64_9.txt\",\n  \"assertion\": \"assertEquals ( s s 1, 2 )\\r\\n\",\n  \"test\": \"class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \\u003d false ; try { final Properties connectionProps \\u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \\\"true\\\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \\\"drill123\\\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \\\"true\\\" ) ; DrillConfig sslConfig \\u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"JKS\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"drill123\\\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \\\"TLSv1.2\\\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \\u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \\u003e 0 ) , \\\"Number\\u003csp\\u003eof\\u003csp\\u003eDrillbits\\u003csp\\u003emust\\u003csp\\u003ebe\\u003csp\\u003eat\\u003csp\\u003eleast\\u003csp\\u003eone\\\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \\u003d newDrillbitCount ; if ( newConfig !\\u003d null ) { org . apache . drill . test . BaseTestQuery . config \\u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \\\"Failure\\u003csp\\u003ewhile\\u003csp\\u003eupdating\\u003csp\\u003ethe\\u003csp\\u003etest\\u003csp\\u003eDrillbit\\u003csp\\u003ecluster.\\\" , e ) ; } } } }\\r\\n\",\n  \"truth\": \"assertEquals ( failureCaught, true )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "65_0.txt": "{\n  \"file\": \"65_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_1.txt": "{\n  \"file\": \"65_1.txt\",\n  \"assertion\": \"assertEquals ( expected, result )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "65_10.txt": "{\n  \"file\": \"65_10.txt\",\n  \"assertion\": \"assertEquals (expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals (expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_11.txt": "{\n  \"file\": \"65_11.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_12.txt": "{\n  \"file\": \"65_12.txt\",\n  \"assertion\": \"assertEquals ( expected, null )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_13.txt": "{\n  \"file\": \"65_13.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_14.txt": "{\n  \"file\": \"65_14.txt\",\n  \"assertion\": \"assertEquals ( expected, 0 )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_15.txt": "{\n  \"file\": \"65_15.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_16.txt": "{\n  \"file\": \"65_16.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( \\\"\\\", expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_17.txt": "{\n  \"file\": \"65_17.txt\",\n  \"assertion\": \"assertEquals ( expected, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_18.txt": "{\n  \"file\": \"65_18.txt\",\n  \"assertion\": \"assertEquals ( unexpected, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( unexpected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_19.txt": "{\n  \"file\": \"65_19.txt\",\n  \"assertion\": \"assertEquals ( expected, unexpected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, unexpected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_2.txt": "{\n  \"file\": \"65_2.txt\",\n  \"assertion\": \"assertEquals ( result, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( result, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "65_20.txt": "{\n  \"file\": \"65_20.txt\",\n  \"assertion\": \"assertEquals ( found, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( found, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"found\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_21.txt": "{\n  \"file\": \"65_21.txt\",\n  \"assertion\": \"assertEquals ( expected, found )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, found ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"found\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_22.txt": "{\n  \"file\": \"65_22.txt\",\n  \"assertion\": \"assertEquals ( allowed, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( allowed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"allowed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_23.txt": "{\n  \"file\": \"65_23.txt\",\n  \"assertion\": \"assertEquals ( expected, allowed )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, allowed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"allowed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_24.txt": "{\n  \"file\": \"65_24.txt\",\n  \"assertion\": \"assertEquals ( 3, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( 3, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_25.txt": "{\n  \"file\": \"65_25.txt\",\n  \"assertion\": \"assertEquals ( message, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( message, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"message\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_26.txt": "{\n  \"file\": \"65_26.txt\",\n  \"assertion\": \"assertEquals ( expected, message )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, message ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"message\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_27.txt": "{\n  \"file\": \"65_27.txt\",\n  \"assertion\": \"assertEquals ( expecting, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expecting, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_28.txt": "{\n  \"file\": \"65_28.txt\",\n  \"assertion\": \"assertEquals ( test, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( test, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"test\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_29.txt": "{\n  \"file\": \"65_29.txt\",\n  \"assertion\": \"assertEquals ( expected, test )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, test ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"test\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_3.txt": "{\n  \"file\": \"65_3.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_4.txt": "{\n  \"file\": \"65_4.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_5.txt": "{\n  \"file\": \"65_5.txt\",\n  \"assertion\": \"assertEquals (pected, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals (pected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_6.txt": "{\n  \"file\": \"65_6.txt\",\n  \"assertion\": \"assertEquals ( expected,pected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected,pected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_7.txt": "{\n  \"file\": \"65_7.txt\",\n  \"assertion\": \"assertEquals ( expectation, expected )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expectation, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expectation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_8.txt": "{\n  \"file\": \"65_8.txt\",\n  \"assertion\": \"assertEquals ( expected, expectation )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( expected, expectation ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"String\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expectation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "65_9.txt": "{\n  \"file\": \"65_9.txt\",\n  \"assertion\": \"assertEquals ( result, result )\\r\\n\",\n  \"test\": \"class X {public void testJSON ( ) { final String testMsg \\u003d \\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\" ; final StringMapMessage msg \\u003d new StringMapMessage ( ) ; msg . put ( \\\"message\\\" , testMsg ) ; msg . put ( \\\"project\\\" , \\\"Log4j\\\" ) ; final String result \\u003d msg . getFormattedMessage ( new String [ ] { \\\"JSON\\\" } ) ; final String expected \\u003d \\\"{\\\\\\\"message\\\\\\\":\\\\\\\"Test\\u003csp\\u003emessage\\u003csp\\u003e{}\\\\\\\",\\u003csp\\u003e\\\\\\\"project\\\\\\\":\\\\\\\"Log4j\\\\\\\"}\\\" ; assertEquals ( result, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "66_0.txt": "{\n  \"file\": \"66_0.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_1.txt": "{\n  \"file\": \"66_1.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_10.txt": "{\n  \"file\": \"66_10.txt\",\n  \"assertion\": \"assertEquals ( reminders reminder reminder, reminder 2 reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder 2 reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_11.txt": "{\n  \"file\": \"66_11.txt\",\n  \"assertion\": \"assertEquals ( reminder reminders reminder, reminder 2 reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder 2 reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_12.txt": "{\n  \"file\": \"66_12.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminders, reminder 2 reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder 2 reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_13.txt": "{\n  \"file\": \"66_13.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminders 2 reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminders 2 reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_14.txt": "{\n  \"file\": \"66_14.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder 2 reminder reminders reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminder reminders reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_15.txt": "{\n  \"file\": \"66_15.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminders )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminders ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_16.txt": "{\n  \"file\": \"66_16.txt\",\n  \"assertion\": \"assertEquals ( reminders reminder reminder, reminder [ reminders reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder [ reminders reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_17.txt": "{\n  \"file\": \"66_17.txt\",\n  \"assertion\": \"assertEquals ( reminder reminders reminder, reminder [ reminders reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder [ reminders reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_18.txt": "{\n  \"file\": \"66_18.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminders, reminder [ reminders reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder [ reminders reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_19.txt": "{\n  \"file\": \"66_19.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminders [ reminders reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminders [ reminders reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_2.txt": "{\n  \"file\": \"66_2.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder [ reminders reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminders reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_20.txt": "{\n  \"file\": \"66_20.txt\",\n  \"assertion\": \"assertEquals ( reminders reminders reminder, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminders reminder, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_21.txt": "{\n  \"file\": \"66_21.txt\",\n  \"assertion\": \"assertEquals ( reminders reminder reminders, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminders, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_22.txt": "{\n  \"file\": \"66_22.txt\",\n  \"assertion\": \"assertEquals ( reminder reminders reminders, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminders, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_23.txt": "{\n  \"file\": \"66_23.txt\",\n  \"assertion\": \"assertEquals ( reminders reminder reminder, reminders [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminders [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_24.txt": "{\n  \"file\": \"66_24.txt\",\n  \"assertion\": \"assertEquals ( reminder reminders reminder, reminders [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminders [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_25.txt": "{\n  \"file\": \"66_25.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminders, reminders [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminders [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_26.txt": "{\n  \"file\": \"66_26.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder [ reminders reminders reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminders reminders reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_27.txt": "{\n  \"file\": \"66_27.txt\",\n  \"assertion\": \"assertEquals ( reminders reminder reminder, reminder [ reminder reminders reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder [ reminder reminders reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_28.txt": "{\n  \"file\": \"66_28.txt\",\n  \"assertion\": \"assertEquals ( reminder reminders reminder, reminder [ reminder reminders reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder [ reminder reminders reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_29.txt": "{\n  \"file\": \"66_29.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminders, reminder [ reminder reminders reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder [ reminder reminders reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_3.txt": "{\n  \"file\": \"66_3.txt\",\n  \"assertion\": \"assertEquals ( reminders reminder reminder, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_4.txt": "{\n  \"file\": \"66_4.txt\",\n  \"assertion\": \"assertEquals ( reminder reminders reminder, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_5.txt": "{\n  \"file\": \"66_5.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminders, reminder [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_6.txt": "{\n  \"file\": \"66_6.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminders [ reminder reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminders [ reminder reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_7.txt": "{\n  \"file\": \"66_7.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder [ reminder reminders reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminder reminders reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_8.txt": "{\n  \"file\": \"66_8.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminders )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminders ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "66_9.txt": "{\n  \"file\": \"66_9.txt\",\n  \"assertion\": \"assertEquals ( reminder reminder reminder, reminder 2 reminders reminder reminder )\\r\\n\",\n  \"test\": \"class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \\u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \\\"Get\\u003csp\\u003eCoffee\\\" ) ; Reminder reminder2 \\u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \\\"Get\\u003csp\\u003eSnack\\\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \\\"Get\\u003csp\\u003eLunch\\\" ) ; Set \\u003c Reminder \\u003e expectedReminders \\u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \\u003c Reminder \\u003e mondayMorningReminders \\u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminders reminder reminder ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \\u003d\\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedReminders, mondayMorningReminders )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_0.txt": "{\n  \"file\": \"67_0.txt\",\n  \"assertion\": \"assertTrue ( out. is empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. is empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_1.txt": "{\n  \"file\": \"67_1.txt\",\n  \"assertion\": \"assertTrue ( out. next empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. next empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_10.txt": "{\n  \"file\": \"67_10.txt\",\n  \"assertion\": \"assertTrue ( out. are empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. are empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_11.txt": "{\n  \"file\": \"67_11.txt\",\n  \"assertion\": \"assertTrue ( out. _ empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. _ empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_12.txt": "{\n  \"file\": \"67_12.txt\",\n  \"assertion\": \"assertTrue ( out. to empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. to empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_13.txt": "{\n  \"file\": \"67_13.txt\",\n  \"assertion\": \"assertTrue ( out. already empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. already empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_14.txt": "{\n  \"file\": \"67_14.txt\",\n  \"assertion\": \"assertTrue ( out. now empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. now empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_15.txt": "{\n  \"file\": \"67_15.txt\",\n  \"assertion\": \"assertTrue ( out. isaining ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. isaining ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"isaining\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "67_16.txt": "{\n  \"file\": \"67_16.txt\",\n  \"assertion\": \"assertTrue ( out. add empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. add empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_17.txt": "{\n  \"file\": \"67_17.txt\",\n  \"assertion\": \"assertTrue ( out. nextaining ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. nextaining ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"nextaining\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "67_18.txt": "{\n  \"file\": \"67_18.txt\",\n  \"assertion\": \"assertTrue ( out. hasaining ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. hasaining ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"hasaining\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "67_19.txt": "{\n  \"file\": \"67_19.txt\",\n  \"assertion\": \"assertTrue ( out. can empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. can empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_2.txt": "{\n  \"file\": \"67_2.txt\",\n  \"assertion\": \"assertTrue ( out. has empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. has empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_20.txt": "{\n  \"file\": \"67_20.txt\",\n  \"assertion\": \"assertTrue ( out. was empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. was empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_21.txt": "{\n  \"file\": \"67_21.txt\",\n  \"assertion\": \"assertTrue ( out. removeaining ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. removeaining ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"removeaining\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "67_22.txt": "{\n  \"file\": \"67_22.txt\",\n  \"assertion\": \"assertTrue ( out. e empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. e empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_23.txt": "{\n  \"file\": \"67_23.txt\",\n  \"assertion\": \"assertTrue ( out.. empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out.. empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_24.txt": "{\n  \"file\": \"67_24.txt\",\n  \"assertion\": \"assertTrue ( out. dis empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. dis empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_25.txt": "{\n  \"file\": \"67_25.txt\",\n  \"assertion\": \"assertTrue ( out. allaining ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. allaining ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"allaining\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "67_26.txt": "{\n  \"file\": \"67_26.txt\",\n  \"assertion\": \"assertTrue ( out.!aining ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out.!aining ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_27.txt": "{\n  \"file\": \"67_27.txt\",\n  \"assertion\": \"assertTrue ( out. boolean empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. boolean empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_28.txt": "{\n  \"file\": \"67_28.txt\",\n  \"assertion\": \"assertTrue ( outs. is empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( outs. is empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_29.txt": "{\n  \"file\": \"67_29.txt\",\n  \"assertion\": \"assertTrue ( out. elements empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. elements empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_3.txt": "{\n  \"file\": \"67_3.txt\",\n  \"assertion\": \"assertTrue ( out. remove empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. remove empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_4.txt": "{\n  \"file\": \"67_4.txt\",\n  \"assertion\": \"assertTrue ( out. all empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. all empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_5.txt": "{\n  \"file\": \"67_5.txt\",\n  \"assertion\": \"assertTrue ( out.! empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out.! empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_6.txt": "{\n  \"file\": \"67_6.txt\",\n  \"assertion\": \"assertTrue ( out. empty empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. empty empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_7.txt": "{\n  \"file\": \"67_7.txt\",\n  \"assertion\": \"assertTrue ( out. signals empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. signals empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_8.txt": "{\n  \"file\": \"67_8.txt\",\n  \"assertion\": \"assertTrue ( out. contains empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. contains empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "67_9.txt": "{\n  \"file\": \"67_9.txt\",\n  \"assertion\": \"assertTrue ( out. any empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \\u003c Object \\u003e out \\u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. any empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( out. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "68_0.txt": "Unknown assertion type",
  "68_1.txt": "Unknown assertion type",
  "68_10.txt": "Unknown assertion type",
  "68_11.txt": "Unknown assertion type",
  "68_12.txt": "Unknown assertion type",
  "68_13.txt": "Unknown assertion type",
  "68_14.txt": "Unknown assertion type",
  "68_15.txt": "Unknown assertion type",
  "68_16.txt": "Unknown assertion type",
  "68_17.txt": "Unknown assertion type",
  "68_18.txt": "Unknown assertion type",
  "68_19.txt": "Unknown assertion type",
  "68_2.txt": "Unknown assertion type",
  "68_20.txt": "Unknown assertion type",
  "68_21.txt": "Unknown assertion type",
  "68_22.txt": "Unknown assertion type",
  "68_23.txt": "Unknown assertion type",
  "68_24.txt": "Unknown assertion type",
  "68_25.txt": "Unknown assertion type",
  "68_26.txt": "Unknown assertion type",
  "68_27.txt": "Unknown assertion type",
  "68_28.txt": "Unknown assertion type",
  "68_29.txt": "Unknown assertion type",
  "68_3.txt": "Unknown assertion type",
  "68_4.txt": "Unknown assertion type",
  "68_5.txt": "Unknown assertion type",
  "68_6.txt": "Unknown assertion type",
  "68_7.txt": "Unknown assertion type",
  "68_8.txt": "Unknown assertion type",
  "68_9.txt": "Unknown assertion type",
  "69_0.txt": "{\n  \"file\": \"69_0.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_1.txt": "{\n  \"file\": \"69_1.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actual list item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actual list item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_10.txt": "{\n  \"file\": \"69_10.txt\",\n  \"assertion\": \"assertEquals ( actualValue item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualValue item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_11.txt": "{\n  \"file\": \"69_11.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualValue 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualValue 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_12.txt": "{\n  \"file\": \"69_12.txt\",\n  \"assertion\": \"assertEquals ( actualEvent item, actualEvent item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualEvent item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_13.txt": "{\n  \"file\": \"69_13.txt\",\n  \"assertion\": \"assertEquals ( actualView item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualView item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_14.txt": "{\n  \"file\": \"69_14.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualView 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualView 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_15.txt": "{\n  \"file\": \"69_15.txt\",\n  \"assertion\": \"assertEquals ( actualL item, actualEvent item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actualEvent item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_16.txt": "{\n  \"file\": \"69_16.txt\",\n  \"assertion\": \"assertEquals ( actualValue item, actual list item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualValue item, actual list item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_17.txt": "{\n  \"file\": \"69_17.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualValue item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualValue item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_18.txt": "{\n  \"file\": \"69_18.txt\",\n  \"assertion\": \"assertEquals ( actualView item, actual list item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualView item, actual list item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_19.txt": "{\n  \"file\": \"69_19.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualView item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualView item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_2.txt": "{\n  \"file\": \"69_2.txt\",\n  \"assertion\": \"assertEquals ( actualEvent item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_20.txt": "{\n  \"file\": \"69_20.txt\",\n  \"assertion\": \"assertEquals ( actualEvent item, actualValue 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualValue 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_21.txt": "{\n  \"file\": \"69_21.txt\",\n  \"assertion\": \"assertEquals ( actualValue item, actualEvent 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualValue item, actualEvent 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_22.txt": "{\n  \"file\": \"69_22.txt\",\n  \"assertion\": \"assertEquals ( actualClass item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualClass item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_23.txt": "{\n  \"file\": \"69_23.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualClass 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualClass 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_24.txt": "{\n  \"file\": \"69_24.txt\",\n  \"assertion\": \"assertEquals ( actual list1, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list1, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_25.txt": "{\n  \"file\": \"69_25.txt\",\n  \"assertion\": \"assertEquals ( actualL item, actualValue 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actualValue 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_26.txt": "{\n  \"file\": \"69_26.txt\",\n  \"assertion\": \"assertEquals ( actualModel item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualModel item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_27.txt": "{\n  \"file\": \"69_27.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualModel 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualModel 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_28.txt": "{\n  \"file\": \"69_28.txt\",\n  \"assertion\": \"assertEquals ( actualEvent item, actualView 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualView 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_29.txt": "{\n  \"file\": \"69_29.txt\",\n  \"assertion\": \"assertEquals ( actualView item, actualEvent 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualView item, actualEvent 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_3.txt": "{\n  \"file\": \"69_3.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualEvent 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualEvent 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_4.txt": "{\n  \"file\": \"69_4.txt\",\n  \"assertion\": \"assertEquals ( actualL item, actual list 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actual list 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_5.txt": "{\n  \"file\": \"69_5.txt\",\n  \"assertion\": \"assertEquals ( actualEvent item, actual list item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actual list item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_6.txt": "{\n  \"file\": \"69_6.txt\",\n  \"assertion\": \"assertEquals ( actual list item, actualEvent item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualEvent item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_7.txt": "{\n  \"file\": \"69_7.txt\",\n  \"assertion\": \"assertEquals ( actualL item, actual list item )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actual list item ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_8.txt": "{\n  \"file\": \"69_8.txt\",\n  \"assertion\": \"assertEquals ( actualEvent item, actualEvent 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualEvent 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "69_9.txt": "{\n  \"file\": \"69_9.txt\",\n  \"assertion\": \"assertEquals ( actualL item, actualEvent 0 )\\r\\n\",\n  \"test\": \"class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \\u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \\u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actualEvent 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \\u003d presenter ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedListItem, actualListItem )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_0.txt": "{\n  \"file\": \"6_0.txt\",\n  \"assertion\": \"assertEquals ( 1, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_1.txt": "{\n  \"file\": \"6_1.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 0. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_10.txt": "{\n  \"file\": \"6_10.txt\",\n  \"assertion\": \"assertEquals ( 0, 2. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 0, 2. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_11.txt": "{\n  \"file\": \"6_11.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 0. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_12.txt": "{\n  \"file\": \"6_12.txt\",\n  \"assertion\": \"assertEquals ( 0, 1. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 0, 1. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_13.txt": "{\n  \"file\": \"6_13.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 2, 2. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_14.txt": "{\n  \"file\": \"6_14.txt\",\n  \"assertion\": \"assertEquals ( 2, 1. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 2, 1. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_15.txt": "{\n  \"file\": \"6_15.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 2. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_16.txt": "{\n  \"file\": \"6_16.txt\",\n  \"assertion\": \"assertEquals ( 4, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 4, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_17.txt": "{\n  \"file\": \"6_17.txt\",\n  \"assertion\": \"assertEquals ( 1, 4. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 4. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_18.txt": "{\n  \"file\": \"6_18.txt\",\n  \"assertion\": \"assertEquals ( 6, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 6, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_19.txt": "{\n  \"file\": \"6_19.txt\",\n  \"assertion\": \"assertEquals ( 3, 0. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 3, 0. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_2.txt": "{\n  \"file\": \"6_2.txt\",\n  \"assertion\": \"assertEquals ( 0, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 0, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_20.txt": "{\n  \"file\": \"6_20.txt\",\n  \"assertion\": \"assertEquals ( 0, 3. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 0, 3. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_21.txt": "{\n  \"file\": \"6_21.txt\",\n  \"assertion\": \"assertEquals ( 5, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 5, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_22.txt": "{\n  \"file\": \"6_22.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 0, 0. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_23.txt": "{\n  \"file\": \"6_23.txt\",\n  \"assertion\": \"assertEquals ( 3, 2. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 3, 2. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_24.txt": "{\n  \"file\": \"6_24.txt\",\n  \"assertion\": \"assertEquals ( 2, 3. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 2, 3. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_25.txt": "{\n  \"file\": \"6_25.txt\",\n  \"assertion\": \"assertEquals ( 3, 1. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 3, 1. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_26.txt": "{\n  \"file\": \"6_26.txt\",\n  \"assertion\": \"assertEquals ( 1, 3. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 3. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_27.txt": "{\n  \"file\": \"6_27.txt\",\n  \"assertion\": \"assertEquals ( 7, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 7, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_28.txt": "{\n  \"file\": \"6_28.txt\",\n  \"assertion\": \"assertEquals ( 9, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 9, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_29.txt": "{\n  \"file\": \"6_29.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 2, 0. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_3.txt": "{\n  \"file\": \"6_3.txt\",\n  \"assertion\": \"assertEquals ( 2, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 2, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_4.txt": "{\n  \"file\": \"6_4.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 2. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_5.txt": "{\n  \"file\": \"6_5.txt\",\n  \"assertion\": \"assertEquals ( 1, 1. 2 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 1. 2 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_6.txt": "{\n  \"file\": \"6_6.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 0, 0. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_7.txt": "{\n  \"file\": \"6_7.txt\",\n  \"assertion\": \"assertEquals ( 3, 1. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 3, 1. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_8.txt": "{\n  \"file\": \"6_8.txt\",\n  \"assertion\": \"assertEquals ( 1, 3. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 1, 3. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "6_9.txt": "{\n  \"file\": \"6_9.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void runTestExceptions3 ( ) { InfoflowResults res \\u003d analyzeAPKFile ( \\\"GeneralJava/Exceptions3.apk\\\" ) ; assertEquals ( 2, 0. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return set . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, res. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "70_0.txt": "{\n  \"file\": \"70_0.txt\",\n  \"assertion\": \"assertTrue ( query. execute ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. execute ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"execute\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_1.txt": "{\n  \"file\": \"70_1.txt\",\n  \"assertion\": \"assertTrue ( query. result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_10.txt": "{\n  \"file\": \"70_10.txt\",\n  \"assertion\": \"assertTrue ( query. take ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. take ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"take\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_11.txt": "{\n  \"file\": \"70_11.txt\",\n  \"assertion\": \"assertTrue ( query. expand ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. expand ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expand\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_12.txt": "{\n  \"file\": \"70_12.txt\",\n  \"assertion\": \"assertTrue ( query. accept ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. accept ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"accept\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_13.txt": "{\n  \"file\": \"70_13.txt\",\n  \"assertion\": \"assertTrue ( query. retrieve ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. retrieve ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"retrieve\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_14.txt": "{\n  \"file\": \"70_14.txt\",\n  \"assertion\": \"assertTrue ( query. analyze ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. analyze ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"analyze\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_15.txt": "{\n  \"file\": \"70_15.txt\",\n  \"assertion\": \"assertTrue ( query. eval ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. eval ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"eval\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_16.txt": "{\n  \"file\": \"70_16.txt\",\n  \"assertion\": \"assertTrue ( query. decide ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. decide ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"decide\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_17.txt": "{\n  \"file\": \"70_17.txt\",\n  \"assertion\": \"assertTrue ( statement. execute ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( statement. execute ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"execute\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_18.txt": "{\n  \"file\": \"70_18.txt\",\n  \"assertion\": \"assertTrue ( query. examine ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. examine ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"examine\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_19.txt": "{\n  \"file\": \"70_19.txt\",\n  \"assertion\": \"assertTrue ( command. execute ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( command. execute ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"execute\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_2.txt": "{\n  \"file\": \"70_2.txt\",\n  \"assertion\": \"assertTrue ( query. expr ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. expr ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expr\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_20.txt": "{\n  \"file\": \"70_20.txt\",\n  \"assertion\": \"assertTrue ( query. calculate ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. calculate ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"calculate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_21.txt": "{\n  \"file\": \"70_21.txt\",\n  \"assertion\": \"assertTrue ( query. evaluation ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. evaluation ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evaluation\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_22.txt": "{\n  \"file\": \"70_22.txt\",\n  \"assertion\": \"assertTrue ( statement. result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( statement. result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_23.txt": "{\n  \"file\": \"70_23.txt\",\n  \"assertion\": \"assertTrue ( command. result ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( command. result ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_24.txt": "{\n  \"file\": \"70_24.txt\",\n  \"assertion\": \"assertTrue ( query. isEnabled ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. isEnabled ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"isEnabled\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_25.txt": "{\n  \"file\": \"70_25.txt\",\n  \"assertion\": \"assertTrue ( query. assess ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. assess ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"assess\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_26.txt": "{\n  \"file\": \"70_26.txt\",\n  \"assertion\": \"assertTrue ( query. evaluating ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. evaluating ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evaluating\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_27.txt": "{\n  \"file\": \"70_27.txt\",\n  \"assertion\": \"assertTrue ( statement. expr ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( statement. expr ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expr\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_28.txt": "{\n  \"file\": \"70_28.txt\",\n  \"assertion\": \"assertTrue ( command. expr ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( command. expr ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expr\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_29.txt": "{\n  \"file\": \"70_29.txt\",\n  \"assertion\": \"assertTrue ( query. optimize ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. optimize ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"optimize\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_3.txt": "{\n  \"file\": \"70_3.txt\",\n  \"assertion\": \"assertTrue ( query. expression ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. expression ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"expression\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_4.txt": "{\n  \"file\": \"70_4.txt\",\n  \"assertion\": \"assertTrue ( query. update ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. update ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"update\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_5.txt": "{\n  \"file\": \"70_5.txt\",\n  \"assertion\": \"assertTrue ( query. find ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. find ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"find\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_6.txt": "{\n  \"file\": \"70_6.txt\",\n  \"assertion\": \"assertTrue ( query. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"count\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_7.txt": "{\n  \"file\": \"70_7.txt\",\n  \"assertion\": \"assertTrue ( query. validate ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. validate ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "70_8.txt": "{\n  \"file\": \"70_8.txt\",\n  \"assertion\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. evaluate ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"find type in focal method\": \"evaluate\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evaluate\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "70_9.txt": "{\n  \"file\": \"70_9.txt\",\n  \"assertion\": \"assertTrue ( query. apply ( ) )\\r\\n\",\n  \"test\": \"class X {public void testAskNoBindings ( ) { String queryString \\u003d \\\"PREFIX\\u003csp\\u003e:\\u003csp\\u003e\\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\\u003e\\u003csp\\u003e\\\" + \\\"ASK\\u003csp\\u003eWHERE\\u003csp\\u003e{?x\\u003csp\\u003e:hasVal1\\u003csp\\u003e?v1\\u003csp\\u003e.}\\\" ; BooleanQuery query \\u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. apply ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \\u003d System . currentTimeMillis ( ) ; try { stm \\u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \\u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \\u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \\u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \\u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \\u003e 0 ) \\u0026\\u0026 ( ( end - start ) \\u003e\\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \\\"OntopTupleQuery\\u003csp\\u003etimed\\u003csp\\u003eout.\\u003csp\\u003eMore\\u003csp\\u003ethan\\u003csp\\u003e\\\" + ( this . queryTimeout ) ) + \\\"\\u003csp\\u003eseconds\\u003csp\\u003epassed\\\" ) , e ) ; } else throw e ; } List \\u003c String \\u003e signature \\u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( query. evaluate ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"apply\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "71_0.txt": "Unknown assertion type",
  "71_1.txt": "Unknown assertion type",
  "71_10.txt": "Unknown assertion type",
  "71_11.txt": "Unknown assertion type",
  "71_12.txt": "Unknown assertion type",
  "71_13.txt": "Unknown assertion type",
  "71_14.txt": "Unknown assertion type",
  "71_15.txt": "Unknown assertion type",
  "71_16.txt": "Unknown assertion type",
  "71_17.txt": "Unknown assertion type",
  "71_18.txt": "Unknown assertion type",
  "71_19.txt": "Unknown assertion type",
  "71_2.txt": "Unknown assertion type",
  "71_20.txt": "Unknown assertion type",
  "71_21.txt": "Unknown assertion type",
  "71_22.txt": "Unknown assertion type",
  "71_23.txt": "Unknown assertion type",
  "71_24.txt": "Unknown assertion type",
  "71_25.txt": "Unknown assertion type",
  "71_26.txt": "Unknown assertion type",
  "71_27.txt": "Unknown assertion type",
  "71_28.txt": "Unknown assertion type",
  "71_29.txt": "Unknown assertion type",
  "71_3.txt": "Unknown assertion type",
  "71_4.txt": "Unknown assertion type",
  "71_5.txt": "Unknown assertion type",
  "71_6.txt": "Unknown assertion type",
  "71_7.txt": "Unknown assertion type",
  "71_8.txt": "Unknown assertion type",
  "71_9.txt": "Unknown assertion type",
  "72_0.txt": "{\n  \"file\": \"72_0.txt\",\n  \"assertion\": \"assertEquals ( 0, objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_1.txt": "{\n  \"file\": \"72_1.txt\",\n  \"assertion\": \"assertEquals ( 1, objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_10.txt": "{\n  \"file\": \"72_10.txt\",\n  \"assertion\": \"assertEquals ( 2, object. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, object. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_11.txt": "{\n  \"file\": \"72_11.txt\",\n  \"assertion\": \"assertEquals ( 2, results. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, results. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_12.txt": "{\n  \"file\": \"72_12.txt\",\n  \"assertion\": \"assertEquals ( 0, classes. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, classes. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_13.txt": "{\n  \"file\": \"72_13.txt\",\n  \"assertion\": \"assertEquals ( 0, elements. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, elements. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_14.txt": "{\n  \"file\": \"72_14.txt\",\n  \"assertion\": \"assertEquals ( 0, items. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, items. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_15.txt": "{\n  \"file\": \"72_15.txt\",\n  \"assertion\": \"assertEquals ( 0, Objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, Objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_16.txt": "{\n  \"file\": \"72_16.txt\",\n  \"assertion\": \"assertEquals ( 1, classes. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, classes. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_17.txt": "{\n  \"file\": \"72_17.txt\",\n  \"assertion\": \"assertEquals ( 3, objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 3, objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_18.txt": "{\n  \"file\": \"72_18.txt\",\n  \"assertion\": \"assertEquals ( 2, classes. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, classes. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_19.txt": "{\n  \"file\": \"72_19.txt\",\n  \"assertion\": \"assertEquals ( 1, elements. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, elements. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_2.txt": "{\n  \"file\": \"72_2.txt\",\n  \"assertion\": \"assertEquals ( 2, objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_20.txt": "{\n  \"file\": \"72_20.txt\",\n  \"assertion\": \"assertEquals ( 2, elements. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, elements. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_21.txt": "{\n  \"file\": \"72_21.txt\",\n  \"assertion\": \"assertEquals ( 1, items. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, items. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_22.txt": "{\n  \"file\": \"72_22.txt\",\n  \"assertion\": \"assertEquals ( 0, types. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, types. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_23.txt": "{\n  \"file\": \"72_23.txt\",\n  \"assertion\": \"assertEquals ( 2, items. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, items. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_24.txt": "{\n  \"file\": \"72_24.txt\",\n  \"assertion\": \"assertEquals ( 1, Objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, Objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_25.txt": "{\n  \"file\": \"72_25.txt\",\n  \"assertion\": \"assertEquals ( 2, Objects. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, Objects. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_26.txt": "{\n  \"file\": \"72_26.txt\",\n  \"assertion\": \"assertEquals ( 0, entities. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, entities. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_27.txt": "{\n  \"file\": \"72_27.txt\",\n  \"assertion\": \"assertEquals ( 1, types. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, types. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_28.txt": "{\n  \"file\": \"72_28.txt\",\n  \"assertion\": \"assertEquals ( 2, types. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, types. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_29.txt": "{\n  \"file\": \"72_29.txt\",\n  \"assertion\": \"assertEquals ( 0, collections. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, collections. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_3.txt": "{\n  \"file\": \"72_3.txt\",\n  \"assertion\": \"assertEquals ( 0, result. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, result. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_4.txt": "{\n  \"file\": \"72_4.txt\",\n  \"assertion\": \"assertEquals ( 0, object. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, object. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_5.txt": "{\n  \"file\": \"72_5.txt\",\n  \"assertion\": \"assertEquals ( 0, results. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 0, results. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_6.txt": "{\n  \"file\": \"72_6.txt\",\n  \"assertion\": \"assertEquals ( 1, result. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, result. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_7.txt": "{\n  \"file\": \"72_7.txt\",\n  \"assertion\": \"assertEquals ( 2, result. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 2, result. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_8.txt": "{\n  \"file\": \"72_8.txt\",\n  \"assertion\": \"assertEquals ( 1, object. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, object. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "72_9.txt": "{\n  \"file\": \"72_9.txt\",\n  \"assertion\": \"assertEquals ( 1, results. 1 ( ) )\\r\\n\",\n  \"test\": \"class X {public void testIdentifiableSearch2 ( ) { Query query \\u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \\u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupA\\\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \\\"name\\\" , \\\"DataElementGroupB\\\" ) ) ; query . add ( disjunction ) ; List \\u003c ? extends IdentifiableObject \\u003e objects \\u003d queryEngine . query ( query ) ; assertEquals ( 1, results. 1 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return messages . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 2, objects. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "73_0.txt": "{\n  \"file\": \"73_0.txt\",\n  \"assertion\": \"assertNull ( match )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( match ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"match\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"IIsotope\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "73_1.txt": "{\n  \"file\": \"73_1.txt\",\n  \"assertion\": \"assertNull ( fit )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( fit ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"fit\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_10.txt": "{\n  \"file\": \"73_10.txt\",\n  \"assertion\": \"assertNull ( search )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( search ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"search\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_11.txt": "{\n  \"file\": \"73_11.txt\",\n  \"assertion\": \"assertNull ( matched )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( matched ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matched\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_12.txt": "{\n  \"file\": \"73_12.txt\",\n  \"assertion\": \"assertNull ( replace )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( replace ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"replace\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_13.txt": "{\n  \"file\": \"73_13.txt\",\n  \"assertion\": \"assertNull ( 0 )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_14.txt": "{\n  \"file\": \"73_14.txt\",\n  \"assertion\": \"assertNull ( mate )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( mate ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_15.txt": "{\n  \"file\": \"73_15.txt\",\n  \"assertion\": \"assertNull ( result )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_16.txt": "{\n  \"file\": \"73_16.txt\",\n  \"assertion\": \"assertNull ( target )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( target ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"target\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_17.txt": "{\n  \"file\": \"73_17.txt\",\n  \"assertion\": \"assertNull ( bet )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( bet ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"bet\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_18.txt": "{\n  \"file\": \"73_18.txt\",\n  \"assertion\": \"assertNull ( 2 )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_19.txt": "{\n  \"file\": \"73_19.txt\",\n  \"assertion\": \"assertNull ( stop )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( stop ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"stop\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_2.txt": "{\n  \"file\": \"73_2.txt\",\n  \"assertion\": \"assertNull ( matching )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( matching ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matching\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_20.txt": "{\n  \"file\": \"73_20.txt\",\n  \"assertion\": \"assertNull ( change )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( change ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"change\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_21.txt": "{\n  \"file\": \"73_21.txt\",\n  \"assertion\": \"assertNull ( pattern )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( pattern ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"pattern\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_22.txt": "{\n  \"file\": \"73_22.txt\",\n  \"assertion\": \"assertNull ( meet )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( meet ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"meet\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_23.txt": "{\n  \"file\": \"73_23.txt\",\n  \"assertion\": \"assertNull ( break )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( break ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "73_24.txt": "{\n  \"file\": \"73_24.txt\",\n  \"assertion\": \"assertNull ( check )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( check ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"check\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_25.txt": "{\n  \"file\": \"73_25.txt\",\n  \"assertion\": \"assertNull ( test )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( test ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"test\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_26.txt": "{\n  \"file\": \"73_26.txt\",\n  \"assertion\": \"assertNull ( join )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( join ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"join\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_27.txt": "{\n  \"file\": \"73_27.txt\",\n  \"assertion\": \"assertNull ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_28.txt": "{\n  \"file\": \"73_28.txt\",\n  \"assertion\": \"assertNull ( look )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( look ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"look\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_29.txt": "{\n  \"file\": \"73_29.txt\",\n  \"assertion\": \"assertNull ( suit )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( suit ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"suit\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_3.txt": "{\n  \"file\": \"73_3.txt\",\n  \"assertion\": \"assertNull ( connect )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( connect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"connect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_4.txt": "{\n  \"file\": \"73_4.txt\",\n  \"assertion\": \"assertNull ( null )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_5.txt": "{\n  \"file\": \"73_5.txt\",\n  \"assertion\": \"assertNull ( matches )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( matches ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matches\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_6.txt": "{\n  \"file\": \"73_6.txt\",\n  \"assertion\": \"assertNull ( compare )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( compare ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"compare\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_7.txt": "{\n  \"file\": \"73_7.txt\",\n  \"assertion\": \"assertNull ( mismatch )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull ( mismatch ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mismatch\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_8.txt": "{\n  \"file\": \"73_8.txt\",\n  \"assertion\": \"assertNull (Match )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull (Match ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "73_9.txt": "{\n  \"file\": \"73_9.txt\",\n  \"assertion\": \"assertNull (match )\\r\\n\",\n  \"test\": \"class X {public void testYeahSure ( ) { Isotopes isofac \\u003d Isotopes . getInstance ( ) ; IIsotope match \\u003d isofac . getIsotope ( \\\"H\\\" , 13.00001 , 1.0E-4 ) ; assertNull (match ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \\u003d null ; double minDiff \\u003d Double . MAX_VALUE ; int elem \\u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \\u003c IIsotope \\u003e isotopes \\u003d this . isotopes [ elem ] ; if ( isotopes \\u003d\\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \\u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \\u0026\\u0026 ( diff \\u003c\\u003d tolerance ) ) \\u0026\\u0026 ( diff \\u003c minDiff ) ) { ret \\u003d clone ( isotope ) ; minDiff \\u003d diff ; } } return ret ; } }\\r\\n\",\n  \"truth\": \"assertNull ( match )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"match\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"IIsotope\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "74_0.txt": "{\n  \"file\": \"74_0.txt\",\n  \"assertion\": \"assertEquals ( c s, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_1.txt": "{\n  \"file\": \"74_1.txt\",\n  \"assertion\": \"assertEquals ( c cs, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_10.txt": "{\n  \"file\": \"74_10.txt\",\n  \"assertion\": \"assertEquals ( crs, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( crs, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_11.txt": "{\n  \"file\": \"74_11.txt\",\n  \"assertion\": \"assertEquals ( cms, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cms, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_12.txt": "{\n  \"file\": \"74_12.txt\",\n  \"assertion\": \"assertEquals ( cus, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cus, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_13.txt": "{\n  \"file\": \"74_13.txt\",\n  \"assertion\": \"assertEquals ( cos, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cos, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_14.txt": "{\n  \"file\": \"74_14.txt\",\n  \"assertion\": \"assertEquals ( cst, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cst, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_15.txt": "{\n  \"file\": \"74_15.txt\",\n  \"assertion\": \"assertEquals ( cns, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cns, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_16.txt": "{\n  \"file\": \"74_16.txt\",\n  \"assertion\": \"assertEquals ( cds, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cds, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_17.txt": "{\n  \"file\": \"74_17.txt\",\n  \"assertion\": \"assertEquals ( cjs, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cjs, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_18.txt": "{\n  \"file\": \"74_18.txt\",\n  \"assertion\": \"assertEquals ( cass, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cass, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_19.txt": "{\n  \"file\": \"74_19.txt\",\n  \"assertion\": \"assertEquals ( c SS, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c SS, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_2.txt": "{\n  \"file\": \"74_2.txt\",\n  \"assertion\": \"assertEquals ( c ss, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c ss, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_20.txt": "{\n  \"file\": \"74_20.txt\",\n  \"assertion\": \"assertEquals ( c s, c c ( )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, c c ( ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_21.txt": "{\n  \"file\": \"74_21.txt\",\n  \"assertion\": \"assertEquals ( ( s, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ( s, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_22.txt": "{\n  \"file\": \"74_22.txt\",\n  \"assertion\": \"assertEquals ( c s, ( c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, ( c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_23.txt": "{\n  \"file\": \"74_23.txt\",\n  \"assertion\": \"assertEquals ( c s, c ( c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, c ( c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_24.txt": "{\n  \"file\": \"74_24.txt\",\n  \"assertion\": \"assertEquals ( cts, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cts, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_25.txt": "{\n  \"file\": \"74_25.txt\",\n  \"assertion\": \"assertEquals ( C s, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( C s, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_26.txt": "{\n  \"file\": \"74_26.txt\",\n  \"assertion\": \"assertEquals ( c cs, c c ( )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, c c ( ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_27.txt": "{\n  \"file\": \"74_27.txt\",\n  \"assertion\": \"assertEquals ( c cs, ( c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, ( c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_28.txt": "{\n  \"file\": \"74_28.txt\",\n  \"assertion\": \"assertEquals ( c cs, c ( c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, c ( c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_29.txt": "{\n  \"file\": \"74_29.txt\",\n  \"assertion\": \"assertEquals ( ( cs, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ( cs, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_3.txt": "{\n  \"file\": \"74_3.txt\",\n  \"assertion\": \"assertEquals ( c stats, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c stats, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_4.txt": "{\n  \"file\": \"74_4.txt\",\n  \"assertion\": \"assertEquals ( cs, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cs, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_5.txt": "{\n  \"file\": \"74_5.txt\",\n  \"assertion\": \"assertEquals ( ccss, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ccss, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_6.txt": "{\n  \"file\": \"74_6.txt\",\n  \"assertion\": \"assertEquals ( c ], c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c ], c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_7.txt": "{\n  \"file\": \"74_7.txt\",\n  \"assertion\": \"assertEquals ( cx, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cx, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_8.txt": "{\n  \"file\": \"74_8.txt\",\n  \"assertion\": \"assertEquals ( css, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( css, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "74_9.txt": "{\n  \"file\": \"74_9.txt\",\n  \"assertion\": \"assertEquals ( ctx, c c c )\\r\\n\",\n  \"test\": \"class X {public void testCopy ( ) { CommunicationSummaryStatistics css \\u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \\\"myid\\\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \\\"myop\\\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \\\"myuri\\\" ) ; ConnectionStatistics cs \\u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \\u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \\\"id2\\\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \\\"out1\\\" , cs ) ; CommunicationSummaryStatistics cssCopy \\u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ctx, c c c ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( css, cssCopy )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "75_0.txt": "Unknown assertion type",
  "75_1.txt": "Unknown assertion type",
  "75_10.txt": "Unknown assertion type",
  "75_11.txt": "Unknown assertion type",
  "75_12.txt": "Unknown assertion type",
  "75_13.txt": "Unknown assertion type",
  "75_14.txt": "Unknown assertion type",
  "75_15.txt": "Unknown assertion type",
  "75_16.txt": "Unknown assertion type",
  "75_17.txt": "Unknown assertion type",
  "75_18.txt": "Unknown assertion type",
  "75_19.txt": "Unknown assertion type",
  "75_2.txt": "Unknown assertion type",
  "75_20.txt": "Unknown assertion type",
  "75_21.txt": "Unknown assertion type",
  "75_22.txt": "Unknown assertion type",
  "75_23.txt": "Unknown assertion type",
  "75_24.txt": "Unknown assertion type",
  "75_25.txt": "Unknown assertion type",
  "75_26.txt": "Unknown assertion type",
  "75_27.txt": "Unknown assertion type",
  "75_28.txt": "Unknown assertion type",
  "75_29.txt": "Unknown assertion type",
  "75_3.txt": "Unknown assertion type",
  "75_4.txt": "Unknown assertion type",
  "75_5.txt": "Unknown assertion type",
  "75_6.txt": "Unknown assertion type",
  "75_7.txt": "Unknown assertion type",
  "75_8.txt": "Unknown assertion type",
  "75_9.txt": "Unknown assertion type",
  "76_0.txt": "{\n  \"file\": \"76_0.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResources\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResources\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_1.txt": "{\n  \"file\": \"76_1.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResourcesResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_10.txt": "{\n  \"file\": \"76_10.txt\",\n  \"assertion\": \"assertTrue ( adapter. input hasCacheResourcesResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheResourcesResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_11.txt": "{\n  \"file\": \"76_11.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreMore\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreMore\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_12.txt": "{\n  \"file\": \"76_12.txt\",\n  \"assertion\": \"assertTrue ( adapter. input hasResourcesResources\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasResourcesResources\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_13.txt": "{\n  \"file\": \"76_13.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResourcesMore ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesMore ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_14.txt": "{\n  \"file\": \"76_14.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreMoreResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreMoreResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_15.txt": "{\n  \"file\": \"76_15.txt\",\n  \"assertion\": \"assertTrue ( adapter. input hasResourcesResourcesResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasResourcesResourcesResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_16.txt": "{\n  \"file\": \"76_16.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResourcess ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcess ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_17.txt": "{\n  \"file\": \"76_17.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreStreamResults ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreamResults ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_18.txt": "{\n  \"file\": \"76_18.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreInput\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreInput\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_19.txt": "{\n  \"file\": \"76_19.txt\",\n  \"assertion\": \"assertTrue ( adapter. inputMore moreResourcesResults ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreResourcesResults ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_2.txt": "{\n  \"file\": \"76_2.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResourcesResults ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesResults ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_20.txt": "{\n  \"file\": \"76_20.txt\",\n  \"assertion\": \"assertTrue ( adapter. input hasCacheResourcesResults ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheResourcesResults ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_21.txt": "{\n  \"file\": \"76_21.txt\",\n  \"assertion\": \"assertTrue ( adapter. inputMore moreStream\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreStream\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_22.txt": "{\n  \"file\": \"76_22.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreExt\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreExt\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_23.txt": "{\n  \"file\": \"76_23.txt\",\n  \"assertion\": \"assertTrue ( adapter. input hasCacheStream\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheStream\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_24.txt": "{\n  \"file\": \"76_24.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreStreammore ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreammore ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_25.txt": "{\n  \"file\": \"76_25.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreStreamStream ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreamStream ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_26.txt": "{\n  \"file\": \"76_26.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreInputResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreInputResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_27.txt": "{\n  \"file\": \"76_27.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreObject\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreObject\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_28.txt": "{\n  \"file\": \"76_28.txt\",\n  \"assertion\": \"assertTrue ( adapter. input. moreResources\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input. moreResources\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_29.txt": "{\n  \"file\": \"76_29.txt\",\n  \"assertion\": \"assertTrue ( adapter. inputMoreCacheResources\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMoreCacheResources\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_3.txt": "{\n  \"file\": \"76_3.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreStream\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStream\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_4.txt": "{\n  \"file\": \"76_4.txt\",\n  \"assertion\": \"assertTrue ( adapter. inputMore moreResources\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreResources\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_5.txt": "{\n  \"file\": \"76_5.txt\",\n  \"assertion\": \"assertTrue ( adapter. input hasCacheResources\\\" ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheResources\\\" ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_6.txt": "{\n  \"file\": \"76_6.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResourcesmore ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesmore ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_7.txt": "{\n  \"file\": \"76_7.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreResourcesStream ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesStream ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_8.txt": "{\n  \"file\": \"76_8.txt\",\n  \"assertion\": \"assertTrue ( adapter. input has moreStreamResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreamResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "76_9.txt": "{\n  \"file\": \"76_9.txt\",\n  \"assertion\": \"assertTrue ( adapter. inputMore moreResourcesResources ( ) )\\r\\n\",\n  \"test\": \"class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreResourcesResources ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\\u003d null ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( adapter. getHasMoreStreams ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "77_0.txt": "{\n  \"file\": \"77_0.txt\",\n  \"assertion\": \"assertEquals ( languages, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_1.txt": "{\n  \"file\": \"77_1.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( \\\"\\\", languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_10.txt": "{\n  \"file\": \"77_10.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", 2 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( \\\"\\\", 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_11.txt": "{\n  \"file\": \"77_11.txt\",\n  \"assertion\": \"assertEquals ( 2, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 2, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_12.txt": "{\n  \"file\": \"77_12.txt\",\n  \"assertion\": \"assertEquals ( 2, 2 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 2, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_13.txt": "{\n  \"file\": \"77_13.txt\",\n  \"assertion\": \"assertEquals ( 4, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 4, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_14.txt": "{\n  \"file\": \"77_14.txt\",\n  \"assertion\": \"assertEquals ( languages, 4 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_15.txt": "{\n  \"file\": \"77_15.txt\",\n  \"assertion\": \"assertEquals ( English, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( English, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"English\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_16.txt": "{\n  \"file\": \"77_16.txt\",\n  \"assertion\": \"assertEquals ( languages, English )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, English ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"English\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_17.txt": "{\n  \"file\": \"77_17.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", 1 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( \\\"\\\", 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_18.txt": "{\n  \"file\": \"77_18.txt\",\n  \"assertion\": \"assertEquals ( 1, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 1, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_19.txt": "{\n  \"file\": \"77_19.txt\",\n  \"assertion\": \"assertEquals ( 1, 2 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 1, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_2.txt": "{\n  \"file\": \"77_2.txt\",\n  \"assertion\": \"assertEquals ( languages, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_20.txt": "{\n  \"file\": \"77_20.txt\",\n  \"assertion\": \"assertEquals ( 2, 1 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 2, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_21.txt": "{\n  \"file\": \"77_21.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", 3 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( \\\"\\\", 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_22.txt": "{\n  \"file\": \"77_22.txt\",\n  \"assertion\": \"assertEquals ( 3, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 3, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_23.txt": "{\n  \"file\": \"77_23.txt\",\n  \"assertion\": \"assertEquals ( 3, 2 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 3, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_24.txt": "{\n  \"file\": \"77_24.txt\",\n  \"assertion\": \"assertEquals ( 2, 3 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 2, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_25.txt": "{\n  \"file\": \"77_25.txt\",\n  \"assertion\": \"assertEquals ( null, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( null, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_26.txt": "{\n  \"file\": \"77_26.txt\",\n  \"assertion\": \"assertEquals ( languages, null )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_27.txt": "{\n  \"file\": \"77_27.txt\",\n  \"assertion\": \"assertEquals ( expected, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( expected, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_28.txt": "{\n  \"file\": \"77_28.txt\",\n  \"assertion\": \"assertEquals ( languages, expected )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_29.txt": "{\n  \"file\": \"77_29.txt\",\n  \"assertion\": \"assertEquals ( true, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( true, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_3.txt": "{\n  \"file\": \"77_3.txt\",\n  \"assertion\": \"assertEquals ( 2, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 2, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_4.txt": "{\n  \"file\": \"77_4.txt\",\n  \"assertion\": \"assertEquals ( languages, 2 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_5.txt": "{\n  \"file\": \"77_5.txt\",\n  \"assertion\": \"assertEquals ( 1, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 1, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_6.txt": "{\n  \"file\": \"77_6.txt\",\n  \"assertion\": \"assertEquals ( languages, 1 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_7.txt": "{\n  \"file\": \"77_7.txt\",\n  \"assertion\": \"assertEquals ( 3, languages )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( 3, languages ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_8.txt": "{\n  \"file\": \"77_8.txt\",\n  \"assertion\": \"assertEquals ( languages, 3 )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( languages, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"languages\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "77_9.txt": "{\n  \"file\": \"77_9.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \\\"title:\\\\\\\"paris\\u003csp\\u003eberlin\\\\\\\"\\\" , getLanguageList ( true ) ) ; assertEquals ( \\\"\\\", \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \\u003c String \\u003e languages \\u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \\\"da\\\" ) ; languages . add ( \\\"de\\\" ) ; languages . add ( \\\"fr\\\" ) ; languages . add ( \\\"ga\\\" ) ; languages . add ( \\\"it\\\" ) ; languages . add ( \\\"nl\\\" ) ; return languages ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 1, 1 )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "78_0.txt": "{\n  \"file\": \"78_0.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_1.txt": "{\n  \"file\": \"78_1.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_10.txt": "{\n  \"file\": \"78_10.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, h1 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, h1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_11.txt": "{\n  \"file\": \"78_11.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, 11 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, 11 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_12.txt": "{\n  \"file\": \"78_12.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, 11 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, 11 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_13.txt": "{\n  \"file\": \"78_13.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, h_ 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h_ 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_14.txt": "{\n  \"file\": \"78_14.txt\",\n  \"assertion\": \"assertEquals ( h_ 1, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h_ 1, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_15.txt": "{\n  \"file\": \"78_15.txt\",\n  \"assertion\": \"assertEquals ( he ( 1, h1 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, h1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_16.txt": "{\n  \"file\": \"78_16.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, he1 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, he1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_17.txt": "{\n  \"file\": \"78_17.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, h_ 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, h_ 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_18.txt": "{\n  \"file\": \"78_18.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, 1_ 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, 1_ 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_19.txt": "{\n  \"file\": \"78_19.txt\",\n  \"assertion\": \"assertEquals ( 1_ 1, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1_ 1, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_2.txt": "{\n  \"file\": \"78_2.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, 1 ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, 1 ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_20.txt": "{\n  \"file\": \"78_20.txt\",\n  \"assertion\": \"assertEquals ( h_ 1, 1 ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h_ 1, 1 ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_21.txt": "{\n  \"file\": \"78_21.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, he1 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, he1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_22.txt": "{\n  \"file\": \"78_22.txt\",\n  \"assertion\": \"assertEquals ( he ( 1, 11 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, 11 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_23.txt": "{\n  \"file\": \"78_23.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, 1_ 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, 1_ 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_24.txt": "{\n  \"file\": \"78_24.txt\",\n  \"assertion\": \"assertEquals ( 1_ 1, 1 ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1_ 1, 1 ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_25.txt": "{\n  \"file\": \"78_25.txt\",\n  \"assertion\": \"assertEquals ( bet ( 1, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( bet ( 1, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_26.txt": "{\n  \"file\": \"78_26.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, bet ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, bet ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_27.txt": "{\n  \"file\": \"78_27.txt\",\n  \"assertion\": \"assertEquals ( h ( true, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( true, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_28.txt": "{\n  \"file\": \"78_28.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, h ( true )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h ( true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_29.txt": "{\n  \"file\": \"78_29.txt\",\n  \"assertion\": \"assertEquals ( bet ( 1, 1 ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( bet ( 1, 1 ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_3.txt": "{\n  \"file\": \"78_3.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, 1 ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, 1 ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_4.txt": "{\n  \"file\": \"78_4.txt\",\n  \"assertion\": \"assertEquals ( he ( 1, h ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, h ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_5.txt": "{\n  \"file\": \"78_5.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, he ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, he ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_6.txt": "{\n  \"file\": \"78_6.txt\",\n  \"assertion\": \"assertEquals ( 1 ( 1, he ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, he ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_7.txt": "{\n  \"file\": \"78_7.txt\",\n  \"assertion\": \"assertEquals ( he ( 1, 1 ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, 1 ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_8.txt": "{\n  \"file\": \"78_8.txt\",\n  \"assertion\": \"assertEquals ( he ( 1, he ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, he ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "78_9.txt": "{\n  \"file\": \"78_9.txt\",\n  \"assertion\": \"assertEquals ( h ( 1, h1 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \\u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \\u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \\u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \\u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\\u003d persoonHisVolledig ) { partnerPersoon \\u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \\u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h1 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( partnerPersoon, resultaat )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "79_0.txt": "{\n  \"file\": \"79_0.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_1.txt": "{\n  \"file\": \"79_1.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_10.txt": "{\n  \"file\": \"79_10.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. count ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. count ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.count()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_11.txt": "{\n  \"file\": \"79_11.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.length()) \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_12.txt": "{\n  \"file\": \"79_12.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.size()) \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_13.txt": "{\n  \"file\": \"79_13.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 3 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 3 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 3)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_14.txt": "{\n  \"file\": \"79_14.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d size ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d size ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.length()) \\\\u003d\\\\u003d size)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_15.txt": "{\n  \"file\": \"79_15.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d size ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d size ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.size()) \\\\u003d\\\\u003d size)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_16.txt": "{\n  \"file\": \"79_16.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. container ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. container ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.container()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_17.txt": "{\n  \"file\": \"79_17.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 4 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 4 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 4)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_18.txt": "{\n  \"file\": \"79_18.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. number ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. number ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.number()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_19.txt": "{\n  \"file\": \"79_19.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "79_2.txt": "{\n  \"file\": \"79_2.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d size ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d size ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d size)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_20.txt": "{\n  \"file\": \"79_20.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.length()) \\\\u003d\\\\u003d 1)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_21.txt": "{\n  \"file\": \"79_21.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. next ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. next ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.next()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_22.txt": "{\n  \"file\": \"79_22.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.size()) \\\\u003d\\\\u003d 1)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_23.txt": "{\n  \"file\": \"79_23.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d size ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d size ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "79_24.txt": "{\n  \"file\": \"79_24.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d null ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d null ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.length()) \\\\u003d\\\\u003d null)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_25.txt": "{\n  \"file\": \"79_25.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d null ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d null ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.size()) \\\\u003d\\\\u003d null)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_26.txt": "{\n  \"file\": \"79_26.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "79_27.txt": "{\n  \"file\": \"79_27.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 5 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 5 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 5)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_28.txt": "{\n  \"file\": \"79_28.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 200 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 200 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 200)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_29.txt": "{\n  \"file\": \"79_29.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. count ( ) ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. count ( ) ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.count()) \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_3.txt": "{\n  \"file\": \"79_3.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 1)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_4.txt": "{\n  \"file\": \"79_4.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d null ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d null ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d null)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_5.txt": "{\n  \"file\": \"79_5.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.length()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_6.txt": "{\n  \"file\": \"79_6.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.size()) \\\\u003d\\\\u003d time)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_7.txt": "{\n  \"file\": \"79_7.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d time ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \\u003d\\u003d time ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "79_8.txt": "{\n  \"file\": \"79_8.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d 2)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "79_9.txt": "{\n  \"file\": \"79_9.txt\",\n  \"assertion\": \"assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d one ) )\\r\\n\",\n  \"test\": \"class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \\u003d new LocalTimeField ( ) ; LocalTime time \\u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \\u003d em . insert ( entity ) ; String query \\u003d \\\"SELECT\\u003csp\\u003e*\\u003csp\\u003eFROM\\u003csp\\u003eLocalTimeField\\u003csp\\u003eWHERE\\u003csp\\u003estartTime\\u003d@Time\\\" ; EntityQueryRequest request \\u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \\\"Time\\\" , time ) ; catatumbo . QueryResponse \\u003c LocalTimeField \\u003e response \\u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \\u003c LocalTimeField \\u003e entities \\u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \\u003d\\u003d one ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return map . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( entities. size ( ) ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((response.index()) \\\\u003d\\\\u003d one)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_0.txt": "{\n  \"file\": \"7_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_1.txt": "{\n  \"file\": \"7_1.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_10.txt": "{\n  \"file\": \"7_10.txt\",\n  \"assertion\": \"assertEquals ( expected, 2 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_11.txt": "{\n  \"file\": \"7_11.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_12.txt": "{\n  \"file\": \"7_12.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_13.txt": "{\n  \"file\": \"7_13.txt\",\n  \"assertion\": \"assertEquals ( 20, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 20, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"20\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_14.txt": "{\n  \"file\": \"7_14.txt\",\n  \"assertion\": \"assertEquals ( expected, 20 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 20 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"20\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_15.txt": "{\n  \"file\": \"7_15.txt\",\n  \"assertion\": \"assertEquals ( 3, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 3, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_16.txt": "{\n  \"file\": \"7_16.txt\",\n  \"assertion\": \"assertEquals ( expected, 3 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_17.txt": "{\n  \"file\": \"7_17.txt\",\n  \"assertion\": \"assertEquals ( 5, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 5, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"5\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_18.txt": "{\n  \"file\": \"7_18.txt\",\n  \"assertion\": \"assertEquals ( expected, 5 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"5\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_19.txt": "{\n  \"file\": \"7_19.txt\",\n  \"assertion\": \"assertEquals ( 6, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 6, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"6\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_2.txt": "{\n  \"file\": \"7_2.txt\",\n  \"assertion\": \"assertEquals ( expected, 10 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_20.txt": "{\n  \"file\": \"7_20.txt\",\n  \"assertion\": \"assertEquals ( expected, 6 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 6 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"6\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_21.txt": "{\n  \"file\": \"7_21.txt\",\n  \"assertion\": \"assertEquals ( 4, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 4, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_22.txt": "{\n  \"file\": \"7_22.txt\",\n  \"assertion\": \"assertEquals ( expected, 4 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"4\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_23.txt": "{\n  \"file\": \"7_23.txt\",\n  \"assertion\": \"assertEquals (pected, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals (pected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_24.txt": "{\n  \"file\": \"7_24.txt\",\n  \"assertion\": \"assertEquals ( expected,pected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected,pected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"pected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_25.txt": "{\n  \"file\": \"7_25.txt\",\n  \"assertion\": \"assertEquals ( true, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( true, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_26.txt": "{\n  \"file\": \"7_26.txt\",\n  \"assertion\": \"assertEquals ( expected, true )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_27.txt": "{\n  \"file\": \"7_27.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_28.txt": "{\n  \"file\": \"7_28.txt\",\n  \"assertion\": \"assertEquals ( 200, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 200, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"200\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_29.txt": "{\n  \"file\": \"7_29.txt\",\n  \"assertion\": \"assertEquals ( expected, 200 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 200 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"200\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_3.txt": "{\n  \"file\": \"7_3.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_4.txt": "{\n  \"file\": \"7_4.txt\",\n  \"assertion\": \"assertEquals ( expected, 0 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_5.txt": "{\n  \"file\": \"7_5.txt\",\n  \"assertion\": \"assertEquals ( 1, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 1, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_6.txt": "{\n  \"file\": \"7_6.txt\",\n  \"assertion\": \"assertEquals ( expected, 1 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_7.txt": "{\n  \"file\": \"7_7.txt\",\n  \"assertion\": \"assertEquals ( 8, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 8, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_8.txt": "{\n  \"file\": \"7_8.txt\",\n  \"assertion\": \"assertEquals ( expected, 8 )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 8 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "7_9.txt": "{\n  \"file\": \"7_9.txt\",\n  \"assertion\": \"assertEquals ( 2, expected )\\r\\n\",\n  \"test\": \"class X {public void testFindTop ( ) { SimilarityStrategy strategy \\u003d mock ( SimilarityStrategy . class ) ; String target \\u003d \\\"McDonalds\\\" ; String c1 \\u003d \\\"MacMahons\\\" ; String c2 \\u003d \\\"McPherson\\\" ; String c3 \\u003d \\\"McDonalds\\\" ; SimilarityScore expected \\u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \\u003d new StringSimilarityServiceImpl ( strategy ) ; List \\u003c String \\u003e features \\u003d new ArrayList \\u003c String \\u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \\u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 2, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \\u003e ( second . length ( ) ) ) { longer \\u003d first . toLowerCase ( ) ; shorter \\u003d second . toLowerCase ( ) ; } else { longer \\u003d second . toLowerCase ( ) ; shorter \\u003d first . toLowerCase ( ) ; } int halflength \\u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \\u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \\u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \\u003d\\u003d 0 ) || ( ( m2 . length ( ) ) \\u003d\\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \\u003d transpositions ( m1 , m2 ) ; double dist \\u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, top )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"SimilarityScore\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "80_0.txt": "{\n  \"file\": \"80_0.txt\",\n  \"assertion\": \"assertNull ( bias, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_1.txt": "{\n  \"file\": \"80_1.txt\",\n  \"assertion\": \"assertNull ( res, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( res, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_10.txt": "{\n  \"file\": \"80_10.txt\",\n  \"assertion\": \"assertNull ( bias, activation )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, activation ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_11.txt": "{\n  \"file\": \"80_11.txt\",\n  \"assertion\": \"assertNull ( \\\"\\\", bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( \\\"\\\", bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_12.txt": "{\n  \"file\": \"80_12.txt\",\n  \"assertion\": \"assertNull ( bias, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_13.txt": "{\n  \"file\": \"80_13.txt\",\n  \"assertion\": \"assertNull ( biases, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( biases, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_14.txt": "{\n  \"file\": \"80_14.txt\",\n  \"assertion\": \"assertNull ( bias, biases )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, biases ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_15.txt": "{\n  \"file\": \"80_15.txt\",\n  \"assertion\": \"assertNull ( true, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( true, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_16.txt": "{\n  \"file\": \"80_16.txt\",\n  \"assertion\": \"assertNull ( bias, true )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_17.txt": "{\n  \"file\": \"80_17.txt\",\n  \"assertion\": \"assertNull ( res, res )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( res, res ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_18.txt": "{\n  \"file\": \"80_18.txt\",\n  \"assertion\": \"assertNull ( penalty, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( penalty, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_19.txt": "{\n  \"file\": \"80_19.txt\",\n  \"assertion\": \"assertNull ( bias, penalty )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, penalty ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_2.txt": "{\n  \"file\": \"80_2.txt\",\n  \"assertion\": \"assertNull ( bias, res )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, res ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_20.txt": "{\n  \"file\": \"80_20.txt\",\n  \"assertion\": \"assertNull ( 0, res )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 0, res ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_21.txt": "{\n  \"file\": \"80_21.txt\",\n  \"assertion\": \"assertNull ( res, 0 )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( res, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_22.txt": "{\n  \"file\": \"80_22.txt\",\n  \"assertion\": \"assertNull ( false, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( false, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_23.txt": "{\n  \"file\": \"80_23.txt\",\n  \"assertion\": \"assertNull ( bias, false )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, false ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_24.txt": "{\n  \"file\": \"80_24.txt\",\n  \"assertion\": \"assertNull ( sensitivity, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( sensitivity, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_25.txt": "{\n  \"file\": \"80_25.txt\",\n  \"assertion\": \"assertNull ( bias, sensitivity )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, sensitivity ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_26.txt": "{\n  \"file\": \"80_26.txt\",\n  \"assertion\": \"assertNull ( 0, 0 )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 0, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_27.txt": "{\n  \"file\": \"80_27.txt\",\n  \"assertion\": \"assertNull ( loss, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( loss, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_28.txt": "{\n  \"file\": \"80_28.txt\",\n  \"assertion\": \"assertNull ( 4, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 4, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_29.txt": "{\n  \"file\": \"80_29.txt\",\n  \"assertion\": \"assertNull ( bias, 4 )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_3.txt": "{\n  \"file\": \"80_3.txt\",\n  \"assertion\": \"assertNull ( 0, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 0, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_4.txt": "{\n  \"file\": \"80_4.txt\",\n  \"assertion\": \"assertNull ( bias, 0 )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_5.txt": "{\n  \"file\": \"80_5.txt\",\n  \"assertion\": \"assertNull ( null, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( null, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_6.txt": "{\n  \"file\": \"80_6.txt\",\n  \"assertion\": \"assertNull ( bias, null )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_7.txt": "{\n  \"file\": \"80_7.txt\",\n  \"assertion\": \"assertNull ( 1, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 1, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_8.txt": "{\n  \"file\": \"80_8.txt\",\n  \"assertion\": \"assertNull ( bias, 1 )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "80_9.txt": "{\n  \"file\": \"80_9.txt\",\n  \"assertion\": \"assertNull ( activation, bias )\\r\\n\",\n  \"test\": \"class X {public void testLayerNormNoDeviation ( ) { final INDArray random \\u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \\u003d 0 ; i \\u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \\u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \\u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \\u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \\u003d res . norm1 ( ) ; final int [ ] axis \\u003d new int [ ] { 1 } ; SameDiff sd \\u003d SameDiff . create ( ) ; SDVariable sdInput \\u003d sd . var ( \\\"input\\\" , standardized ) ; SDVariable sdGain \\u003d sd . var ( \\\"gain\\\" , gain ) ; SDVariable sdBias \\u003d sd . var ( \\\"bias\\\" , bias ) ; SDVariable out \\u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \\\"out\\\" ) ; String err \\u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \\\"out\\\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \\\"input\\\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( activation, bias ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertNull ( err, err )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "81_0.txt": "Unknown assertion type",
  "81_1.txt": "Unknown assertion type",
  "81_10.txt": "Unknown assertion type",
  "81_11.txt": "Unknown assertion type",
  "81_12.txt": "Unknown assertion type",
  "81_13.txt": "Unknown assertion type",
  "81_14.txt": "Unknown assertion type",
  "81_15.txt": "Unknown assertion type",
  "81_16.txt": "Unknown assertion type",
  "81_17.txt": "Unknown assertion type",
  "81_18.txt": "Unknown assertion type",
  "81_19.txt": "Unknown assertion type",
  "81_2.txt": "Unknown assertion type",
  "81_20.txt": "Unknown assertion type",
  "81_21.txt": "Unknown assertion type",
  "81_22.txt": "Unknown assertion type",
  "81_23.txt": "Unknown assertion type",
  "81_24.txt": "Unknown assertion type",
  "81_25.txt": "Unknown assertion type",
  "81_26.txt": "Unknown assertion type",
  "81_27.txt": "Unknown assertion type",
  "81_28.txt": "Unknown assertion type",
  "81_29.txt": "Unknown assertion type",
  "81_3.txt": "Unknown assertion type",
  "81_4.txt": "Unknown assertion type",
  "81_5.txt": "Unknown assertion type",
  "81_6.txt": "Unknown assertion type",
  "81_7.txt": "Unknown assertion type",
  "81_8.txt": "Unknown assertion type",
  "81_9.txt": "Unknown assertion type",
  "82_0.txt": "{\n  \"file\": \"82_0.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 0, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_1.txt": "{\n  \"file\": \"82_1.txt\",\n  \"assertion\": \"assertEquals ( 1, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 1, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_10.txt": "{\n  \"file\": \"82_10.txt\",\n  \"assertion\": \"assertEquals ( 9, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 9, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_11.txt": "{\n  \"file\": \"82_11.txt\",\n  \"assertion\": \"assertEquals ( 1, false. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 1, false. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_12.txt": "{\n  \"file\": \"82_12.txt\",\n  \"assertion\": \"assertEquals ( index, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( index, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_13.txt": "{\n  \"file\": \"82_13.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. index ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 0, 0. index ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_14.txt": "{\n  \"file\": \"82_14.txt\",\n  \"assertion\": \"assertEquals ( 8, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 8, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_15.txt": "{\n  \"file\": \"82_15.txt\",\n  \"assertion\": \"assertEquals ( null, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( null, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_16.txt": "{\n  \"file\": \"82_16.txt\",\n  \"assertion\": \"assertEquals ( 0, null. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 0, null. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_17.txt": "{\n  \"file\": \"82_17.txt\",\n  \"assertion\": \"assertEquals ( 10, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 10, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_18.txt": "{\n  \"file\": \"82_18.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. count ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 0, 0. count ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_19.txt": "{\n  \"file\": \"82_19.txt\",\n  \"assertion\": \"assertEquals ( count, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( count, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_2.txt": "{\n  \"file\": \"82_2.txt\",\n  \"assertion\": \"assertEquals ( 2, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 2, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_20.txt": "{\n  \"file\": \"82_20.txt\",\n  \"assertion\": \"assertEquals ( 16, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 16, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_21.txt": "{\n  \"file\": \"82_21.txt\",\n  \"assertion\": \"assertEquals ( 20, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 20, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_22.txt": "{\n  \"file\": \"82_22.txt\",\n  \"assertion\": \"assertEquals ( 0, 0. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 0, 0. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_23.txt": "{\n  \"file\": \"82_23.txt\",\n  \"assertion\": \"assertEquals ( size, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( size, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_24.txt": "{\n  \"file\": \"82_24.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( \\\"\\\", 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_25.txt": "{\n  \"file\": \"82_25.txt\",\n  \"assertion\": \"assertEquals ( 12, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 12, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_26.txt": "{\n  \"file\": \"82_26.txt\",\n  \"assertion\": \"assertEquals ( 100, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 100, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_27.txt": "{\n  \"file\": \"82_27.txt\",\n  \"assertion\": \"assertEquals ( 1000, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 1000, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_28.txt": "{\n  \"file\": \"82_28.txt\",\n  \"assertion\": \"assertEquals ( 2, false. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 2, false. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_29.txt": "{\n  \"file\": \"82_29.txt\",\n  \"assertion\": \"assertEquals (0, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals (0, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_3.txt": "{\n  \"file\": \"82_3.txt\",\n  \"assertion\": \"assertEquals ( 0, false. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 0, false. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_4.txt": "{\n  \"file\": \"82_4.txt\",\n  \"assertion\": \"assertEquals ( false, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( false, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_5.txt": "{\n  \"file\": \"82_5.txt\",\n  \"assertion\": \"assertEquals ( 3, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 3, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_6.txt": "{\n  \"file\": \"82_6.txt\",\n  \"assertion\": \"assertEquals ( 4, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 4, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_7.txt": "{\n  \"file\": \"82_7.txt\",\n  \"assertion\": \"assertEquals ( 5, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 5, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_8.txt": "{\n  \"file\": \"82_8.txt\",\n  \"assertion\": \"assertEquals ( 6, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 6, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "82_9.txt": "{\n  \"file\": \"82_9.txt\",\n  \"assertion\": \"assertEquals ( 7, 0. 0 ( ) )\\r\\n\",\n  \"test\": \"class X {public void falseBody ( ) { List \\u003c Annotation \\u003e list \\u003d queryService . addCriteria ( \\\"oa:hasBody/ex:languageValue[@es]\\\" ) . execute ( ) ; assertEquals ( 7, 0. 0 ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { try { if ( ( _size ) \\u003c 0 ) { synchronized ( this ) { if ( ( _size ) \\u003c 0 ) { int index \\u003d findSize ( ) ; _size \\u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, list. size ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_0.txt": "{\n  \"file\": \"83_0.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_1.txt": "{\n  \"file\": \"83_1.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_10.txt": "{\n  \"file\": \"83_10.txt\",\n  \"assertion\": \"assertEquals ( \\\" result 1, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result 1, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_11.txt": "{\n  \"file\": \"83_11.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" null null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" null null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_12.txt": "{\n  \"file\": \"83_12.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" result 1 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" result 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_13.txt": "{\n  \"file\": \"83_13.txt\",\n  \"assertion\": \"assertEquals ( \\\" result 1, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result 1, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_14.txt": "{\n  \"file\": \"83_14.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( 2, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( 2, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_15.txt": "{\n  \"file\": \"83_15.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" ( 2 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" ( 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_16.txt": "{\n  \"file\": \"83_16.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null,\\u0027( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null,\\u0027( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_17.txt": "{\n  \"file\": \"83_17.txt\",\n  \"assertion\": \"assertEquals (\\u0027( null, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals (\\u0027( null, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_18.txt": "{\n  \"file\": \"83_18.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( 2, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( 2, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_19.txt": "{\n  \"file\": \"83_19.txt\",\n  \"assertion\": \"assertEquals ( \\\" result 2, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result 2, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_2.txt": "{\n  \"file\": \"83_2.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_20.txt": "{\n  \"file\": \"83_20.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" result 2 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" result 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_21.txt": "{\n  \"file\": \"83_21.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" ( 2 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" ( 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_22.txt": "{\n  \"file\": \"83_22.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( 0, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( 0, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_23.txt": "{\n  \"file\": \"83_23.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" ( 0 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_24.txt": "{\n  \"file\": \"83_24.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null,\\u0027result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null,\\u0027result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_25.txt": "{\n  \"file\": \"83_25.txt\",\n  \"assertion\": \"assertEquals (\\u0027( null, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals (\\u0027( null, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_26.txt": "{\n  \"file\": \"83_26.txt\",\n  \"assertion\": \"assertEquals (\\u0027result null, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals (\\u0027result null, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_27.txt": "{\n  \"file\": \"83_27.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null,\\u0027( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null,\\u0027( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_28.txt": "{\n  \"file\": \"83_28.txt\",\n  \"assertion\": \"assertEquals ( \\\" result 2, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result 2, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_29.txt": "{\n  \"file\": \"83_29.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" result 2 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" result 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_3.txt": "{\n  \"file\": \"83_3.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_4.txt": "{\n  \"file\": \"83_4.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_5.txt": "{\n  \"file\": \"83_5.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( 1, \\\" ( null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( 1, \\\" ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_6.txt": "{\n  \"file\": \"83_6.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" null null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" null null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_7.txt": "{\n  \"file\": \"83_7.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( null, \\\" result 1 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( null, \\\" result 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_8.txt": "{\n  \"file\": \"83_8.txt\",\n  \"assertion\": \"assertEquals ( \\\" result null, \\\" ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" result null, \\\" ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "83_9.txt": "{\n  \"file\": \"83_9.txt\",\n  \"assertion\": \"assertEquals ( \\\" ( 1, \\\" result null )\\r\\n\",\n  \"test\": \"class X {public void testSearchReusesNoParams ( ) { List \\u003c IBaseResource \\u003e resources \\u003d new ArrayList ( ) ; for ( int i \\u003d 0 ; i \\u003c 50 ; i ++ ) { Organization org \\u003d new Organization ( ) ; org . setName ( \\\"HELLO\\\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \\u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \\u003d ourClient . search ( ) . forResource ( \\\"Organization\\\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \\u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \\\" ( 1, \\\" result null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \\u003d theBundle . getLink ( \\\"next\\\" ) . getUrl ( ) ; linkNext \\u003d linkNext . substring ( linkNext . indexOf ( \\u0027?\\u0027 ) ) ; Map \\u003c String , String [ ] \\u003e params \\u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \\u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \\u003d uuidParams [ 0 ] ; return uuid ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( uuid1, uuid2 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "84_0.txt": "{\n  \"file\": \"84_0.txt\",\n  \"assertion\": \"assertEquals ( msg, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_1.txt": "{\n  \"file\": \"84_1.txt\",\n  \"assertion\": \"assertEquals ( msg, result )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "84_10.txt": "{\n  \"file\": \"84_10.txt\",\n  \"assertion\": \"assertEquals ( message, result )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( message, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"message\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_11.txt": "{\n  \"file\": \"84_11.txt\",\n  \"assertion\": \"assertEquals ( result, message )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, message ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"message\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_12.txt": "{\n  \"file\": \"84_12.txt\",\n  \"assertion\": \"assertEquals ( 0, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( 0, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_13.txt": "{\n  \"file\": \"84_13.txt\",\n  \"assertion\": \"assertEquals ( msg, 0 )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_14.txt": "{\n  \"file\": \"84_14.txt\",\n  \"assertion\": \"assertEquals (msg, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals (msg, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_15.txt": "{\n  \"file\": \"84_15.txt\",\n  \"assertion\": \"assertEquals ( msg,msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg,msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_16.txt": "{\n  \"file\": \"84_16.txt\",\n  \"assertion\": \"assertEquals ( out, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( out, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"out\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_17.txt": "{\n  \"file\": \"84_17.txt\",\n  \"assertion\": \"assertEquals ( msg, out )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, out ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"out\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_18.txt": "{\n  \"file\": \"84_18.txt\",\n  \"assertion\": \"assertEquals ( expected, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( expected, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_19.txt": "{\n  \"file\": \"84_19.txt\",\n  \"assertion\": \"assertEquals ( msg, expected )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_2.txt": "{\n  \"file\": \"84_2.txt\",\n  \"assertion\": \"assertEquals ( result, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "84_20.txt": "{\n  \"file\": \"84_20.txt\",\n  \"assertion\": \"assertEquals ( true, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( true, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_21.txt": "{\n  \"file\": \"84_21.txt\",\n  \"assertion\": \"assertEquals ( msg, true )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_22.txt": "{\n  \"file\": \"84_22.txt\",\n  \"assertion\": \"assertEquals ( ch, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( ch, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"ch\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_23.txt": "{\n  \"file\": \"84_23.txt\",\n  \"assertion\": \"assertEquals ( msg, ch )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, ch ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"ch\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_24.txt": "{\n  \"file\": \"84_24.txt\",\n  \"assertion\": \"assertEquals ( 1, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( 1, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_25.txt": "{\n  \"file\": \"84_25.txt\",\n  \"assertion\": \"assertEquals ( msg, 1 )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_26.txt": "{\n  \"file\": \"84_26.txt\",\n  \"assertion\": \"assertEquals ( reply, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( reply, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"reply\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_27.txt": "{\n  \"file\": \"84_27.txt\",\n  \"assertion\": \"assertEquals ( msg, reply )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, reply ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"reply\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_28.txt": "{\n  \"file\": \"84_28.txt\",\n  \"assertion\": \"assertEquals ( session, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( session, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"session\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"long\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"incompatible type\"\n}",
  "84_29.txt": "{\n  \"file\": \"84_29.txt\",\n  \"assertion\": \"assertEquals ( msg, session )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, session ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"session\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"session\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"long\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"incompatible type\"\n}",
  "84_3.txt": "{\n  \"file\": \"84_3.txt\",\n  \"assertion\": \"assertEquals ( result, result )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_4.txt": "{\n  \"file\": \"84_4.txt\",\n  \"assertion\": \"assertEquals ( null, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( null, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_5.txt": "{\n  \"file\": \"84_5.txt\",\n  \"assertion\": \"assertEquals ( msg, null )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_6.txt": "{\n  \"file\": \"84_6.txt\",\n  \"assertion\": \"assertEquals ( null, result )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( null, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_7.txt": "{\n  \"file\": \"84_7.txt\",\n  \"assertion\": \"assertEquals ( result, null )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_8.txt": "{\n  \"file\": \"84_8.txt\",\n  \"assertion\": \"assertEquals ( message, msg )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( message, msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"message\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "84_9.txt": "{\n  \"file\": \"84_9.txt\",\n  \"assertion\": \"assertEquals ( msg, message )\\r\\n\",\n  \"test\": \"class X {public void readChokeMessage ( ) { long session \\u003d 1L ; Message msg \\u003d Messages . choke ( session ) ; byte [ ] bytes \\u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \\u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, message ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( msg, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"msg\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Message\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"message\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_0.txt": "{\n  \"file\": \"85_0.txt\",\n  \"assertion\": \"assertNull ( mp )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"mp\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"MarketplaceHistory\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "85_1.txt": "{\n  \"file\": \"85_1.txt\",\n  \"assertion\": \"assertNull ( MP )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( MP ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"MP\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_10.txt": "{\n  \"file\": \"85_10.txt\",\n  \"assertion\": \"assertNull ( sp )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( sp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"sp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_11.txt": "{\n  \"file\": \"85_11.txt\",\n  \"assertion\": \"assertNull ( me )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( me ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"me\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_12.txt": "{\n  \"file\": \"85_12.txt\",\n  \"assertion\": \"assertNull ( pipe )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pipe ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"pipe\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_13.txt": "{\n  \"file\": \"85_13.txt\",\n  \"assertion\": \"assertNull ( msg )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( msg ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"msg\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_14.txt": "{\n  \"file\": \"85_14.txt\",\n  \"assertion\": \"assertNull ( pm )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pm ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"pm\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_15.txt": "{\n  \"file\": \"85_15.txt\",\n  \"assertion\": \"assertNull ( pup )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pup ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"pup\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_16.txt": "{\n  \"file\": \"85_16.txt\",\n  \"assertion\": \"assertNull ( m )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( m ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"m\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_17.txt": "{\n  \"file\": \"85_17.txt\",\n  \"assertion\": \"assertNull ( dc )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( dc ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"dc\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_18.txt": "{\n  \"file\": \"85_18.txt\",\n  \"assertion\": \"assertNull ( subp )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( subp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"subp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_19.txt": "{\n  \"file\": \"85_19.txt\",\n  \"assertion\": \"assertNull ( cap )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( cap ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"cap\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_2.txt": "{\n  \"file\": \"85_2.txt\",\n  \"assertion\": \"assertNull ( null )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_20.txt": "{\n  \"file\": \"85_20.txt\",\n  \"assertion\": \"assertNull ( ma )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ma ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ma\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_21.txt": "{\n  \"file\": \"85_21.txt\",\n  \"assertion\": \"assertNull ( poll )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( poll ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"poll\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_22.txt": "{\n  \"file\": \"85_22.txt\",\n  \"assertion\": \"assertNull ( listening )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( listening ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"listening\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_23.txt": "{\n  \"file\": \"85_23.txt\",\n  \"assertion\": \"assertNull ( mute )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mute ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mute\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_24.txt": "{\n  \"file\": \"85_24.txt\",\n  \"assertion\": \"assertNull ( sip )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( sip ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"sip\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_25.txt": "{\n  \"file\": \"85_25.txt\",\n  \"assertion\": \"assertNull ( 0 )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_26.txt": "{\n  \"file\": \"85_26.txt\",\n  \"assertion\": \"assertNull ( pp )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"pp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_27.txt": "{\n  \"file\": \"85_27.txt\",\n  \"assertion\": \"assertNull ( mm )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mm ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mm\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_28.txt": "{\n  \"file\": \"85_28.txt\",\n  \"assertion\": \"assertNull ( ap )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ap ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ap\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_29.txt": "{\n  \"file\": \"85_29.txt\",\n  \"assertion\": \"assertNull ( ml )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ml ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ml\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_3.txt": "{\n  \"file\": \"85_3.txt\",\n  \"assertion\": \"assertNull (mp )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull (mp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"mp\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"MarketplaceHistory\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "85_4.txt": "{\n  \"file\": \"85_4.txt\",\n  \"assertion\": \"assertNull ( mc )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mc ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"mc\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_5.txt": "{\n  \"file\": \"85_5.txt\",\n  \"assertion\": \"assertNull ( multip )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( multip ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"multip\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_6.txt": "{\n  \"file\": \"85_6.txt\",\n  \"assertion\": \"assertNull ( ps )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ps ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ps\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_7.txt": "{\n  \"file\": \"85_7.txt\",\n  \"assertion\": \"assertNull ( ip )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ip ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ip\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_8.txt": "{\n  \"file\": \"85_8.txt\",\n  \"assertion\": \"assertNull ( cp )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( cp ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"cp\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "85_9.txt": "{\n  \"file\": \"85_9.txt\",\n  \"assertion\": \"assertNull ( pa )\\r\\n\",\n  \"test\": \"class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \\u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pa ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \\u003d dm . createNamedQuery ( \\\"MarketplaceHistory.findWithinPeriod\\\" ) ; query . Long . setParameter ( \\\"mpKey\\\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \\\"modDate\\\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\\r\\n\",\n  \"truth\": \"assertNull ( mp )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"pa\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "86_0.txt": "{\n  \"file\": \"86_0.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_1.txt": "{\n  \"file\": \"86_1.txt\",\n  \"assertion\": \"assertEquals ( 12, cells. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_10.txt": "{\n  \"file\": \"86_10.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. number ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. number ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"number\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_11.txt": "{\n  \"file\": \"86_11.txt\",\n  \"assertion\": \"assertEquals ( 12, doubles. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_12.txt": "{\n  \"file\": \"86_12.txt\",\n  \"assertion\": \"assertEquals ( 12, cells. number ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. number ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"number\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_13.txt": "{\n  \"file\": \"86_13.txt\",\n  \"assertion\": \"assertEquals ( 12, tiles. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "86_14.txt": "{\n  \"file\": \"86_14.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. numbers ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. numbers ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"numbers\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_15.txt": "{\n  \"file\": \"86_15.txt\",\n  \"assertion\": \"assertEquals ( 12, tiles. order ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. order ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"order\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_16.txt": "{\n  \"file\": \"86_16.txt\",\n  \"assertion\": \"assertEquals ( 12, phones. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "86_17.txt": "{\n  \"file\": \"86_17.txt\",\n  \"assertion\": \"assertEquals ( 12, tiles. cells ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. cells ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"cells\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_18.txt": "{\n  \"file\": \"86_18.txt\",\n  \"assertion\": \"assertEquals ( 12, cells. numbers ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. numbers ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"numbers\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_19.txt": "{\n  \"file\": \"86_19.txt\",\n  \"assertion\": \"assertEquals ( 12, doubles. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "86_2.txt": "{\n  \"file\": \"86_2.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "86_20.txt": "{\n  \"file\": \"86_20.txt\",\n  \"assertion\": \"assertEquals ( 12, keys. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, keys. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_21.txt": "{\n  \"file\": \"86_21.txt\",\n  \"assertion\": \"assertEquals ( 12, phones. order ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. order ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"order\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_22.txt": "{\n  \"file\": \"86_22.txt\",\n  \"assertion\": \"assertEquals ( 12, phones. cells ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. cells ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"cells\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_23.txt": "{\n  \"file\": \"86_23.txt\",\n  \"assertion\": \"assertEquals ( 12, maps. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, maps. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_24.txt": "{\n  \"file\": \"86_24.txt\",\n  \"assertion\": \"assertEquals ( 12, doubles. order ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. order ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"order\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_25.txt": "{\n  \"file\": \"86_25.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. elements ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. elements ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"elements\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_26.txt": "{\n  \"file\": \"86_26.txt\",\n  \"assertion\": \"assertEquals ( 12, results. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, results. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_27.txt": "{\n  \"file\": \"86_27.txt\",\n  \"assertion\": \"assertEquals ( 12, doubles. cells ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. cells ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"cells\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_28.txt": "{\n  \"file\": \"86_28.txt\",\n  \"assertion\": \"assertEquals ( 12, tiles. number ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. number ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"number\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_29.txt": "{\n  \"file\": \"86_29.txt\",\n  \"assertion\": \"assertEquals ( 12, ships. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, ships. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_3.txt": "{\n  \"file\": \"86_3.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. order ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. order ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"order\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_4.txt": "{\n  \"file\": \"86_4.txt\",\n  \"assertion\": \"assertEquals ( 12, cells. size ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. size ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, focal method\"\n}",
  "86_5.txt": "{\n  \"file\": \"86_5.txt\",\n  \"assertion\": \"assertEquals ( 12, pages. cells ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. cells ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"cells\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_6.txt": "{\n  \"file\": \"86_6.txt\",\n  \"assertion\": \"assertEquals ( 12, tiles. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_7.txt": "{\n  \"file\": \"86_7.txt\",\n  \"assertion\": \"assertEquals ( 12, cells. order ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. order ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"order\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_8.txt": "{\n  \"file\": \"86_8.txt\",\n  \"assertion\": \"assertEquals ( 12, cells. cells ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. cells ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"cells\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "86_9.txt": "{\n  \"file\": \"86_9.txt\",\n  \"assertion\": \"assertEquals ( 12, phones. seeds ( ) )\\r\\n\",\n  \"test\": \"class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \\u003d new VFMapper ( benzene , true ) ; util . List \\u003c Map \\u003c INode , IAtom \\u003e \\u003e maps \\u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. seeds ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return cells . size ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 12, maps. size ( ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"12\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"seeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "87_0.txt": "{\n  \"file\": \"87_0.txt\",\n  \"assertion\": \"assertEquals ( result, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_1.txt": "{\n  \"file\": \"87_1.txt\",\n  \"assertion\": \"assertEquals ( false, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( false, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"false\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_10.txt": "{\n  \"file\": \"87_10.txt\",\n  \"assertion\": \"assertEquals ( result, null )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_11.txt": "{\n  \"file\": \"87_11.txt\",\n  \"assertion\": \"assertEquals ( 0, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( 0, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_12.txt": "{\n  \"file\": \"87_12.txt\",\n  \"assertion\": \"assertEquals ( result, 0 )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_13.txt": "{\n  \"file\": \"87_13.txt\",\n  \"assertion\": \"assertEquals ( expected, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( expected, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_14.txt": "{\n  \"file\": \"87_14.txt\",\n  \"assertion\": \"assertEquals ( result, expected )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_15.txt": "{\n  \"file\": \"87_15.txt\",\n  \"assertion\": \"assertEquals ( value, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( value, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_16.txt": "{\n  \"file\": \"87_16.txt\",\n  \"assertion\": \"assertEquals ( result, value )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, value ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_17.txt": "{\n  \"file\": \"87_17.txt\",\n  \"assertion\": \"assertEquals ( return, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( return, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "87_18.txt": "{\n  \"file\": \"87_18.txt\",\n  \"assertion\": \"assertEquals ( result, return )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, return ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "87_19.txt": "{\n  \"file\": \"87_19.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( \\\"\\\", result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_2.txt": "{\n  \"file\": \"87_2.txt\",\n  \"assertion\": \"assertEquals ( result, false )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, false ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"false\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_20.txt": "{\n  \"file\": \"87_20.txt\",\n  \"assertion\": \"assertEquals ( result, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_21.txt": "{\n  \"file\": \"87_21.txt\",\n  \"assertion\": \"assertEquals ( Result, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( Result, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_22.txt": "{\n  \"file\": \"87_22.txt\",\n  \"assertion\": \"assertEquals ( result, Result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, Result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_23.txt": "{\n  \"file\": \"87_23.txt\",\n  \"assertion\": \"assertEquals ( results, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( results, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_24.txt": "{\n  \"file\": \"87_24.txt\",\n  \"assertion\": \"assertEquals ( result, results )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_25.txt": "{\n  \"file\": \"87_25.txt\",\n  \"assertion\": \"assertEquals ( rule, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( rule, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"rule\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_26.txt": "{\n  \"file\": \"87_26.txt\",\n  \"assertion\": \"assertEquals ( result, rule )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, rule ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"rule\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_27.txt": "{\n  \"file\": \"87_27.txt\",\n  \"assertion\": \"assertEquals ( answer, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( answer, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"answer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_28.txt": "{\n  \"file\": \"87_28.txt\",\n  \"assertion\": \"assertEquals ( result, answer )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, answer ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"answer\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_29.txt": "{\n  \"file\": \"87_29.txt\",\n  \"assertion\": \"assertEquals ( filter, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( filter, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"filter\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_3.txt": "{\n  \"file\": \"87_3.txt\",\n  \"assertion\": \"assertEquals ( true, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( true, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_4.txt": "{\n  \"file\": \"87_4.txt\",\n  \"assertion\": \"assertEquals ( result, true )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"true\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_5.txt": "{\n  \"file\": \"87_5.txt\",\n  \"assertion\": \"assertEquals (result, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals (result, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_6.txt": "{\n  \"file\": \"87_6.txt\",\n  \"assertion\": \"assertEquals ( result,result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result,result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_7.txt": "{\n  \"file\": \"87_7.txt\",\n  \"assertion\": \"assertEquals (Result, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals (Result, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_8.txt": "{\n  \"file\": \"87_8.txt\",\n  \"assertion\": \"assertEquals ( result,Result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result,Result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"Result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "87_9.txt": "{\n  \"file\": \"87_9.txt\",\n  \"assertion\": \"assertEquals ( null, result )\\r\\n\",\n  \"test\": \"class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \\u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \\u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \\u003d new FlipOffCondition ( ) ; boolean result \\u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( null, result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \\u003d flipAnnotationAttributes . getAttributeValue ( \\\"expression\\\" , \\\"\\\" ) ; ValidationUtils . requireNonEmpty ( expression , \\\"expression\\u003csp\\u003eelement\\u003csp\\u003ecan\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eNULL\\u003csp\\u003eor\\u003csp\\u003eEMPTY\\u003csp\\u003ewhen\\u003csp\\u003eusing\\u003csp\\u003e@FlipOnSpringExpression\\\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( false, result )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"result\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"boolean\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "88_0.txt": "{\n  \"file\": \"88_0.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_1.txt": "{\n  \"file\": \"88_1.txt\",\n  \"assertion\": \"assertEquals ( 1, 2Files count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_10.txt": "{\n  \"file\": \"88_10.txt\",\n  \"assertion\": \"assertEquals ( 3, 2. count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 3, 2. count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_11.txt": "{\n  \"file\": \"88_11.txt\",\n  \"assertion\": \"assertEquals ( 2, 3. count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 3. count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_12.txt": "{\n  \"file\": \"88_12.txt\",\n  \"assertion\": \"assertEquals ( 1, 3. count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 3. count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_13.txt": "{\n  \"file\": \"88_13.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. count ( 3 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 3 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_14.txt": "{\n  \"file\": \"88_14.txt\",\n  \"assertion\": \"assertEquals ( 1, 2D count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2D count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_15.txt": "{\n  \"file\": \"88_15.txt\",\n  \"assertion\": \"assertEquals ( 1, 3Files count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 3Files count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_16.txt": "{\n  \"file\": \"88_16.txt\",\n  \"assertion\": \"assertEquals ( 3, 2Files count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 3, 2Files count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_17.txt": "{\n  \"file\": \"88_17.txt\",\n  \"assertion\": \"assertEquals ( 2, 3Files count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 3Files count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_18.txt": "{\n  \"file\": \"88_18.txt\",\n  \"assertion\": \"assertEquals ( 1, 2Files count ( 3 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 3 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_19.txt": "{\n  \"file\": \"88_19.txt\",\n  \"assertion\": \"assertEquals ( 4, 2. count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 4, 2. count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_2.txt": "{\n  \"file\": \"88_2.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 2. count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_20.txt": "{\n  \"file\": \"88_20.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. count ( 4 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 4 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_21.txt": "{\n  \"file\": \"88_21.txt\",\n  \"assertion\": \"assertEquals ( 3, 2. count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 3, 2. count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_22.txt": "{\n  \"file\": \"88_22.txt\",\n  \"assertion\": \"assertEquals ( 2, 3. count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 3. count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_23.txt": "{\n  \"file\": \"88_23.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. count ( 3 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 2. count ( 3 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_24.txt": "{\n  \"file\": \"88_24.txt\",\n  \"assertion\": \"assertEquals ( 2, 2D count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 2D count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_25.txt": "{\n  \"file\": \"88_25.txt\",\n  \"assertion\": \"assertEquals ( 1, 2D count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2D count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_26.txt": "{\n  \"file\": \"88_26.txt\",\n  \"assertion\": \"assertEquals ( 1, 2M count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2M count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_27.txt": "{\n  \"file\": \"88_27.txt\",\n  \"assertion\": \"assertEquals ( 4, 2Files count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 4, 2Files count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_28.txt": "{\n  \"file\": \"88_28.txt\",\n  \"assertion\": \"assertEquals ( 1, 2Files count ( 4 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 4 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_29.txt": "{\n  \"file\": \"88_29.txt\",\n  \"assertion\": \"assertEquals ( 3, 2Files count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 3, 2Files count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_3.txt": "{\n  \"file\": \"88_3.txt\",\n  \"assertion\": \"assertEquals ( 1, 2. count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_4.txt": "{\n  \"file\": \"88_4.txt\",\n  \"assertion\": \"assertEquals ( 2, 2Files count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 2Files count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_5.txt": "{\n  \"file\": \"88_5.txt\",\n  \"assertion\": \"assertEquals ( 1, 2Files count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_6.txt": "{\n  \"file\": \"88_6.txt\",\n  \"assertion\": \"assertEquals ( 2, 2. count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 2. count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_7.txt": "{\n  \"file\": \"88_7.txt\",\n  \"assertion\": \"assertEquals ( 1, 3. count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 3. count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_8.txt": "{\n  \"file\": \"88_8.txt\",\n  \"assertion\": \"assertEquals ( 2, 2Files count ( 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 2, 2Files count ( 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "88_9.txt": "{\n  \"file\": \"88_9.txt\",\n  \"assertion\": \"assertEquals ( 1, 3Files count ( 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \\\"foo\\\" ) ; IFile file \\u003d createFile ( ( \\\"foo/src/foo\\\" + ( F_EXT ) ) , \\\"object\\u003csp\\u003eFoo\\u003csp\\u003e\\\" ) ; build ( ) ; assertEquals ( 1, 3Files count ( 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( 0, countMarkers ( file ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "89_0.txt": "{\n  \"file\": \"89_0.txt\",\n  \"assertion\": \"assertEquals ( groups. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_1.txt": "{\n  \"file\": \"89_1.txt\",\n  \"assertion\": \"assertEquals ( groups. 0 ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. 0 ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "89_10.txt": "{\n  \"file\": \"89_10.txt\",\n  \"assertion\": \"assertEquals ( groups. n ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. n ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"n\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_11.txt": "{\n  \"file\": \"89_11.txt\",\n  \"assertion\": \"assertEquals ( groups. get ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. get ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"get\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_12.txt": "{\n  \"file\": \"89_12.txt\",\n  \"assertion\": \"assertEquals ( this. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( this. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_13.txt": "{\n  \"file\": \"89_13.txt\",\n  \"assertion\": \"assertEquals ( output. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( output. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_14.txt": "{\n  \"file\": \"89_14.txt\",\n  \"assertion\": \"assertEquals ( items. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( items. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_15.txt": "{\n  \"file\": \"89_15.txt\",\n  \"assertion\": \"assertEquals ( groups. count ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. count ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"count\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_16.txt": "{\n  \"file\": \"89_16.txt\",\n  \"assertion\": \"assertEquals ( groups. empty ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. empty ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"empty\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_17.txt": "{\n  \"file\": \"89_17.txt\",\n  \"assertion\": \"assertEquals ( elements. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( elements. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_18.txt": "{\n  \"file\": \"89_18.txt\",\n  \"assertion\": \"assertEquals ( results. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( results. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_19.txt": "{\n  \"file\": \"89_19.txt\",\n  \"assertion\": \"assertEquals ( groups. group ( ), 0 )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. group ( ), 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_2.txt": "{\n  \"file\": \"89_2.txt\",\n  \"assertion\": \"assertEquals ( groups. group ( ), group )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. group ( ), group ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_20.txt": "{\n  \"file\": \"89_20.txt\",\n  \"assertion\": \"assertEquals ( groups. 0 ( ), group )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. 0 ( ), group ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "89_21.txt": "{\n  \"file\": \"89_21.txt\",\n  \"assertion\": \"assertEquals ( 0. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( 0. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "89_22.txt": "{\n  \"file\": \"89_22.txt\",\n  \"assertion\": \"assertEquals ( group. 0 ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( group. 0 ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "89_23.txt": "{\n  \"file\": \"89_23.txt\",\n  \"assertion\": \"assertEquals ( groups. order ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. order ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"order\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_24.txt": "{\n  \"file\": \"89_24.txt\",\n  \"assertion\": \"assertEquals ( data. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( data. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_25.txt": "{\n  \"file\": \"89_25.txt\",\n  \"assertion\": \"assertEquals ( list. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( list. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_26.txt": "{\n  \"file\": \"89_26.txt\",\n  \"assertion\": \"assertEquals ( Group. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( Group. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_27.txt": "{\n  \"file\": \"89_27.txt\",\n  \"assertion\": \"assertEquals ( groups. remaining ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. remaining ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"remaining\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_28.txt": "{\n  \"file\": \"89_28.txt\",\n  \"assertion\": \"assertEquals ( collection. 0 ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( collection. 0 ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "89_29.txt": "{\n  \"file\": \"89_29.txt\",\n  \"assertion\": \"assertEquals ( groups. sizes ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. sizes ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"sizes\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_3.txt": "{\n  \"file\": \"89_3.txt\",\n  \"assertion\": \"assertEquals ( group. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( group. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_4.txt": "{\n  \"file\": \"89_4.txt\",\n  \"assertion\": \"assertEquals ( collection. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( collection. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_5.txt": "{\n  \"file\": \"89_5.txt\",\n  \"assertion\": \"assertEquals ( Groups. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( Groups. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_6.txt": "{\n  \"file\": \"89_6.txt\",\n  \"assertion\": \"assertEquals ( collections. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( collections. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_7.txt": "{\n  \"file\": \"89_7.txt\",\n  \"assertion\": \"assertEquals ( g. group ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( g. group ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "89_8.txt": "{\n  \"file\": \"89_8.txt\",\n  \"assertion\": \"assertEquals ( groups. size ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. size ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in focal method\": \"size\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"size\\\",\\n  \\\"fm\\\": true,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"int\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"incompatible type\"\n}",
  "89_9.txt": "{\n  \"file\": \"89_9.txt\",\n  \"assertion\": \"assertEquals ( groups. members ( ), groups )\\r\\n\",\n  \"test\": \"class X {public void chunk_empty ( ) { RichIterable \\u003c String \\u003e collection \\u003d this . newWith ( ) ; api . RichIterable \\u003c RichIterable \\u003c String \\u003e \\u003e groups \\u003d collection . chunk ( 2 ) ; assertEquals ( groups. members ( ), groups ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void size() { return 0 ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( groups. size ( ), 0 )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"true\",\n  \"find type in test\": \"groups\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"members\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"groups\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"api.RichIterable\\\\u003cRichIterable\\\\u003cString\\\\u003e\\\\u003e\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "8_0.txt": "{\n  \"file\": \"8_0.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_1.txt": "{\n  \"file\": \"8_1.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 2 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_10.txt": "{\n  \"file\": \"8_10.txt\",\n  \"assertion\": \"assertEquals ( businessOB data, data )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, data ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_11.txt": "{\n  \"file\": \"8_11.txt\",\n  \"assertion\": \"assertEquals ( business_ 0, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_12.txt": "{\n  \"file\": \"8_12.txt\",\n  \"assertion\": \"assertEquals ( businessOB 1, 2 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_13.txt": "{\n  \"file\": \"8_13.txt\",\n  \"assertion\": \"assertEquals ( businessOB 1, 5 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_14.txt": "{\n  \"file\": \"8_14.txt\",\n  \"assertion\": \"assertEquals ( businessOB data, 1 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_15.txt": "{\n  \"file\": \"8_15.txt\",\n  \"assertion\": \"assertEquals ( businessOB 1, data )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, data ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_16.txt": "{\n  \"file\": \"8_16.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 7 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 7 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_17.txt": "{\n  \"file\": \"8_17.txt\",\n  \"assertion\": \"assertEquals ( business_ 0, 2 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_18.txt": "{\n  \"file\": \"8_18.txt\",\n  \"assertion\": \"assertEquals ( businessOB data, value )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, value ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_19.txt": "{\n  \"file\": \"8_19.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 12 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 12 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_2.txt": "{\n  \"file\": \"8_2.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 5 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_20.txt": "{\n  \"file\": \"8_20.txt\",\n  \"assertion\": \"assertEquals ( business_ 0, 5 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_21.txt": "{\n  \"file\": \"8_21.txt\",\n  \"assertion\": \"assertEquals ( business_ data, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ data, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_22.txt": "{\n  \"file\": \"8_22.txt\",\n  \"assertion\": \"assertEquals ( business_ 0, data )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, data ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_23.txt": "{\n  \"file\": \"8_23.txt\",\n  \"assertion\": \"assertEquals ( businessOB 10, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 10, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_24.txt": "{\n  \"file\": \"8_24.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 10 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 10 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_25.txt": "{\n  \"file\": \"8_25.txt\",\n  \"assertion\": \"assertEquals ( businessOB 1, 1 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_26.txt": "{\n  \"file\": \"8_26.txt\",\n  \"assertion\": \"assertEquals ( business. 0, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business. 0, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_27.txt": "{\n  \"file\": \"8_27.txt\",\n  \"assertion\": \"assertEquals ( business ${ 0, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business ${ 0, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_28.txt": "{\n  \"file\": \"8_28.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, null )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_29.txt": "{\n  \"file\": \"8_29.txt\",\n  \"assertion\": \"assertEquals ( businessOB 1, value )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, value ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_3.txt": "{\n  \"file\": \"8_3.txt\",\n  \"assertion\": \"assertEquals ( businessOB data, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_4.txt": "{\n  \"file\": \"8_4.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, data )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, data ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_5.txt": "{\n  \"file\": \"8_5.txt\",\n  \"assertion\": \"assertEquals ( businessOB 1, 0 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_6.txt": "{\n  \"file\": \"8_6.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, 1 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_7.txt": "{\n  \"file\": \"8_7.txt\",\n  \"assertion\": \"assertEquals ( businessOB data, 2 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_8.txt": "{\n  \"file\": \"8_8.txt\",\n  \"assertion\": \"assertEquals ( businessOB 0, value )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, value ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "8_9.txt": "{\n  \"file\": \"8_9.txt\",\n  \"assertion\": \"assertEquals ( businessOB data, 5 )\\r\\n\",\n  \"test\": \"class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \\u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \\u003d String . join ( \\\"|\\\" ) ; BusinessObjectData businessObjectData \\u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \\u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( businessObjectData, result )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_0.txt": "{\n  \"file\": \"90_0.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_1.txt": "{\n  \"file\": \"90_1.txt\",\n  \"assertion\": \"assertEquals ( transformed ), transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed ), transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_10.txt": "{\n  \"file\": \"90_10.txt\",\n  \"assertion\": \"assertEquals ( transformed\\\", transformed\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed\\\", transformed\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_11.txt": "{\n  \"file\": \"90_11.txt\",\n  \"assertion\": \"assertEquals ( transformed \\\", transformed ) )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed \\\", transformed ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_12.txt": "{\n  \"file\": \"90_12.txt\",\n  \"assertion\": \"assertEquals ( transformed ), transformed \\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed ), transformed \\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_13.txt": "{\n  \"file\": \"90_13.txt\",\n  \"assertion\": \"assertEquals ( transformed \\\", transformed\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed \\\", transformed\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_14.txt": "{\n  \"file\": \"90_14.txt\",\n  \"assertion\": \"assertEquals ( transformed\\\", transformed \\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed\\\", transformed \\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_15.txt": "{\n  \"file\": \"90_15.txt\",\n  \"assertion\": \"assertEquals ( transformed-\\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed-\\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_16.txt": "{\n  \"file\": \"90_16.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed-\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed-\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_17.txt": "{\n  \"file\": \"90_17.txt\",\n  \"assertion\": \"assertEquals ( transformed,\\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed,\\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"transformed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\", transformed.\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "90_18.txt": "{\n  \"file\": \"90_18.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed,\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed,\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_19.txt": "{\n  \"file\": \"90_19.txt\",\n  \"assertion\": \"assertEquals ( transformed \\\", transformed \\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed \\\", transformed \\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_2.txt": "{\n  \"file\": \"90_2.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed ) )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_20.txt": "{\n  \"file\": \"90_20.txt\",\n  \"assertion\": \"assertEquals ( transformed}\\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed}\\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_21.txt": "{\n  \"file\": \"90_21.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed}\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed}\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_22.txt": "{\n  \"file\": \"90_22.txt\",\n  \"assertion\": \"assertEquals ( transformed:\\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed:\\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_23.txt": "{\n  \"file\": \"90_23.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed:\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed:\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_24.txt": "{\n  \"file\": \"90_24.txt\",\n  \"assertion\": \"assertEquals ( transformed-\\\", transformed ) )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed-\\\", transformed ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_25.txt": "{\n  \"file\": \"90_25.txt\",\n  \"assertion\": \"assertEquals ( transformed ), transformed-\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed ), transformed-\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_26.txt": "{\n  \"file\": \"90_26.txt\",\n  \"assertion\": \"assertEquals ( transformedPath, transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformedPath, transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_27.txt": "{\n  \"file\": \"90_27.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformedPath )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformedPath ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_28.txt": "{\n  \"file\": \"90_28.txt\",\n  \"assertion\": \"assertEquals ( transformed-\\\", transformed\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed-\\\", transformed\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_29.txt": "{\n  \"file\": \"90_29.txt\",\n  \"assertion\": \"assertEquals ( transformed\\\", transformed-\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed\\\", transformed-\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_3.txt": "{\n  \"file\": \"90_3.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_4.txt": "{\n  \"file\": \"90_4.txt\",\n  \"assertion\": \"assertEquals ( transformed\\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed\\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_5.txt": "{\n  \"file\": \"90_5.txt\",\n  \"assertion\": \"assertEquals ( transformed \\\", transformed.\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed \\\", transformed.\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_6.txt": "{\n  \"file\": \"90_6.txt\",\n  \"assertion\": \"assertEquals ( transformed.\\\", transformed \\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed.\\\", transformed \\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_7.txt": "{\n  \"file\": \"90_7.txt\",\n  \"assertion\": \"assertEquals ( transformed ), transformed ) )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed ), transformed ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_8.txt": "{\n  \"file\": \"90_8.txt\",\n  \"assertion\": \"assertEquals ( transformed\\\", transformed ) )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed\\\", transformed ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "90_9.txt": "{\n  \"file\": \"90_9.txt\",\n  \"assertion\": \"assertEquals ( transformed ), transformed\\\" )\\r\\n\",\n  \"test\": \"class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \\u003d BuildTargetFactory . newInstance ( \\\"//java/com/facebook/util:ManifestGenerator\\\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \\\"com.facebook.util.ManifestGenerator\\\" ) . build ( graphBuilder ) ; String transformedString \\u003d coerceAndStringify ( \\\"$(exe\\u003csp\\u003e//java/com/facebook/util:ManifestGenerator)\\u003csp\\u003e$OUT\\\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \\u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \\\"java/com/facebook/util/ManifestGenerator.jar\\\" ) . toAbsolutePath ( ) ; String expectedCmd \\u003d String . format ( \\\"java\\u003csp\\u003e-jar\\u003csp\\u003e%s\\u003csp\\u003e$OUT\\\" , expectedClasspath ) ; assertEquals ( transformed ), transformed\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectedCmd, transformedString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_0.txt": "{\n  \"file\": \"91_0.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect 2 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect 2 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_1.txt": "{\n  \"file\": \"91_1.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect 2 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect 2 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_10.txt": "{\n  \"file\": \"91_10.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect 2 repS )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect 2 repS ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_11.txt": "{\n  \"file\": \"91_11.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect10 repS )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect10 repS ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_12.txt": "{\n  \"file\": \"91_12.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect, repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect, repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_13.txt": "{\n  \"file\": \"91_13.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect, repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect, repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_14.txt": "{\n  \"file\": \"91_14.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect 2 repU )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect 2 repU ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_15.txt": "{\n  \"file\": \"91_15.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect10 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect10 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_16.txt": "{\n  \"file\": \"91_16.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect 2 repA )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect 2 repA ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_17.txt": "{\n  \"file\": \"91_17.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect10 repA )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect10 repA ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_18.txt": "{\n  \"file\": \"91_18.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect10 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect10 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_19.txt": "{\n  \"file\": \"91_19.txt\",\n  \"assertion\": \"assertEquals ( expect URI, expect 2 repS )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expect URI, expect 2 repS ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_2.txt": "{\n  \"file\": \"91_2.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect 2 repS )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect 2 repS ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_20.txt": "{\n  \"file\": \"91_20.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect, repS )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect, repS ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_21.txt": "{\n  \"file\": \"91_21.txt\",\n  \"assertion\": \"assertEquals ( expect URI, expect10 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expect URI, expect10 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_22.txt": "{\n  \"file\": \"91_22.txt\",\n  \"assertion\": \"assertEquals ( expect URI, expect 2 repA )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expect URI, expect 2 repA ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_23.txt": "{\n  \"file\": \"91_23.txt\",\n  \"assertion\": \"assertEquals ( expect URI, expect10 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expect URI, expect10 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_24.txt": "{\n  \"file\": \"91_24.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect10 repS )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect10 repS ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_25.txt": "{\n  \"file\": \"91_25.txt\",\n  \"assertion\": \"assertEquals ( expectri, expect 2 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectri, expect 2 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_26.txt": "{\n  \"file\": \"91_26.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect, repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect, repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_27.txt": "{\n  \"file\": \"91_27.txt\",\n  \"assertion\": \"assertEquals ( expectri, expect 2 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectri, expect 2 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_28.txt": "{\n  \"file\": \"91_28.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect, repA )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect, repA ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_29.txt": "{\n  \"file\": \"91_29.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect, repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect, repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_3.txt": "{\n  \"file\": \"91_3.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect 2 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect 2 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_4.txt": "{\n  \"file\": \"91_4.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect10 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect10 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_5.txt": "{\n  \"file\": \"91_5.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect 2 repA )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect 2 repA ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_6.txt": "{\n  \"file\": \"91_6.txt\",\n  \"assertion\": \"assertEquals ( expectI, expect 2 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectI, expect 2 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_7.txt": "{\n  \"file\": \"91_7.txt\",\n  \"assertion\": \"assertEquals ( expectU, expect10 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expectU, expect10 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_8.txt": "{\n  \"file\": \"91_8.txt\",\n  \"assertion\": \"assertEquals ( expect URI, expect 2 repR )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expect URI, expect 2 repR ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "91_9.txt": "{\n  \"file\": \"91_9.txt\",\n  \"assertion\": \"assertEquals ( expect URI, expect 2 repIENT )\\r\\n\",\n  \"test\": \"class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \\u003d new File ( \\\"/tmp/testcomp.zip\\\" ) ; URI p2RepURI \\u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \\u003d URI . create ( ( ( \\\"jar:\\\" + ( compFile . toURI ( ) . toString ( ) ) ) + \\\"!/\\\" ) ) ; assertEquals ( expect URI, expect 2 repIENT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void toString() { return ( ( project ) + \\\"-------\\\" ) + ( mappingNLProject ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expectURI, p2RepURI )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_0.txt": "{\n  \"file\": \"92_0.txt\",\n  \"assertion\": \"assertEquals ( status )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( status ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_1.txt": "{\n  \"file\": \"92_1.txt\",\n  \"assertion\": \"assertEquals ( Status )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( Status ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_10.txt": "{\n  \"file\": \"92_10.txt\",\n  \"assertion\": \"assertEquals ( STAT )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( STAT ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_11.txt": "{\n  \"file\": \"92_11.txt\",\n  \"assertion\": \"assertEquals ( code )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( code ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_12.txt": "{\n  \"file\": \"92_12.txt\",\n  \"assertion\": \"assertEquals ( source )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( source ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_13.txt": "{\n  \"file\": \"92_13.txt\",\n  \"assertion\": \"assertEquals ( false )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( false ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_14.txt": "{\n  \"file\": \"92_14.txt\",\n  \"assertion\": \"assertEquals ( 200 )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( 200 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_15.txt": "{\n  \"file\": \"92_15.txt\",\n  \"assertion\": \"assertEquals ( type )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( type ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_16.txt": "{\n  \"file\": \"92_16.txt\",\n  \"assertion\": \"assertEquals ( mode )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( mode ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_17.txt": "{\n  \"file\": \"92_17.txt\",\n  \"assertion\": \"assertEquals ( stage )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( stage ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_18.txt": "{\n  \"file\": \"92_18.txt\",\n  \"assertion\": \"assertEquals ( 100 )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( 100 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_19.txt": "{\n  \"file\": \"92_19.txt\",\n  \"assertion\": \"assertEquals ( ( )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( ( ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_2.txt": "{\n  \"file\": \"92_2.txt\",\n  \"assertion\": \"assertEquals ( state )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( state ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_20.txt": "{\n  \"file\": \"92_20.txt\",\n  \"assertion\": \"assertEquals ( ) )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_21.txt": "{\n  \"file\": \"92_21.txt\",\n  \"assertion\": \"assertEquals ( visibility )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( visibility ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_22.txt": "{\n  \"file\": \"92_22.txt\",\n  \"assertion\": \"assertEquals ( version )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( version ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_23.txt": "{\n  \"file\": \"92_23.txt\",\n  \"assertion\": \"assertEquals ( condition )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( condition ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_24.txt": "{\n  \"file\": \"92_24.txt\",\n  \"assertion\": \"assertEquals ( content )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( content ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_25.txt": "{\n  \"file\": \"92_25.txt\",\n  \"assertion\": \"assertEquals ( str )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( str ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_26.txt": "{\n  \"file\": \"92_26.txt\",\n  \"assertion\": \"assertEquals ( update )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( update ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_27.txt": "{\n  \"file\": \"92_27.txt\",\n  \"assertion\": \"assertEquals ( method )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( method ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_28.txt": "{\n  \"file\": \"92_28.txt\",\n  \"assertion\": \"assertEquals ( 4 )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( 4 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_29.txt": "{\n  \"file\": \"92_29.txt\",\n  \"assertion\": \"assertEquals ( expected )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_3.txt": "{\n  \"file\": \"92_3.txt\",\n  \"assertion\": \"assertEquals (status )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals (status ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_4.txt": "{\n  \"file\": \"92_4.txt\",\n  \"assertion\": \"assertEquals ( 0 )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_5.txt": "{\n  \"file\": \"92_5.txt\",\n  \"assertion\": \"assertEquals (Status )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals (Status ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_6.txt": "{\n  \"file\": \"92_6.txt\",\n  \"assertion\": \"assertEquals ( null )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_7.txt": "{\n  \"file\": \"92_7.txt\",\n  \"assertion\": \"assertEquals ( 1 )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_8.txt": "{\n  \"file\": \"92_8.txt\",\n  \"assertion\": \"assertEquals ( stat )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( stat ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "92_9.txt": "{\n  \"file\": \"92_9.txt\",\n  \"assertion\": \"assertEquals ( true )\\r\\n\",\n  \"test\": \"class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \\\"CREATION_EXECUTING_WORKLOAD\\\" ) ) ; propertyHandler \\u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \\u003d propertyHandler . getState ( ) ; assertEquals ( true ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getState() { return state ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( status )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "93_0.txt": "{\n  \"file\": \"93_0.txt\",\n  \"assertion\": \"assertNotNull ( results )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"results\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"QueryResult\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "93_1.txt": "{\n  \"file\": \"93_1.txt\",\n  \"assertion\": \"assertNotNull (results )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull (results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"results\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"QueryResult\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "93_10.txt": "{\n  \"file\": \"93_10.txt\",\n  \"assertion\": \"assertNotNull ( rows )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( rows ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"rows\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_11.txt": "{\n  \"file\": \"93_11.txt\",\n  \"assertion\": \"assertNotNull ( records )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( records ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"records\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_12.txt": "{\n  \"file\": \"93_12.txt\",\n  \"assertion\": \"assertNotNull ( permissions )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( permissions ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"permissions\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_13.txt": "{\n  \"file\": \"93_13.txt\",\n  \"assertion\": \"assertNotNull ( runs )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( runs ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"runs\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_14.txt": "{\n  \"file\": \"93_14.txt\",\n  \"assertion\": \"assertNotNull ( works )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( works ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"works\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_15.txt": "{\n  \"file\": \"93_15.txt\",\n  \"assertion\": \"assertNotNull ( blocks )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( blocks ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"blocks\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_16.txt": "{\n  \"file\": \"93_16.txt\",\n  \"assertion\": \"assertNotNull ( maps )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( maps ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"maps\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_17.txt": "{\n  \"file\": \"93_17.txt\",\n  \"assertion\": \"assertNotNull ( executions )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( executions ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"executions\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_18.txt": "{\n  \"file\": \"93_18.txt\",\n  \"assertion\": \"assertNotNull ( completes )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( completes ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"completes\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_19.txt": "{\n  \"file\": \"93_19.txt\",\n  \"assertion\": \"assertNotNull ( findings )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( findings ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"findings\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_2.txt": "{\n  \"file\": \"93_2.txt\",\n  \"assertion\": \"assertNotNull ( values )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( values ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"values\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_20.txt": "{\n  \"file\": \"93_20.txt\",\n  \"assertion\": \"assertNotNull ( fills )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( fills ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"fills\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_21.txt": "{\n  \"file\": \"93_21.txt\",\n  \"assertion\": \"assertNotNull ( succeeds )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( succeeds ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"succeeds\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_22.txt": "{\n  \"file\": \"93_22.txt\",\n  \"assertion\": \"assertNotNull ( details )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( details ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"details\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_23.txt": "{\n  \"file\": \"93_23.txt\",\n  \"assertion\": \"assertNotNull ( exists )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( exists ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"exists\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_24.txt": "{\n  \"file\": \"93_24.txt\",\n  \"assertion\": \"assertNotNull ( filters )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( filters ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"filters\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_25.txt": "{\n  \"file\": \"93_25.txt\",\n  \"assertion\": \"assertNotNull ( assignments )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( assignments ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"assignments\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_26.txt": "{\n  \"file\": \"93_26.txt\",\n  \"assertion\": \"assertNotNull ( closes )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( closes ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"closes\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_27.txt": "{\n  \"file\": \"93_27.txt\",\n  \"assertion\": \"assertNotNull ( ends )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( ends ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"ends\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_28.txt": "{\n  \"file\": \"93_28.txt\",\n  \"assertion\": \"assertNotNull ( contents )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( contents ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"contents\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_29.txt": "{\n  \"file\": \"93_29.txt\",\n  \"assertion\": \"assertNotNull ( methods )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( methods ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"methods\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_3.txt": "{\n  \"file\": \"93_3.txt\",\n  \"assertion\": \"assertNotNull ( result )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( result ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"result\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_4.txt": "{\n  \"file\": \"93_4.txt\",\n  \"assertion\": \"assertNotNull ( executes )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( executes ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"executes\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_5.txt": "{\n  \"file\": \"93_5.txt\",\n  \"assertion\": \"assertNotNull ( null )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"stop parsing\": \"arg is trivial\",\n  \"trivial_check\": \"finished\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_6.txt": "{\n  \"file\": \"93_6.txt\",\n  \"assertion\": \"assertNotNull ( Results )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( Results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_7.txt": "{\n  \"file\": \"93_7.txt\",\n  \"assertion\": \"assertNotNull ( answers )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( answers ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"answers\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_8.txt": "{\n  \"file\": \"93_8.txt\",\n  \"assertion\": \"assertNotNull ( metrics )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( metrics ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"metrics\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "93_9.txt": "{\n  \"file\": \"93_9.txt\",\n  \"assertion\": \"assertNotNull (Results )\\r\\n\",\n  \"test\": \"class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \\u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \\u003d \\\"select\\u003csp\\u003erow_id\\u003csp\\u003efrom\\u003csp\\u003e\\\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \\u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull (Results ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \\u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \\u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003elock:\\u003csp\\u003e\\\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \\\"Waiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003ebuild\\u003csp\\u003etable.\\u003csp\\u003eStatus:\\u003csp\\u003e\\\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \\\"Timed\\u003csp\\u003eout\\u003csp\\u003ewaiting\\u003csp\\u003efor\\u003csp\\u003etable\\u003csp\\u003eindex\\u003csp\\u003eworker\\u003csp\\u003eto\\u003csp\\u003emake\\u003csp\\u003ethe\\u003csp\\u003etable\\u003csp\\u003eavailable.\\\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \\u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\\r\\n\",\n  \"truth\": \"assertNotNull ( results )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"Results\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_0.txt": "{\n  \"file\": \"94_0.txt\",\n  \"assertion\": \"assertEquals ( expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_1.txt": "{\n  \"file\": \"94_1.txt\",\n  \"assertion\": \"assertEquals ( expect, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expect, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_10.txt": "{\n  \"file\": \"94_10.txt\",\n  \"assertion\": \"assertEquals ( expected, assumed )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, assumed ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_11.txt": "{\n  \"file\": \"94_11.txt\",\n  \"assertion\": \"assertEquals ( 0, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( 0, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_12.txt": "{\n  \"file\": \"94_12.txt\",\n  \"assertion\": \"assertEquals ( expected, 0 )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_13.txt": "{\n  \"file\": \"94_13.txt\",\n  \"assertion\": \"assertEquals ( 10, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( 10, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"10\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_14.txt": "{\n  \"file\": \"94_14.txt\",\n  \"assertion\": \"assertEquals (expected, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals (expected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_15.txt": "{\n  \"file\": \"94_15.txt\",\n  \"assertion\": \"assertEquals ( anticipated, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( anticipated, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"anticipated\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_16.txt": "{\n  \"file\": \"94_16.txt\",\n  \"assertion\": \"assertEquals ( expected, anticipated )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, anticipated ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"anticipated\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_17.txt": "{\n  \"file\": \"94_17.txt\",\n  \"assertion\": \"assertEquals ( 1, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( 1, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_18.txt": "{\n  \"file\": \"94_18.txt\",\n  \"assertion\": \"assertEquals ( expected, 1 )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_19.txt": "{\n  \"file\": \"94_19.txt\",\n  \"assertion\": \"assertEquals ( 8, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( 8, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"8\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_2.txt": "{\n  \"file\": \"94_2.txt\",\n  \"assertion\": \"assertEquals ( expected, expect )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, expect ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expect\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_20.txt": "{\n  \"file\": \"94_20.txt\",\n  \"assertion\": \"assertEquals ( input, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( input, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"input\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_21.txt": "{\n  \"file\": \"94_21.txt\",\n  \"assertion\": \"assertEquals ( expected, input )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, input ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"input\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_22.txt": "{\n  \"file\": \"94_22.txt\",\n  \"assertion\": \"assertEquals ( predicted, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( predicted, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"predicted\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_23.txt": "{\n  \"file\": \"94_23.txt\",\n  \"assertion\": \"assertEquals ( unexpected, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( unexpected, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"unexpected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_24.txt": "{\n  \"file\": \"94_24.txt\",\n  \"assertion\": \"assertEquals ( target, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( target, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"target\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_25.txt": "{\n  \"file\": \"94_25.txt\",\n  \"assertion\": \"assertEquals ( expected, target )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, target ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"target\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_26.txt": "{\n  \"file\": \"94_26.txt\",\n  \"assertion\": \"assertEquals ( 2, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( 2, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_27.txt": "{\n  \"file\": \"94_27.txt\",\n  \"assertion\": \"assertEquals ( expects, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expects, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expects\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_28.txt": "{\n  \"file\": \"94_28.txt\",\n  \"assertion\": \"assertEquals ( original, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( original, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"original\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_29.txt": "{\n  \"file\": \"94_29.txt\",\n  \"assertion\": \"assertEquals ( expected, original )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, original ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"original\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_3.txt": "{\n  \"file\": \"94_3.txt\",\n  \"assertion\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, actual ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"actual\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"actual\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "94_4.txt": "{\n  \"file\": \"94_4.txt\",\n  \"assertion\": \"assertEquals ( actual, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( actual, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"actual\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "94_5.txt": "{\n  \"file\": \"94_5.txt\",\n  \"assertion\": \"assertEquals ( null, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( null, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_6.txt": "{\n  \"file\": \"94_6.txt\",\n  \"assertion\": \"assertEquals ( expected, null )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_7.txt": "{\n  \"file\": \"94_7.txt\",\n  \"assertion\": \"assertEquals ( expecting, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expecting, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_8.txt": "{\n  \"file\": \"94_8.txt\",\n  \"assertion\": \"assertEquals ( expected, expecting )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( expected, expecting ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expecting\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "94_9.txt": "{\n  \"file\": \"94_9.txt\",\n  \"assertion\": \"assertEquals ( assumed, expected )\\r\\n\",\n  \"test\": \"class X {public void testGetSchema ( ) { Schema expected \\u003d AvroUtils . _string ( ) ; AvroConverter \\u003c ? , ? \\u003e converter \\u003d new BigDecimalStringConverter ( ) ; Schema actual \\u003d converter . getSchema ( ) ; assertEquals ( assumed, expected ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, actual )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"expected\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"assumed\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Schema\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_0.txt": "{\n  \"file\": \"95_0.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sr ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sr) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_1.txt": "{\n  \"file\": \"95_1.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sp ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sp) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_10.txt": "{\n  \"file\": \"95_10.txt\",\n  \"assertion\": \"assertTrue ( ( ( result s\\u0027 ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s\\u0027 ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "95_11.txt": "{\n  \"file\": \"95_11.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sp ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sp) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_12.txt": "{\n  \"file\": \"95_12.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sr ) \\u003d\\u003d 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \\u003d\\u003d 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sr) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 2)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_13.txt": "{\n  \"file\": \"95_13.txt\",\n  \"assertion\": \"assertTrue ( ( ( result s q ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s q ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "95_14.txt": "{\n  \"file\": \"95_14.txt\",\n  \"assertion\": \"assertTrue ( ( ( result ssq ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result ssq ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result ssq) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_15.txt": "{\n  \"file\": \"95_15.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sf ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sf ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sf) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_16.txt": "{\n  \"file\": \"95_16.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sp ) \\u003d\\u003d 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \\u003d\\u003d 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sp) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 2)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_17.txt": "{\n  \"file\": \"95_17.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sc ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sc ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sc) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_18.txt": "{\n  \"file\": \"95_18.txt\",\n  \"assertion\": \"assertTrue ( ( ( result s1 ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s1 ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result s1) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_19.txt": "{\n  \"file\": \"95_19.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sr ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \\u003d\\u003d 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sr) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 1)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_2.txt": "{\n  \"file\": \"95_2.txt\",\n  \"assertion\": \"assertTrue ( ( ( result s q ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s q ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "95_20.txt": "{\n  \"file\": \"95_20.txt\",\n  \"assertion\": \"assertTrue ( ( ( result s q ) \\u003d\\u003d 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s q ) \\u003d\\u003d 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "95_21.txt": "{\n  \"file\": \"95_21.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sv ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sv ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sv) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_22.txt": "{\n  \"file\": \"95_22.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sr ) \\u003d\\u003d null ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \\u003d\\u003d null ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sr) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d null)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_23.txt": "{\n  \"file\": \"95_23.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sf ) \\u003d\\u003d 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sf ) \\u003d\\u003d 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sf) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 2)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_24.txt": "{\n  \"file\": \"95_24.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sk ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sk ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sk) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_25.txt": "{\n  \"file\": \"95_25.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sx ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sx ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sx) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_26.txt": "{\n  \"file\": \"95_26.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sg ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sg ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sg) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_27.txt": "{\n  \"file\": \"95_27.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sp ) \\u003d\\u003d 1 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \\u003d\\u003d 1 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sp) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 1)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_28.txt": "{\n  \"file\": \"95_28.txt\",\n  \"assertion\": \"assertTrue ( ( ( result smp ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result smp ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result smp) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_29.txt": "{\n  \"file\": \"95_29.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sc ) \\u003d\\u003d 2 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sc ) \\u003d\\u003d 2 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sc) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 2)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_3.txt": "{\n  \"file\": \"95_3.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sf ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sf ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sf) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_4.txt": "{\n  \"file\": \"95_4.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sc ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sc ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sc) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_5.txt": "{\n  \"file\": \"95_5.txt\",\n  \"assertion\": \"assertTrue ( ( ( result s1 ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s1 ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result s1) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_6.txt": "{\n  \"file\": \"95_6.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sv ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sv ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sv) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_7.txt": "{\n  \"file\": \"95_7.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sk ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sk ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sk) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_8.txt": "{\n  \"file\": \"95_8.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sg ) \\u003d\\u003d expected ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sg ) \\u003d\\u003d expected ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sg) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d expected)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "95_9.txt": "{\n  \"file\": \"95_9.txt\",\n  \"assertion\": \"assertTrue ( ( ( result sr ) \\u003d\\u003d 0 ) )\\r\\n\",\n  \"test\": \"class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \\u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \\u003d\\u003d 0 ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \\u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \\u0026\\u0026 ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \\u0026\\u0026 ( ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \\u0026\\u0026 ( ( onSquare . rank ) !\\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \\u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( ( ( resultSq ) \\u003d\\u003d null ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"((result sr) -\\\\u003e {\\\\r\\\\n} \\\\u003d\\\\u003d 0)\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "96_0.txt": "{\n  \"file\": \"96_0.txt\",\n  \"assertion\": \"assertTrue ( p. value ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_1.txt": "{\n  \"file\": \"96_1.txt\",\n  \"assertion\": \"assertTrue ( p. value ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_10.txt": "{\n  \"file\": \"96_10.txt\",\n  \"assertion\": \"assertTrue ( p. validate ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_11.txt": "{\n  \"file\": \"96_11.txt\",\n  \"assertion\": \"assertTrue ( p. can ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. can ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"can\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_12.txt": "{\n  \"file\": \"96_12.txt\",\n  \"assertion\": \"assertTrue ( p. evaluate ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. evaluate ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evaluate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_13.txt": "{\n  \"file\": \"96_13.txt\",\n  \"assertion\": \"assertTrue ( p. group ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_14.txt": "{\n  \"file\": \"96_14.txt\",\n  \"assertion\": \"assertTrue ( p. matches ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matches\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_15.txt": "{\n  \"file\": \"96_15.txt\",\n  \"assertion\": \"assertTrue ( p. match ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_16.txt": "{\n  \"file\": \"96_16.txt\",\n  \"assertion\": \"assertTrue ( p. can ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. can ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"can\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_17.txt": "{\n  \"file\": \"96_17.txt\",\n  \"assertion\": \"assertTrue ( p. evaluate ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. evaluate ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evaluate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_18.txt": "{\n  \"file\": \"96_18.txt\",\n  \"assertion\": \"assertTrue ( p. validate ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_19.txt": "{\n  \"file\": \"96_19.txt\",\n  \"assertion\": \"assertTrue ( p. matches ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matches\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_2.txt": "{\n  \"file\": \"96_2.txt\",\n  \"assertion\": \"assertTrue ( p. value ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_20.txt": "{\n  \"file\": \"96_20.txt\",\n  \"assertion\": \"assertTrue ( p. group ( \\\"matched\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \\\"matched\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_21.txt": "{\n  \"file\": \"96_21.txt\",\n  \"assertion\": \"assertTrue ( p. match ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_22.txt": "{\n  \"file\": \"96_22.txt\",\n  \"assertion\": \"assertTrue ( p. group ( \\\"1\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \\\"1\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_23.txt": "{\n  \"file\": \"96_23.txt\",\n  \"assertion\": \"assertTrue ( p. can ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. can ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"can\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_24.txt": "{\n  \"file\": \"96_24.txt\",\n  \"assertion\": \"assertTrue ( p. value ( \\\"test\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \\\"test\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_25.txt": "{\n  \"file\": \"96_25.txt\",\n  \"assertion\": \"assertTrue ( p. evaluate ( \\\"cas\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. evaluate ( \\\"cas\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"evaluate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_26.txt": "{\n  \"file\": \"96_26.txt\",\n  \"assertion\": \"assertTrue ( p. validate ( \\\"matched\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \\\"matched\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_27.txt": "{\n  \"file\": \"96_27.txt\",\n  \"assertion\": \"assertTrue ( p. validate ( \\\"1\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \\\"1\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_28.txt": "{\n  \"file\": \"96_28.txt\",\n  \"assertion\": \"assertTrue ( p. matches ( \\\"matched\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \\\"matched\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matches\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_29.txt": "{\n  \"file\": \"96_29.txt\",\n  \"assertion\": \"assertTrue ( p. match ( \\\"matched\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \\\"matched\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_3.txt": "{\n  \"file\": \"96_3.txt\",\n  \"assertion\": \"assertTrue ( p. group ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_4.txt": "{\n  \"file\": \"96_4.txt\",\n  \"assertion\": \"assertTrue ( p. group ( \\\"c\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \\\"c\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"group\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_5.txt": "{\n  \"file\": \"96_5.txt\",\n  \"assertion\": \"assertTrue ( p. value ( \\\"matched\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \\\"matched\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_6.txt": "{\n  \"file\": \"96_6.txt\",\n  \"assertion\": \"assertTrue ( p. validate ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"validate\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_7.txt": "{\n  \"file\": \"96_7.txt\",\n  \"assertion\": \"assertTrue ( p. value ( \\\"1\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \\\"1\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"value\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_8.txt": "{\n  \"file\": \"96_8.txt\",\n  \"assertion\": \"assertTrue ( p. matches ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"matches\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "96_9.txt": "{\n  \"file\": \"96_9.txt\",\n  \"assertion\": \"assertTrue ( p. match ( \\\"value\\\" ) )\\r\\n\",\n  \"test\": \"class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \\u003d new HashMap ( ) ; map . Arrays . put ( \\\"firstName\\\" , Arrays . asList ( \\\"cas\\\" , \\\"sso\\\" ) ) ; map . put ( \\\"lastName\\\" , \\\"user\\\" ) ; final Principal p \\u003d principalFactory . createPrincipal ( \\\"userid\\\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \\u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \\\"firstName\\\" ) ; configureMessageContextForPrincipal ( \\\"cas\\\" ) ; final String value \\u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \\\"value\\\" ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \\u003d p . getId ( ) ; final Object attrValue \\u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \\u003d\\u003d null ) { LOGGER . warn ( \\\"No\\u003csp\\u003eattribute\\u003csp\\u003evalue\\u003csp\\u003ecould\\u003csp\\u003ebe\\u003csp\\u003efound\\u003csp\\u003efor\\u003csp\\u003e[{}]\\\" ) ; return p . getId ( ) ; } String greetingPersonId \\u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \\u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \\u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \\\"Found\\u003csp\\u003emultiple\\u003csp\\u003eattribute\\u003csp\\u003evalues\\u003csp\\u003e[{}]\\u003csp\\u003efor\\u003csp\\u003e[{}]\\u003csp\\u003eto\\u003csp\\u003egreet.\\u003csp\\u003ePicked\\u003csp\\u003e[{}]\\\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \\u003d greetingPersonId ; } final MessageResolver resolver \\u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \\u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \\u003d\\u003d null ) || ( ( messages . length ) \\u003d\\u003d 0 ) ) { LOGGER . warn ( ( \\\"The\\u003csp\\u003egreeting\\u003csp\\u003emessage\\u003csp\\u003efor\\u003csp\\u003eprincipal\\u003csp\\u003e[{}]\\u003csp\\u003ecould\\u003csp\\u003enot\\u003csp\\u003ebe\\u003csp\\u003eresolved\\u003csp\\u003eby\\u003csp\\u003ethe\\u003csp\\u003e\\\" + \\\"code\\u003csp\\u003e[{}]\\u003csp\\u003ein\\u003csp\\u003eany\\u003csp\\u003eof\\u003csp\\u003ethe\\u003csp\\u003econfigured\\u003csp\\u003emessage\\u003csp\\u003eresource\\u003csp\\u003ebundles.\\u003csp\\u003eFalling\\u003csp\\u003eback\\u003csp\\u003eto\\u003csp\\u003eprincipal\\u003csp\\u003eid\\u003csp\\u003e[{}]\\\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\\r\\n\",\n  \"truth\": \"assertTrue ( value. contains ( \\\"cas\\\" ) )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"finished\",\n  \"parse context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg\": \"{\\n  \\\"argName\\\": \\\"match\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": true\\n}\",\n  \"result\": \"method call, not focal method\"\n}",
  "97_0.txt": "{\n  \"file\": \"97_0.txt\",\n  \"assertion\": \"assertEquals ( new file ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_1.txt": "{\n  \"file\": \"97_1.txt\",\n  \"assertion\": \"assertEquals ( read file ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_10.txt": "{\n  \"file\": \"97_10.txt\",\n  \"assertion\": \"assertEquals ( read file ( file ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( file ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_11.txt": "{\n  \"file\": \"97_11.txt\",\n  \"assertion\": \"assertEquals ( new Read ( file ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( file ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_12.txt": "{\n  \"file\": \"97_12.txt\",\n  \"assertion\": \"assertEquals ( read Read ( download ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( download ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_13.txt": "{\n  \"file\": \"97_13.txt\",\n  \"assertion\": \"assertEquals ( get file ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( get file ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_14.txt": "{\n  \"file\": \"97_14.txt\",\n  \"assertion\": \"assertEquals ( read file ( local ), new File )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( local ), new File ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_15.txt": "{\n  \"file\": \"97_15.txt\",\n  \"assertion\": \"assertEquals ( read File ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read File ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_16.txt": "{\n  \"file\": \"97_16.txt\",\n  \"assertion\": \"assertEquals ( new Read ( local ), new File )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( local ), new File ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_17.txt": "{\n  \"file\": \"97_17.txt\",\n  \"assertion\": \"assertEquals ( read Read ( file ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( file ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_18.txt": "{\n  \"file\": \"97_18.txt\",\n  \"assertion\": \"assertEquals ( new Local ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Local ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_19.txt": "{\n  \"file\": \"97_19.txt\",\n  \"assertion\": \"assertEquals ( new Stream ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Stream ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_2.txt": "{\n  \"file\": \"97_2.txt\",\n  \"assertion\": \"assertEquals ( new Read ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_20.txt": "{\n  \"file\": \"97_20.txt\",\n  \"assertion\": \"assertEquals ( get Read ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( get Read ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_21.txt": "{\n  \"file\": \"97_21.txt\",\n  \"assertion\": \"assertEquals ( read Read ( local ), new File )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( local ), new File ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_22.txt": "{\n  \"file\": \"97_22.txt\",\n  \"assertion\": \"assertEquals ( new file ( source ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( source ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_23.txt": "{\n  \"file\": \"97_23.txt\",\n  \"assertion\": \"assertEquals ( new file ( path ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( path ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_24.txt": "{\n  \"file\": \"97_24.txt\",\n  \"assertion\": \"assertEquals ( new file ( content ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( content ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_25.txt": "{\n  \"file\": \"97_25.txt\",\n  \"assertion\": \"assertEquals ( read Local ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Local ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_26.txt": "{\n  \"file\": \"97_26.txt\",\n  \"assertion\": \"assertEquals ( read Stream ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Stream ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_27.txt": "{\n  \"file\": \"97_27.txt\",\n  \"assertion\": \"assertEquals ( new file ( input ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( input ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_28.txt": "{\n  \"file\": \"97_28.txt\",\n  \"assertion\": \"assertEquals ( new file ( local ), local file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( local ), local file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_29.txt": "{\n  \"file\": \"97_29.txt\",\n  \"assertion\": \"assertEquals ( local file ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( local file ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_3.txt": "{\n  \"file\": \"97_3.txt\",\n  \"assertion\": \"assertEquals ( read Read ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_4.txt": "{\n  \"file\": \"97_4.txt\",\n  \"assertion\": \"assertEquals ( new file ( download ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( download ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_5.txt": "{\n  \"file\": \"97_5.txt\",\n  \"assertion\": \"assertEquals ( new file ( file ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( file ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_6.txt": "{\n  \"file\": \"97_6.txt\",\n  \"assertion\": \"assertEquals ( read file ( download ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( download ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_7.txt": "{\n  \"file\": \"97_7.txt\",\n  \"assertion\": \"assertEquals ( new Read ( download ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( download ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_8.txt": "{\n  \"file\": \"97_8.txt\",\n  \"assertion\": \"assertEquals ( new file ( local ), new File )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( local ), new File ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "97_9.txt": "{\n  \"file\": \"97_9.txt\",\n  \"assertion\": \"assertEquals ( new File ( local ), new file )\\r\\n\",\n  \"test\": \"class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \\u003d \\\"copyFromLocalFileToDstPathTest\\\" ; byte [ ] data \\u003d dataString . getBytes ( ) ; File localDir \\u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \\\"/localDir\\\" ) ) ; localDir . mkdir ( ) ; File localFile \\u003d generateFileContent ( \\\"/localDir/testFile\\\" , data ) ; alluxioInterpreter . interpret ( \\\"mkdir\\u003csp\\u003e/dstDir\\\" , null ) ; alluxioInterpreter . interpret ( ( ( \\\"copyFromLocal\\u003csp\\u003e\\\" + ( localFile . getPath ( ) ) ) + \\\"\\u003csp\\u003e/dstDir\\\" ) , null ) ; FileInStream fStream \\u003d fs . openFile ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) ; long fileLength \\u003d fs . getStatus ( new AlluxioURI ( \\\"/dstDir/testFile\\\" ) ) . getLength ( ) ; byte [ ] read \\u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new File ( local ), new file ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \\u003d Streams . parse ( in ) ; JsonElement labelJsonElement \\u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \\u003d ( labelJsonElement \\u003d\\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \\\"unchecked\\\" ) TypeAdapter \\u003c R \\u003e delegate \\u003d ( ( TypeAdapter \\u003c R \\u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \\u003d\\u003d null ) { throw new JsonParseException ( ( ( ( ( \\\"cannot\\u003csp\\u003edeserialize\\u003csp\\u003e\\\" + ( baseType ) ) + \\\"\\u003csp\\u003esubtype\\u003csp\\u003enamed\\u003csp\\u003e\\\" ) + label ) + \\\";\\u003csp\\u003edid\\u003csp\\u003eyou\\u003csp\\u003eforget\\u003csp\\u003eto\\u003csp\\u003eregister\\u003csp\\u003ea\\u003csp\\u003esubtype?\\\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( new String ( read ), dataString )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_0.txt": "{\n  \"file\": \"98_0.txt\",\n  \"assertion\": \"assertTrue ( figures. ends contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. ends contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_1.txt": "{\n  \"file\": \"98_1.txt\",\n  \"assertion\": \"assertTrue ( figures. ends empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. ends empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_10.txt": "{\n  \"file\": \"98_10.txt\",\n  \"assertion\": \"assertTrue ( figures. empty contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. empty contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_11.txt": "{\n  \"file\": \"98_11.txt\",\n  \"assertion\": \"assertTrue ( figures. empty empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. empty empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_12.txt": "{\n  \"file\": \"98_12.txt\",\n  \"assertion\": \"assertTrue ( figures. is contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. is contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_13.txt": "{\n  \"file\": \"98_13.txt\",\n  \"assertion\": \"assertTrue ( figures. is empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. is empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_14.txt": "{\n  \"file\": \"98_14.txt\",\n  \"assertion\": \"assertTrue ( figures. first contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. first contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_15.txt": "{\n  \"file\": \"98_15.txt\",\n  \"assertion\": \"assertTrue ( figures. first empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. first empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_16.txt": "{\n  \"file\": \"98_16.txt\",\n  \"assertion\": \"assertTrue ( figures. zero contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. zero contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_17.txt": "{\n  \"file\": \"98_17.txt\",\n  \"assertion\": \"assertTrue ( figures. zero empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. zero empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_18.txt": "{\n  \"file\": \"98_18.txt\",\n  \"assertion\": \"assertTrue ( figures. impl contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. impl contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_19.txt": "{\n  \"file\": \"98_19.txt\",\n  \"assertion\": \"assertTrue ( figures. has contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. has contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_2.txt": "{\n  \"file\": \"98_2.txt\",\n  \"assertion\": \"assertTrue ( figures. matches contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. matches contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_20.txt": "{\n  \"file\": \"98_20.txt\",\n  \"assertion\": \"assertTrue ( figures. impl empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. impl empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_21.txt": "{\n  \"file\": \"98_21.txt\",\n  \"assertion\": \"assertTrue ( figures. has empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. has empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_22.txt": "{\n  \"file\": \"98_22.txt\",\n  \"assertion\": \"assertTrue ( figures. all contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. all contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_23.txt": "{\n  \"file\": \"98_23.txt\",\n  \"assertion\": \"assertTrue ( figures. all empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. all empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_24.txt": "{\n  \"file\": \"98_24.txt\",\n  \"assertion\": \"assertTrue ( figures. equals contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. equals contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_25.txt": "{\n  \"file\": \"98_25.txt\",\n  \"assertion\": \"assertTrue ( figures. equals empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. equals empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_26.txt": "{\n  \"file\": \"98_26.txt\",\n  \"assertion\": \"assertTrue ( figures. e contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. e contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_27.txt": "{\n  \"file\": \"98_27.txt\",\n  \"assertion\": \"assertTrue ( figures. e empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. e empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_28.txt": "{\n  \"file\": \"98_28.txt\",\n  \"assertion\": \"assertTrue ( figures. test contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. test contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_29.txt": "{\n  \"file\": \"98_29.txt\",\n  \"assertion\": \"assertTrue ( figures. test empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. test empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_3.txt": "{\n  \"file\": \"98_3.txt\",\n  \"assertion\": \"assertTrue ( figures. matches empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. matches empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_4.txt": "{\n  \"file\": \"98_4.txt\",\n  \"assertion\": \"assertTrue ( figures. starts contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. starts contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_5.txt": "{\n  \"file\": \"98_5.txt\",\n  \"assertion\": \"assertTrue ( figures. starts empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. starts empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_6.txt": "{\n  \"file\": \"98_6.txt\",\n  \"assertion\": \"assertTrue ( figures. null contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. null contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_7.txt": "{\n  \"file\": \"98_7.txt\",\n  \"assertion\": \"assertTrue ( figures. null empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. null empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_8.txt": "{\n  \"file\": \"98_8.txt\",\n  \"assertion\": \"assertTrue ( figures. contains contains ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. contains contains ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "98_9.txt": "{\n  \"file\": \"98_9.txt\",\n  \"assertion\": \"assertTrue ( figures. contains empty ( ) )\\r\\n\",\n  \"test\": \"class X {public void extractFigDesc4 ( ) { String pargraphText \\u003d \\\"FIG.\\u003csp\\u003e1\\\" ; List \\u003c Figure \\u003e figures \\u003d new ArrayList \\u003c Figure \\u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. contains empty ( ) ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \\u003d null ; int figEnd \\u003d 0 ; String figText \\u003d \\\"\\\" ; Matcher matchFig \\u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \\u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFig . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \\u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \\u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \\u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \\u003d matchFigs . end ( ) ; figText \\u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \\u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \\\"^FIG\\\" ) ) { LOGGER . warn ( ( \\\"Unable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \\\"2.\\u003csp\\u003eUnable\\u003csp\\u003eto\\u003csp\\u003eParse\\u003csp\\u003ePatent\\u003csp\\u003eFigure\\u003csp\\u003eID:\\u003csp\\u003e\\u0027\\\" + pargraphText ) ) ; } } } if ( figure !\\u003d null ) { figureList . add ( figure ) ; } } }\\r\\n\",\n  \"truth\": \"assertTrue ( figures. isEmpty ( ) )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_0.txt": "{\n  \"file\": \"99_0.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_1.txt": "{\n  \"file\": \"99_1.txt\",\n  \"assertion\": \"assertEquals ( new byte [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_10.txt": "{\n  \"file\": \"99_10.txt\",\n  \"assertion\": \"assertEquals ( new b [ 1 ], b [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new b [ 1 ], b [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"new b[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"b[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "99_11.txt": "{\n  \"file\": \"99_11.txt\",\n  \"assertion\": \"assertEquals ( io b [ 1 ], b [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io b [ 1 ], b [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_12.txt": "{\n  \"file\": \"99_12.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 1 ], a [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], a [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_13.txt": "{\n  \"file\": \"99_13.txt\",\n  \"assertion\": \"assertEquals ( new byte [ 1 ], a [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], a [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"new byte[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"a[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "99_14.txt": "{\n  \"file\": \"99_14.txt\",\n  \"assertion\": \"assertEquals ( io 1 [ 1 ], a [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], a [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_15.txt": "{\n  \"file\": \"99_15.txt\",\n  \"assertion\": \"assertEquals ( io byte [ 1 ], a [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], a [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_16.txt": "{\n  \"file\": \"99_16.txt\",\n  \"assertion\": \"assertEquals ( new b [ 1 ], a [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new b [ 1 ], a [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"new b[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"a[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "99_17.txt": "{\n  \"file\": \"99_17.txt\",\n  \"assertion\": \"assertEquals ( io b [ 1 ], a [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io b [ 1 ], a [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_18.txt": "{\n  \"file\": \"99_18.txt\",\n  \"assertion\": \"assertEquals ( new 2 [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 2 [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_19.txt": "{\n  \"file\": \"99_19.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 2 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 2 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_2.txt": "{\n  \"file\": \"99_2.txt\",\n  \"assertion\": \"assertEquals ( io 1 [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_20.txt": "{\n  \"file\": \"99_20.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 1 ], byte [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], byte [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_21.txt": "{\n  \"file\": \"99_21.txt\",\n  \"assertion\": \"assertEquals ( new byte [ 2 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new byte [ 2 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_22.txt": "{\n  \"file\": \"99_22.txt\",\n  \"assertion\": \"assertEquals ( new byte [ 1 ], byte [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], byte [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_23.txt": "{\n  \"file\": \"99_23.txt\",\n  \"assertion\": \"assertEquals ( io 2 [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io 2 [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_24.txt": "{\n  \"file\": \"99_24.txt\",\n  \"assertion\": \"assertEquals ( io 1 [ 2 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 2 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_25.txt": "{\n  \"file\": \"99_25.txt\",\n  \"assertion\": \"assertEquals ( io 1 [ 1 ], byte [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], byte [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_26.txt": "{\n  \"file\": \"99_26.txt\",\n  \"assertion\": \"assertEquals ( io byte [ 2 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io byte [ 2 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_27.txt": "{\n  \"file\": \"99_27.txt\",\n  \"assertion\": \"assertEquals ( io byte [ 1 ], byte [ 2 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], byte [ 2 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_28.txt": "{\n  \"file\": \"99_28.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 0 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 0 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_29.txt": "{\n  \"file\": \"99_29.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 1 ], byte [ 0 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], byte [ 0 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_3.txt": "{\n  \"file\": \"99_3.txt\",\n  \"assertion\": \"assertEquals ( io byte [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_4.txt": "{\n  \"file\": \"99_4.txt\",\n  \"assertion\": \"assertEquals ( new 1 [ 1 ], b [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], b [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_5.txt": "{\n  \"file\": \"99_5.txt\",\n  \"assertion\": \"assertEquals ( new byte [ 1 ], b [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], b [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"new byte[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"b[1]\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "99_6.txt": "{\n  \"file\": \"99_6.txt\",\n  \"assertion\": \"assertEquals ( new b [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( new b [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_7.txt": "{\n  \"file\": \"99_7.txt\",\n  \"assertion\": \"assertEquals ( io 1 [ 1 ], b [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], b [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_8.txt": "{\n  \"file\": \"99_8.txt\",\n  \"assertion\": \"assertEquals ( io b [ 1 ], byte [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io b [ 1 ], byte [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "99_9.txt": "{\n  \"file\": \"99_9.txt\",\n  \"assertion\": \"assertEquals ( io byte [ 1 ], b [ 1 ] )\\r\\n\",\n  \"test\": \"class X {public void testGet ( ) { ByteBuffer bb1 \\u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \\\"012\\\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \\u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \\\"345\\\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \\u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \\\"6789\\\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \\u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \\u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \\u003d \\\"234567\\\" . getBytes ( ) ; for ( int i \\u003d 0 ; i \\u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], b [ 1 ] ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void get( Object  var24678 ) { ExpiringValue \\u003c V \\u003e expValue \\u003d map . get ( key ) ; if ( expValue !\\u003d null ) { return expValue . value ; } return null ; } }\\r\\n\",\n  \"truth\": \"assertEquals ( seg [ i ], block [ i ] )\\r\\n\",\n  \"stop parsing\": \"arg is null. It might be caused by assertion parse error.\"\n}",
  "9_0.txt": "{\n  \"file\": \"9_0.txt\",\n  \"assertion\": \"assertEquals ( instant, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"stop parsing\": \"arg1 \\u003d\\u003d arg2\",\n  \"trivial_check\": \"finished\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_1.txt": "{\n  \"file\": \"9_1.txt\",\n  \"assertion\": \"assertEquals ( null, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( null, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_10.txt": "{\n  \"file\": \"9_10.txt\",\n  \"assertion\": \"assertEquals ( instant, date )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, date ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_11.txt": "{\n  \"file\": \"9_11.txt\",\n  \"assertion\": \"assertEquals ( 0, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( 0, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_12.txt": "{\n  \"file\": \"9_12.txt\",\n  \"assertion\": \"assertEquals ( instant, 0 )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, 0 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"0\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_13.txt": "{\n  \"file\": \"9_13.txt\",\n  \"assertion\": \"assertEquals ( \\\"\\\", instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( \\\"\\\", instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_14.txt": "{\n  \"file\": \"9_14.txt\",\n  \"assertion\": \"assertEquals ( instant, \\\"\\\" )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, \\\"\\\" ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"\\\\\\\"\\\\\\\"\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_15.txt": "{\n  \"file\": \"9_15.txt\",\n  \"assertion\": \"assertEquals (Instant, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals (Instant, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"Instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_16.txt": "{\n  \"file\": \"9_16.txt\",\n  \"assertion\": \"assertEquals ( instant,Instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant,Instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"Instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_17.txt": "{\n  \"file\": \"9_17.txt\",\n  \"assertion\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( expected, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"true\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"expected\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"Good assertion\"\n}",
  "9_18.txt": "{\n  \"file\": \"9_18.txt\",\n  \"assertion\": \"assertEquals ( 2, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( 2, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_19.txt": "{\n  \"file\": \"9_19.txt\",\n  \"assertion\": \"assertEquals ( instant, 2 )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, 2 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"2\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_2.txt": "{\n  \"file\": \"9_2.txt\",\n  \"assertion\": \"assertEquals ( instant, null )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, null ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"null\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_20.txt": "{\n  \"file\": \"9_20.txt\",\n  \"assertion\": \"assertEquals ( 3, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( 3, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_21.txt": "{\n  \"file\": \"9_21.txt\",\n  \"assertion\": \"assertEquals ( instant, 3 )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, 3 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"3\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_22.txt": "{\n  \"file\": \"9_22.txt\",\n  \"assertion\": \"assertEquals ( epoch, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( epoch, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"epoch\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_23.txt": "{\n  \"file\": \"9_23.txt\",\n  \"assertion\": \"assertEquals ( instant, epoch )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, epoch ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"epoch\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_24.txt": "{\n  \"file\": \"9_24.txt\",\n  \"assertion\": \"assertEquals ( 2010, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( 2010, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"2010\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_25.txt": "{\n  \"file\": \"9_25.txt\",\n  \"assertion\": \"assertEquals ( leap, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( leap, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"leap\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_26.txt": "{\n  \"file\": \"9_26.txt\",\n  \"assertion\": \"assertEquals ( now, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( now, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"now\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_27.txt": "{\n  \"file\": \"9_27.txt\",\n  \"assertion\": \"assertEquals ( instant, now )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, now ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"now\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_28.txt": "{\n  \"file\": \"9_28.txt\",\n  \"assertion\": \"assertEquals ( 5, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( 5, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"5\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_29.txt": "{\n  \"file\": \"9_29.txt\",\n  \"assertion\": \"assertEquals ( instant, 5 )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, 5 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"5\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_3.txt": "{\n  \"file\": \"9_3.txt\",\n  \"assertion\": \"assertEquals ( Instant, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( Instant, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"Instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_4.txt": "{\n  \"file\": \"9_4.txt\",\n  \"assertion\": \"assertEquals ( instant, Instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, Instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"Instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_5.txt": "{\n  \"file\": \"9_5.txt\",\n  \"assertion\": \"assertEquals ( 1, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( 1, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_6.txt": "{\n  \"file\": \"9_6.txt\",\n  \"assertion\": \"assertEquals ( instant, 1 )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, 1 ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"1\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_7.txt": "{\n  \"file\": \"9_7.txt\",\n  \"assertion\": \"assertEquals ( UTC, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( UTC, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"UTC\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_8.txt": "{\n  \"file\": \"9_8.txt\",\n  \"assertion\": \"assertEquals ( instant, UTC )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( instant, UTC ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"UTC\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}",
  "9_9.txt": "{\n  \"file\": \"9_9.txt\",\n  \"assertion\": \"assertEquals ( date, instant )\\r\\n\",\n  \"test\": \"class X {public void testJSDate ( ) { ScriptEngineManager factory \\u003d new ScriptEngineManager ( ) ; ScriptEngine engine \\u003d factory . getEngineByName ( \\\"nashorn\\\" ) ; Object obj \\u003d engine . eval ( \\\"new\\u003csp\\u003eDate(2010,\\u003csp\\u003e1,\\u003csp\\u003e2);\\\" ) ; ScriptObjectMirror jsDate \\u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \\u003d ( ( double ) ( jsDate . callMember ( \\\"getTime\\\" ) ) ) ; Instant instant \\u003d Converters . toDate ( timestampLocal ) ; String someDate \\u003d \\\"2010-02-02\\\" ; DateParsing parsing \\u003d new DateParsing ( someDate ) ; Instant expected \\u003d parsing . parse ( someDate ) ; assertEquals ( date, instant ) ; }  }\\r\\n\",\n  \"focal method\": \"class Y{ public void parse( String  var24678 ) { s \\u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\\r\\n\",\n  \"truth\": \"assertEquals ( expected, instant )\\r\\n\",\n  \"trivial_check\": \"finished\",\n  \"parse focal method\": \"false\",\n  \"find type in test\": \"instant\",\n  \"parse_context\": \"finished\",\n  \"correct answer\": \"false\",\n  \"arg1\": \"{\\n  \\\"argName\\\": \\\"date\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"arg2\": \"{\\n  \\\"argName\\\": \\\"instant\\\",\\n  \\\"fm\\\": false,\\n  \\\"fieldAccess\\\": false,\\n  \\\"type\\\": \\\"Instant\\\",\\n  \\\"methodCall\\\": false\\n}\",\n  \"result\": \"cannot solve all the type info\"\n}"
}
